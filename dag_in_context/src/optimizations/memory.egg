; Recommended VSCode setting:

(ruleset memory)

(datatype Cell (CellOf i64))

(sort ExprSetPrim (Set Expr))

(datatype ExprSet (ES ExprSetPrim))

(function ExprSet-intersect (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-intersect (ES set1) (ES set2)) (ES (set-intersect set1 set2))
         :ruleset always-run)
(function ExprSet-union (ExprSet ExprSet) ExprSet)
(rewrite (ExprSet-union (ES set1) (ES set2)) (ES (set-union set1 set2))
         :ruleset always-run)
(relation ExprSet-contains (ExprSet Expr))
(rule ((ES set1) (set-contains set1 x))
      ((ExprSet-contains (ES set1) x))
      :ruleset always-run)
(function ExprSet-insert (ExprSet Expr) ExprSet)
(rewrite (ExprSet-insert (ES set1) x)
         (ES (set-insert set1 x))
         :ruleset always-run)
(function ExprSet-length (ExprSet) i64)
(rewrite (ExprSet-length (ES set1)) (set-length set1) :ruleset always-run)

; ============================
; PointsToCells
; ============================

; [ {0->[4,5], 1->[0,0]}, {0->[0,0]}]

(function Map<Union-List<i64+IntInterval>> (List<List<i64+IntInterval>> List<List<i64+IntInterval>>) List<List<i64+IntInterval>>)
(rewrite (Map<Union-List<i64+IntInterval>> (Nil-List<List<i64+IntInterval>>) (Nil-List<List<i64+IntInterval>>))
         (Nil-List<List<i64+IntInterval>>)
         :ruleset always-run)
(rewrite
  (Map<Union-List<i64+IntInterval>> (Cons-List<List<i64+IntInterval>> hd1 tl1) (Cons-List<List<i64+IntInterval>> hd2 tl2))
  (Cons-List<List<i64+IntInterval>> (Union-List<i64+IntInterval> hd1 hd2) (Map<Union-List<i64+IntInterval>> tl1 tl2))
  :ruleset always-run
)

(function Map<Intersect-List<i64+IntInterval>> (List<List<i64+IntInterval>> List<List<i64+IntInterval>>) List<List<i64+IntInterval>>)
(rewrite (Map<Intersect-List<i64+IntInterval>> (Nil-List<List<i64+IntInterval>>) (Nil-List<List<i64+IntInterval>>))
         (Nil-List<List<i64+IntInterval>>)
         :ruleset always-run)
(rewrite
  (Map<Intersect-List<i64+IntInterval>> (Cons-List<List<i64+IntInterval>> hd1 tl1) (Cons-List<List<i64+IntInterval>> hd2 tl2))
  (Cons-List<List<i64+IntInterval>> (Intersect-List<i64+IntInterval> hd1 hd2) (Map<Intersect-List<i64+IntInterval>> tl1 tl2))
  :ruleset always-run
)

(relation LMIIPointsNowhere (List<List<i64+IntInterval>>))
(rule ((= l (Nil-List<List<i64+IntInterval>>)))
      ((LMIIPointsNowhere l))
      :ruleset always-run)
(rule ((= l (Cons-List<List<i64+IntInterval>> hd tl))
       (LMIIPointsNowhere tl)
       (= (Nil-List<i64+IntInterval>) hd))
      ((LMIIPointsNowhere l))
      :ruleset always-run)

(datatype Pointees
          (TuplePointees List<List<i64+IntInterval>>)
          (PtrPointees List<i64+IntInterval>)
          (PointsAnywhere))

(function UnionPointees (Pointees Pointees) Pointees)
(rewrite (UnionPointees (PointsAnywhere) _)
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (UnionPointees _ (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (UnionPointees (PtrPointees mii1) (PtrPointees mii2))
         (PtrPointees (Union-List<i64+IntInterval> mii1 mii2))
         :ruleset always-run)
(rewrite (UnionPointees (TuplePointees l1) (TuplePointees l2))
         (TuplePointees (Map<Union-List<i64+IntInterval>> l1 l2))
         :ruleset always-run)

(function IntersectPointees (Pointees Pointees) Pointees)
(rewrite (IntersectPointees (PointsAnywhere) _)
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (IntersectPointees _ (PointsAnywhere))
         (PointsAnywhere)
         :ruleset always-run)
(rewrite (IntersectPointees (PtrPointees mii1) (PtrPointees mii2))
         (PtrPointees (Intersect-List<i64+IntInterval> mii1 mii2))
         :ruleset always-run)
(rewrite (IntersectPointees (TuplePointees l1) (TuplePointees l2))
         (TuplePointees (Map<Intersect-List<i64+IntInterval>> l1 l2))
         :ruleset always-run)

(function ConcatPointees (Pointees Pointees) Pointees)

(relation PointsNowhere (Pointees))
(rule ((= pointees (PtrPointees m))
       (= (Nil-List<i64+IntInterval>) m))
      ((PointsNowhere pointees))
      :ruleset always-run)
(rule ((= pointees (TuplePointees l))
       (LMIIPointsNowhere l))
      ((PointsNowhere pointees))
      :ruleset always-run)

;                             arg pointees  result pointees
(function PointsToCells (Expr Pointees)     Pointees) 

; Top-level demand
(rule ((Function name in-ty out-ty body))
      ((PointsToCells body (PointsAnywhere)))
      :ruleset always-run)

(relation DemandPointsToCells (Expr))
(rule ((DemandPointsToCells e))
      ((PointsToCells e (PointsAnywhere)))
      :ruleset always-run)

; Concat get single ptradd if
; aps = "arg pointees"
; (rewrite
  ; (PointsToCells (Concat x y) aps)
  ; (ConcatPointees (PointsToCells x aps) (PointsToCells y aps))
  ; :ruleset always-run)


      ; (

      ; ))

; (Alloc 0 amt)
; (Interval amt 0 7)


;   (PtrPointees {0->[0,0]}))
;   (PtrPointees {0->[0,1]}))
;   (PtrPointees {0->[0,2]}))
;   (PtrPointees {0->[0,4))
;   (PtrPointees {0->[0,7]}))
;   (PtrPointees {0->[0,7]}))

; (PointsToCells
;   (Concat (Arg int*) (PtrAdd (Arg int*) 1))
;   (PtrPointees {0->[0,0]}))
; = (TuplePointees)

; arg pointees * loop in * loop out * i64 -> result pointees
; (function PointsToCellsAtIter (Expr Expr))

; (PointsToCells loopin arg-pointees) = pointees
; (Loop loopin loopout)
; ---
; (set (PointsToCellsAtIter arg-pointees loopin loopout 0))

; (PointsToCellsAtIter arg-pointees loopin loopout i) = pointees
; -----
; set PointsToCellsAtIter i + 1 to (PointToCells pointees loopout)

; (PointsToCellsAtIter arg-pointees loopin loopout i) = pointees1
; (PointsToCellsAtIter arg-pointees loopin loopout (- i 1) = pointees2
; (IsResolved pointees1)
; (IsResolved pointees2)
; ---
; if pointees1 == pointees2







;                       pointer-typed expression
; (function PointsToCells (Expr) CellSet :merge (CellSet-intersect old new))

; (rule ((= e (Alloc id sz state ty)))
;       ((set (PointsToCells (Get e 0)) (CS (set-of (CellOf id)))))
;       :ruleset memory)

; ; Offsets refer to the same cell, for now
; (rule ((= e (Bop (PtrAdd) x y))
;        (= xcells (PointsToCells x)))
;       ((set (PointsToCells e) xcells))
;       :ruleset memory)

; (rule ((= e (If pred t f))
;        (= tcells (PointsToCells (Get t j)))
;        (= fcells (PointsToCells (Get f j))))
;       ((set (PointsToCells (Get e j)) (CellSet-union tcells fcells)))
;       :ruleset memory)

; (= loop inputs outputs)
; (PointsToCellsAtIter loop i in_pts) out_pts
; ----
; ; To get: (PointsToCellsAtIter loop (+ i 1) in_puts)
; (PointsToCells outputs out_pts) ; demand

; (= loop inputs outputs)
; (PointsToCellsAtIter loop i in_pts) out_pts
; (= out_pts2 (PointsToCell))
; (!= out_pts2 out_pts) ; so we don't count to infin
; ----
; (set
  ; (PointsToCellsAtIter loop (+ i 1) inputs)
  ; out_pts
  ; )

; (rule ((= loop (Loop inputs outputs))
       ; (= (PointsToCellsAtIter loop i       in_pts:vec<set<cell,offset>>)    out_pts=vec<set<cell,offset>>)
       ; (PointsToCellsAtIter loop (+ i 1)    in_pts:vec<set<cell,offset>>    vec<set<cell,offset>>))
      ; ((set (PointsToCells))


      
      ; ))

; ============================
; Update CellHasValues
; ============================

;                       program point, cell
(function CellHasValues (Expr Cell) ExprSet :merge (ExprSet-intersect old new))

; TODO: add loop rules

; note: We could have a specialized rule for (set-len cells 1) where we overwrite instead of union
; (rule ((= e (Top (Write) ptr val state))
       ; (= pointees (PointsToCells (PointsAnywhere) ptr)))
       ; (PointeesC)
      ; (()))

; TODO: make sensitive to offsets
(rule ((= e (Top (Write) ptr val state))
       (= (PtrPointees cells) (PointsToCells ptr (PointsAnywhere)))
       (At-List<i64+IntInterval> cells any-idx alloc-id offsets)
       (= vals (CellHasValues state cell)))
      ((set (CellHasValues e cell) (ExprSet-insert vals val)))
      :ruleset memory)

; ============================
; Update PointsTo
; ============================

;                    pointer, pointer
(relation Dontalias (Expr Expr Pointees))
;                   outer, pointer
; merge function???
(function PointsTo (Expr Expr)  Expr)

; TODO: gate with body-contains and type
(rule (
      ;  (HasType ptr1 (PointerT ty))
      ;  (HasType ptr2 (PointerT ty))
       (= pointees1 (PointsToCells ptr1 arg-pointees))
       (= pointees2 (PointsToCells ptr2 arg-pointees)))
      ((IntersectPointees pointees1 pointees2))
      :ruleset always-run)

(rule ((PointsNowhere
         (IntersectPointees
           (PointsToCells ptr1 arg-pointees)
           (PointsToCells ptr2 arg-pointees))))
      ((Dontalias ptr1 ptr2 arg-pointees))
      :ruleset always-run)

; For a write, mark the given expression as containing `data`.
; Propagate the previous values of any expression that definitely does not alias `addr`.
(rule ((= e (Top (Write) addr data state)))
      ((set (PointsTo e addr) data)) :ruleset memory)
(rule ((= e (Top (Write) addr data state))
       (= otherdata (PointsTo state otheraddr))
       (Dontalias addr otheraddr (PointsAnywhere)))
      ((set (PointsTo e otheraddr) otherdata)) :ruleset memory)

; Special-case: no intervening effects between load and write, elide the write
; entirely (if write isn't otherwise used).
; TODO: This is a general problem. Loads that get removed shouldn't really
; have a state edge, but they need one to feed into further effects.
; (rule ((= e (Bop (Load) addr (Top (Write) addr v state))))
;       ((union (Get e 0) v)
;        (union (Get e 1) state)) :ruleset memory)

(rule ((= e (Bop (Load) addr state))
       (= v (PointsTo state addr)))
      ((union (Get e 0) v)
       (union (Get e 1) state)) :ruleset memory)

; (function PointsTOCells )

(datatype Cell (CellOf i64))

(sort ExprSet (Set Expr))
(sort CellSet (Set Cell))

(ruleset memory)

;                       program point, cell
(function CellHasValues (Expr Cell) ExprSet :merge (set-intersect old new))
;                       program point, pointer-typed expression
(function PointsToCells (Expr Expr) CellSet :merge (set-intersect old new))

; ============================
; Update PointsToCells
; ============================

(function StateOf (Expr) Expr)
(rewrite (StateOf e) (Get e 1) :ruleset always-run)
(function AddrOf (Expr) Expr)
(rewrite (AddrOf e) (Get e 0) :ruleset always-run)

(rule ((= e (Alloc id sz state ty)))
      ((set (PointsToCells (Get e 1) (Get e 0)) (set-of (CellOf id))))
      :ruleset memory)


; Offsets refer to the same cell, for now
(rule ((= e (Bop (PtrAdd) x y))
       (= xcells (PointsToCells state x))
       (= ycells (PointsToCells state y)))
      ((set (PointsToCells state e) (set-union xcells ycells)))
      :ruleset memory)

; Move down the state path
(rule ((= e (Alloc id sz state ty))
       (= xcells (PointsToCells state x)))
      ((set (PointsToCells (Get e 1) x) xcells))
      :ruleset memory)

; Move down the state path
(rule ((= e (Bop (Load) any-ptr state))
       (= xcells (PointsToCells state x)))
      ((set (PointsToCells (Get e 1) x) xcells))
      :ruleset memory)

; Move down the state path
(rule ((= e (Bop (Print) any-val state))
       (= xcells (PointsToCells state x)))
      ((set (PointsToCells e x) xcells))
      :ruleset memory)

; Move down the state path
(rule ((= e (Top (Write) any-addr any-val state))
       (= xcells (PointsToCells state x)))
      ((set (PointsToCells e x) xcells))
      :ruleset memory)

(rule ((= e (If pred t f))
       (= tcells (PointsToCells (Get t i) (Get t j)))
       (= fcells (PointsToCells (Get f i) (Get f j))))
      ((set (PointsToCells (Get e i) (Get e j)) (set-union tcells fcells)))
      :ruleset memory)

; ============================
; Update CellHasValues
; ============================

; TODO: add loop rules

; note: We could have a specialized rule for (set-len cells 1) where we overwrite instead of union
(rule ((= e (Top (Write) ptr val state))
       (= cells (PointsToCells state ptr))
       (set-contains cells cell)
       (= vals (CellHasValues state cell)))
      ((set (CellHasValues e cell) (set-insert vals val)))
      :ruleset memory)

; ============================
; Update PointsTo
; ============================

;                    outer, pointer, pointer
(relation Dontalias (Expr Expr Expr))
;                   outer, pointer
; merge function???
(function PointsTo (Expr Expr)  Expr)

(rule ((= cs1 (PointsToCells outer ptr1))
       (= cs2 (PointsToCells outer ptr2))
       (= 0 (set-length (set-intersect cs1 cs2))))
      ((Dontalias outer ptr1 ptr2)) :ruleset memory)

; For a write, mark the given expression as containing `data`.
; Propagate the previous values of any expression that definitely does not alias `addr`.
(rule ((= e (Top (Write) addr data state)))
      ((set (PointsTo e addr) data)) :ruleset memory)
(rule ((= e (Top (Write) addr data state))
       (= otherdata (PointsTo state otheraddr))
       (Dontalias state addr otheraddr))
      ((set (PointsTo e otheraddr) otherdata)) :ruleset memory)

; Special-case: no intervening effects between load and write, elide the write
; entirely (if write isn't otherwise used).
; TODO: This is a general problem. Loads that get removed shouldn't really
; have a state edge, but they need one to feed into further effects.
; (rule ((= e (Bop (Load) addr (Top (Write) addr v state))))
;       ((union (Get e 0) v)
;        (union (Get e 1) state)) :ruleset memory)

(rule ((= e (Bop (Load) addr state))
       (= v (PointsTo state addr)))
      ((union (Get e 0) v)
       (union (Get e 1) state)) :ruleset memory)
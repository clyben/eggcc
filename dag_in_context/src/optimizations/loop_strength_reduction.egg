;; in-loop
;;
;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a += d
;;     d += c

; TODO: this optimization does not get extracted if the multiplications
; for the initial value of d and the update to d do not get constant folded.
; To fix this, we would need to:
;   1. move the multiplication in the update to d outside the loop
;   2. count loop bodies as higher cost, so moving a multiplication outside
;       the loop reduces the overall cost of the program

(ruleset loop-strength-reduction)


; Finds invariants/constants within a body.
; Columns: body; value of invariant in inputs; value of invariant in outputs

;; Get the input and output value of an invariant, or constant int, within the loop
;; TODO (start by doing constant only)
;;             loop in   out
(relation inv (Expr Expr Expr))
(rule (
    (= loop (DoWhile inputs pred-and-body))
    (= (Get outputs (+ i 1)) (Get (Arg arg-type) i)))
    ((inv loop (Get inputs (+ i 1)) (Get (Arg arg-type) i))) :ruleset always-run)
(rule (
    (= constant (Const c out-type))
    (= loop (DoWhile inputs pred-and-body))
    (ContextOf constant (InLoop inputs pred-and-body))
    (HasType inputs in-type)
    )
    ((inv loop (Const c in-type) constant)) :ruleset always-run)

(rule 
    (
        ;; Find loop
        (= old-loop (DoWhile inputs pred-and-outputs))

        ; Find loop variable (argument that gets incremented with an invariant)
        (inv old-loop loop-incr-in loop-incr-out)
        ; Since the first el of pred-and-outputs is the pred, we need to offset i
        (= (Get pred-and-outputs (+ i 1)) (Bop (Add) (Get (Arg arg-type) i) loop-incr-out))

        ; Find invariant where input is same as output, or constant
        (inv old-loop c-in c-out)

        ; Find multiplication of loop variable and invariant
        (= old-mul (Bop (Mul) c-out (Get (Arg arg-type) i)))
        (ContextOf old-mul (InLoop inputs pred-and-outputs))
    )
    (
        ; Each time we need to update d by the product of the multiplied constant and the loop increment
        (let addend (Bop (Mul) c-out loop-incr-out))

        ; n is index of our new, temporary variable d
        (let n (tuple-length inputs))

        ; Initial value of d is i * c
        (let d-init (Bop (Mul) c-in (Get inputs i)))

        ; Value of d in loop
        (let d-out (Bop (Add) (Get (Arg arg-type) i) addend))

        ; Construct optimized theta
        (let new-inputs (Concat inputs (Single d-init)))
        (let new-pred-and-outputs (Concat pred-and-outputs (Single d-out)))
        (let new-loop (DoWhile new-inputs new-pred-and-outputs))

        ; Substitute d for the *i expression
        (Subst inf-fuel (InLoop new-inputs new-pred-and-outputs) (Get (Arg arg-type) n) old-mul)

        ; Project all but last
        (union old-loop (SubTuple new-loop 0 n))
    )
    :ruleset loop-strength-reduction
)
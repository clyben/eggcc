; TODO: this is unsound because some loops don't terminate
; ;; Pass through thetas
; (rule ((= lhs (Get loop i))
;        (= loop (DoWhile inputs pred-outputs))
;        (= (Get pred-outputs (+ i 1)) (Get (Arg _) i))
;        (= passed-through (Get inputs i)))
;       ((union lhs passed-through))
;       :ruleset always-run)

;; Pass through switch arguments
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Get (Arg _ _ctx0) j))
       (= (Get branch1 i) (Get (Arg _ _ctx1) j))
       (= passed-through (Get inputs j))
       (HasType lhs lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union lhs passed-through))
      :ruleset always-run)

(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Get (Arg _ _ctx0) j))
       (= (Get branch1 i) (Get (Arg _ _ctx1) j))
       (= passed-through (Get inputs j))
       (HasType lhs lhs_ty)
       (= lhs_ty (Base (StateT))))
      ((panic "TODO: state edge passthrough"))
      :ruleset always-run)

;; Pass through switch predicate
(rule ((= lhs (Get switch i))
       (= switch (Switch pred inputs branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Const (Bool false) _ _ctx0))
       (= (Get branch1 i) (Const (Bool true) _ _ctx1)))
      ((union lhs pred))
      :ruleset always-run)

;; Pass through if arguments
(rule ((= if (If pred inputs then_ else_))
       (= jth-inside (Get (Arg _ _then_ctx) j))
       (= (Get then_ i) jth-inside)
       (= (Get else_ i) (Get (Arg _ _else_ctx) j))
       (HasType jth-inside lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union (Get if i) (Get inputs j)))
      :ruleset always-run)

; Pass through if state edge arguments
; To maintain the invariant, we have to union the other outputs with a pure if statement
(rule ((= lhs (Get outputs i))
       (= outputs (If pred inputs then_ else_))

       (= (Get then_ i) (Get (Arg (TupleT arg_ty) then_ctx) j))
       (= (Get else_ i) (Get (Arg (TupleT arg_ty) else_ctx) j))
       (= passed-through (Get inputs j))

       (HasType lhs lhs_ty)
       (= lhs_ty (Base (StateT)))

       (= inputs_len  (tuple-length inputs))
       (= outputs_len (tuple-length outputs)))

      ((let new_inputs         (TupleMinusOne    inputs j))
       (let new_arg_ty (TupleT (TypeListMinusOne arg_ty j)))
       
       (let new_then_ctx (InIf true  pred new_inputs))
       (let new_else_ctx (InIf false pred new_inputs))

       (let new_then_args (TupleMinusOne (Arg new_arg_ty new_then_ctx) j)) ; THIS IS WRONG
       (let new_else_args (TupleMinusOne (Arg new_arg_ty new_else_ctx) j)) ; THIS IS WRONG

       (let old_then    (TupleMinusOne then_   i))
       (let old_else    (TupleMinusOne else_   i))

       (let new_then (DropAt new_then_ctx j old_then))
       (let new_else (DropAt new_else_ctx j old_else))

       (let old_outputs (TupleMinusOne outputs i))
       (let new_if (If pred new_inputs new_then new_else))
       (union new_if old_outputs)

       (union lhs passed-through))
      :ruleset always-run)

;; Pass through if predicate
(rule ((= if (If pred inputs then_ else_))
       (= (Get then_ i) (Const (Bool true) _ _thenctx))
       (= (Get else_ i) (Const (Bool false) _ _elsectx)))
      ((union (Get if i) pred))
      :ruleset always-run)

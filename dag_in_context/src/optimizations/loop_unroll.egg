;; Some simple simplifications of loops
(ruleset loop-unroll)
(ruleset loop-peel)

;;                      inputs, outputs -> number of iterations
(function LoopNumItersGuess (Expr Expr) i64 :merge (max 1 (min old new)))

;; by default, guess that all loops run 1000 times
(rule ((DoWhile inputs outputs))
      ((set (LoopNumItersGuess inputs outputs) 1000))
      :ruleset always-run)


;; loop peeling rule
(rule
 ((= lhs (DoWhile inputs outputs))
  (ContextOf lhs ctx)
  (HasType inputs inputs-ty)
  (= outputs-len (tuple-length outputs))
  (= old_cost (LoopNumItersGuess inputs outputs)))
 ((let executed-once
    (Subst ctx inputs outputs))
  (let executed-once-body
     (SubTuple executed-once 1 (- outputs-len 1)))
  (let then-ctx
    (InIf true (Get executed-once 0) executed-once-body))
  (let else-ctx
    (InIf false (Get executed-once 0) executed-once-body))
  (union lhs
    ;; check if we need to continue executing the loop
    (If (Get executed-once 0)
        executed-once-body ;; inputs are the body executed once
        (DoWhile (Arg inputs-ty then-ctx)
          outputs) ;; right now, loop unrolling shares the same outputs, but we could add more context here
        (Arg inputs-ty else-ctx)))
   (set (LoopNumItersGuess (Arg inputs-ty then-ctx) outputs) (- old_cost 1))
    )
 :ruleset loop-peel)

;; unroll a loop with constant bounds and initial value
(rule
  ((= lhs (DoWhile inputs outputs))
   (= num-inputs (tuple-length inputs))
   (= pred (Get outputs 0))
   ;; iteration counter starts at start_const
   (= (Const (Int start_const) _ty1 _ctx1) (Get inputs counter_i))
   ;; updated counter at counter_i
   (= next_counter (Get outputs (+ counter_i 1)))
   ;; increments by one each loop
   (= next_counter (Bop (Add) (Get (Arg _ty _ctx) counter_i)
                              (Const (Int 1) _ty2 _ctx2)))
   ;; while less than end_constant
   (= pred (Bop (LessThan) next_counter
                           (Const (Int end_constant) _ty3 _ctx3)))
   ;; start and end constant is a multiple of 4 and greater than start_const
   (> end_constant start_const)
   (= (% start_const 4) 0)
   (= (% end_constant 4) 0)
   (= old_cost (LoopNumItersGuess inputs outputs))
  )
  (
    (let one-iter (SubTuple outputs 1 num-inputs))
    (let unrolled
        (Subst (TmpCtx) one-iter
          (Subst (TmpCtx) one-iter
            (Subst (TmpCtx) one-iter
               outputs))))
    (union lhs
      (DoWhile inputs
        unrolled))
    (let actual-ctx (InLoop inputs unrolled))
    (union (TmpCtx) actual-ctx)

    (set (LoopNumItersGuess inputs unrolled) (/ old_cost 4))
    (delete (TmpCtx))
  )
  :ruleset loop-unroll)



(ruleset switch_rewrite)

; if (a and b) X Y ~~> if a (if b X Y) Y
(rule ((= lhs (If (Bop (And) a b) ins X Y))
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_pred    (Get      (InContext (InIf true  a outer_ins) (Arg outer_ins_ty)) 0))
       (let sub_arg_true  (SubTuple (InContext (InIf true  a outer_ins) (Arg outer_ins_ty)) 1 len))
       (let sub_arg_false (SubTuple (InContext (InIf false a outer_ins) (Arg outer_ins_ty)) 1 len))

       (let inner_X (Subst (InIf true  inner_pred sub_arg_true) (Arg (TupleT ins_ty)) X))
       (let inner_Y (Subst (InIf false inner_pred sub_arg_true) (Arg (TupleT ins_ty)) Y))
       (let outer_Y (Subst (InIf false a          outer_ins)    sub_arg_false         Y))

       (let inner (If inner_pred sub_arg_true inner_X inner_Y))
       (union lhs (If a          outer_ins    inner   outer_Y)))

       :ruleset switch_rewrite)

(rewrite (If (InContext ctx (Const (Bool true) ty)) ins thn els)
         (Subst ctx ins thn)
         :ruleset switch_rewrite)

(rewrite (If (InContext ctx (Const (Bool false) ty)) ins thn els)
         (Subst ctx ins els)
         :ruleset switch_rewrite)

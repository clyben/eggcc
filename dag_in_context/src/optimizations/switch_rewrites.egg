(ruleset switch_rewrite)

; if (a and b) X Y ~~> if a (if b X Y) Y
(rule ((= lhs (If (Bop (And) a b) ins X Y))
       (ExprIsPure b)
       (HasType ins (TupleT ins_ty))
       (= len (tuple-length ins)))

      ((let outer_ins (Concat (Single b) ins))
       (let outer_ins_ty (TupleT (TCons (BoolT) ins_ty)))

       (let inner_ctx (InIf true a outer_ins))
       (let inner_pred (Get (InContext inner_ctx (Arg outer_ins_ty)) 0))
       (let inner_ins (SubTuple (InContext inner_ctx (Arg outer_ins_ty)) 1 len))

       (let inner_X (Subst (InIf true inner_pred inner_ins) (Arg (TupleT ins_ty)) X))
       (let inner_Y (Subst (InIf false inner_pred inner_ins) (Arg (TupleT ins_ty)) Y))
       (let outer_Y (Subst (InIf false a outer_ins) inner_ins Y))

       (let inner (If inner_pred inner_ins inner_X inner_Y))
       (union lhs (If a outer_ins inner outer_Y)))

       :ruleset switch_rewrite)

(rewrite (If (InContext ctx (Const (Bool true) ty)) ins thn els)
         (Subst ctx ins thn)
         :ruleset switch_rewrite)

(rewrite (If (InContext ctx (Const (Bool false) ty)) ins thn els)
         (Subst ctx ins els)
         :ruleset switch_rewrite)

;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst-helpers)
(ruleset subst)

(let inf-fuel 1000000)

;; (Subst fuel assumption to in) substitutes to for `(Arg ty)` in `in`.
;; It also replaces any contexts found by updating them to `assumption`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
;; Subst rules always saturate, even when the fuel is infinite. The fuel is there to control
;; exponential substitution for optimizations like function inlining.
(function Subst (i64 Assumption Expr Expr) Expr :unextractable)
;; (SubstLeaf to in) substitutes `to` for `in` in a leaf node `in`
;; SubstLeaf assumes context has already been added
(function SubstLeaf (Expr Expr) Expr :unextractable)
(function SubstList (i64 Assumption Expr ListExpr) ListExpr :unextractable)


;; if you find a subst with a higher fuel than yours, subsume this one
(rule ((= lower (Subst fuel1 assum to in))
       (= higher (Subst fuel2 assum to in))
       (> fuel2 fuel1))
      ((union lower higher)
       (subsume (Subst fuel1 assum to in)))
      :ruleset subst-helpers)

;; Base case- leaf nodes
;; leaf node without context
(rule ((= lhs (Subst fuel assum to leaf))
       (IsLeaf leaf))
      ((union lhs (InContext assum (SubstLeaf to leaf))))
      :ruleset subst)
;; leaf node with loop context
(rule ((= lhs (Subst fuel assum to (InContext (InLoop inputs body) leaf)))
       (IsLeaf leaf))
      ((union lhs (InContext assum (SubstLeaf to leaf))))
      :ruleset subst)

;; modify inif context, doesn't need to be on a leaf
(rule ((= lhs (Subst fuel assum to (InContext (InIf branch pred) expr))))
      ((union lhs
        (InContext
          (InIf branch (Subst (- fuel 1) assum to pred))
          (Subst (- fuel 1) assum to expr))))
      :ruleset subst)


;; substitute for a leaf node- interested case is (Arg ty)
(rewrite (SubstLeaf to (Arg ty))
         to
         :ruleset subst)
(rewrite (SubstLeaf to (Const constant ty))
         (Const constant ty2)
         :when ((HasArgType to ty2))
         :ruleset subst)
(rewrite (SubstLeaf to (Empty ty))
         (Empty ty2)
         :when ((HasArgType to ty2))
          :ruleset subst)


;; Operators
(rewrite (Subst fuel assum to (Bop op c1 c2))
         (Bop op (Subst (- fuel 1) assum to c1)
                 (Subst (- fuel 1) assum to c2))
         :ruleset subst)
(rewrite (Subst fuel assum to (Uop op c1))
         (Uop op (Subst (- fuel 1) assum to c1))
         :ruleset subst)
(rewrite (Subst fuel assum to (Get c1 index))
         (Get (Subst (- fuel 1) assum to c1) index)
         :ruleset subst)
(rewrite (Subst fuel assum to (Alloc id c1 state ty))
         (Alloc id (Subst (- fuel 1) assum to c1) (Subst fuel assum to state) ty)
         :ruleset subst)
(rewrite (Subst fuel assum to (Call name c1))
         (Call name (Subst (- fuel 1) assum to c1))
         :ruleset subst)


;; Tuple operators
(rewrite (Subst fuel assum to (Single c1))
         (Single (Subst (- fuel 1) assum to c1))
         :ruleset subst)
(rewrite (Subst fuel assum to (Concat c1 c2))
         (Concat (Subst (- fuel 1) assum to c1) (Subst (- fuel 1) assum to c2))
         :ruleset subst)


;; Control flow
(rewrite (Subst fuel assum to (Switch pred branches))
         (Switch (Subst (- fuel 1) assum to pred)
                 (SubstList (- fuel 1) assum to branches))
         :ruleset subst)
(rewrite (Subst fuel assum to (If pred c1 c2))
         (If (Subst (- fuel 1) assum to pred)
             (Subst (- fuel 1) assum to c1)
             (Subst (- fuel 1) assum to c2))
         :ruleset subst)
(rewrite (Subst fuel assum to (DoWhile in out))
         (DoWhile (Subst (- fuel 1) assum to in)
                  out)
         :ruleset subst)

;; List operators
(rewrite (SubstList fuel assum to (Cons c1 c2))
         (Cons (Subst fuel assum to c1)
               (SubstList fuel assum to c2))
         :ruleset subst)
(rewrite (SubstList fuel assum to (Nil))
         (Nil)
         :ruleset subst)

;; substitute into function (convenience)
(rewrite (Subst fuel assum to (Function name inty outty body))
         (Function name inty outty (Subst fuel assum to body))
         :ruleset subst)
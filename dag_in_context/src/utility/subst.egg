;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)

;; (Subst assumption to in) substitutes `to` for `(Arg ty)` in `in`.
;; It also replaces any contexts found by updating them to `assumption`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
(function Subst (Assumption Expr Expr) Expr :unextractable)
;; (SubstLeaf to in) substitutes `to` for `in` in a leaf node `in`
;; SubstLeaf assumes context has already been added
(function SubstLeaf (Expr Expr) Expr :unextractable)
(function SubstList (Assumption Expr ListExpr) ListExpr :unextractable)


;; leaf node with context
;; replace this context- subst assumes the context is more specific
(rule ((= lhs (Subst assum to (InContext oldctx leaf)))
       (IsLeaf leaf))
      ((union lhs (InContext assum (SubstLeaf to leaf))))
      :ruleset subst)

;; substitute for a leaf node- interested case is (Arg ty)
(rewrite (SubstLeaf to (Arg ty))
         to
         :ruleset subst)
(rewrite (SubstLeaf to (Const constant ty))
         (Const constant ty2)
         :when ((HasArgType to ty2))
         :ruleset subst)
(rewrite (SubstLeaf to (Empty ty))
         (Empty ty2)
         :when ((HasArgType to ty2))
          :ruleset subst)


;; Operators
(rewrite (Subst assum to (Bop op c1 c2))
         (Bop op (Subst assum to c1)
                 (Subst assum to c2))
         :ruleset subst)
(rewrite (Subst assum to (Uop op c1))
         (Uop op (Subst assum to c1))
         :ruleset subst)
(rewrite (Subst assum to (Get c1 index))
         (Get (Subst assum to c1) index)
         :ruleset subst)
(rewrite (Subst assum to (Alloc id c1 state ty))
         (Alloc id (Subst assum to c1) (Subst assum to state) ty)
         :ruleset subst)
(rewrite (Subst assum to (Call name c1))
         (Call name (Subst assum to c1))
         :ruleset subst)


;; Tuple operators
(rewrite (Subst assum to (Single c1))
         (Single (Subst assum to c1))
         :ruleset subst)
(rewrite (Subst assum to (Concat c1 c2))
         (Concat (Subst assum to c1) (Subst assum to c2))
         :ruleset subst)


;; Control flow
(rewrite (Subst assum to (Switch pred inputs branches))
         (Switch (Subst assum to pred)
                 (Subst assum to inputs)
                 branches)
         :ruleset subst)
(rewrite (Subst assum to (If pred inputs c1 c2))
         (If (Subst assum to pred)
             (Subst assum to inputs)
             c1
             c2)
         :ruleset subst)
(rewrite (Subst assum to (DoWhile in out))
         (DoWhile (Subst assum to in)
                  out)
         :ruleset subst)

;; List operators
(rewrite (SubstList assum to (Cons c1 c2))
         (Cons (Subst assum to c1)
               (SubstList assum to c2))
         :ruleset subst)
(rewrite (SubstList assum to (Nil))
         (Nil)
         :ruleset subst)

;; substitute into function (convenience)
(rewrite (Subst assum to (Function name inty outty body))
         (Function name inty outty (Subst assum to body))
         :ruleset subst)
; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with a new context.
; Users of AddContext can specify how deeply to do this copy.
; However, these rules do not recursivly add new InIf contexts as they go,
; since these can blow up exponentially. 


(ruleset context)
(ruleset context-helpers)

;; ################################ datatypes
;; A context path is a list of (DoAddContext ... (DoWhile ...)) nodes that we have already visited.
;; In substitution, the path is used to store every loop eclass we have visited, 
;; and the corresponding expression at that point.
;; When we visit an eclass for the second time, we have found a cycle in the egraph.
;; Then the corresponding contexts are made equivalent.
(datatype ContextPath
  (PathNil)
  (PathCons Expr ContextPath))


;; For every path P in the database,
;; we add a (Path-contains P S)
;; for every subpath S with the same endpoint.
;; We also include the empty path.
;; Ex: for path P = (PathCons a (PathCons b (PathCons c (PathNil))))
;; we have (Path-contains P P),
;; (Path-contains P (PathCons b (PathCons c (PathNil)))),
;; (Path-contains P (PathCons c (PathNil))),
;; and (Path-contains P (PathNil)).
(relation Path-contains (ContextPath ContextPath))

(rule ((= lhs (PathCons hd1 tl)))
      ((Path-contains lhs lhs))
      :ruleset context-helpers)
(rule ((Path-contains top (PathCons hd1 tl)))
      ((Path-contains top tl))
      :ruleset context-helpers)


(datatype ContextDepth
  ;; Make new InLoop contexts for the full reachable subgraph
  (Full)
  ;; Don't make new contexts for sub-loops
  (StopAtLoop))
(Full)
(StopAtLoop)

;; AddFuncContext is a helper for tests, it adds full context to everything in a function.
(function AddFuncContext (Expr) Expr :unextractable)
(function AddContext (Assumption ContextDepth Expr) Expr :unextractable)
(function DoAddContext (ContextPath Assumption ContextDepth Expr) Expr :unextractable)
(function DoAddContextList (ContextPath Assumption ContextDepth ListExpr) ListExpr :unextractable)

;; ###################### sugar


;; desugar add func context
(rule ((= lhs (AddFuncContext (Function name inty outty body))))
      ((union lhs
         (Function name inty outty
           (AddContext (NoContext) (Full) body))))
       :ruleset context-helpers)


;; AddContext is sugar for DoAddContext
(rewrite (AddContext ctx depth expr)
         (DoAddContext (PathNil) ctx depth expr)
         :ruleset context-helpers)

;; ################################### error detection

(rule ((DoAddContext path (InIf b pred) depth expr))
      ((panic "InIf context not allowed in AddContext. Only InLoop is allowed."))
      :ruleset context-helpers)


;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (DoAddContext seen ctx (Full) inner))
   (= inner (DoAddContext seen2 ctx (Full) expr)))
  ((union lhs inner))
  :ruleset context-helpers)


;; key rule that detects cycles
;; It finds that we have already seen the eclass we are adding context to.
;; The corresponding eclasses are unioned, and the cyclic
;; substitution is subsumed to ensure saturation.
(rule ((= lhs (DoAddContext seen ctx scope in))
       (Path-contains seen
         (PathCons original rest))
       (= original (DoAddContext oldseen oldctx oldscope in))
       )
      (;; contexts are equal
       (union ctx oldctx)
       ;; therefore adding context the first time is also equal to this time
       (union lhs original)
       ;; subsume the one with a cycle in the path
       (subsume (DoAddContext seen ctx scope in)))
      :ruleset context-helpers)

(rewrite (InContext (NoContext) expr)
         expr
         :ruleset context-helpers)


;; ############################################### Existing contexts


;; Replace existing InLoop contexts.
;; This relies on the fact that new contexts for DoAddContext 
;; must be more specific than old ones.
(rewrite (DoAddContext seen ctx scope
            (InContext (InLoop oldpred oldbody)  expr))
         (DoAddContext seen ctx scope expr)
         :ruleset context)

(rewrite (DoAddContext seen ctx scope
            (InContext (InIf b pred) expr))
         (InContext
           (InIf b (DoAddContext seen ctx scope pred))
           (DoAddContext seen ctx scope expr))
          :ruleset context)


;; ############################## Base cases- leaf nodes

(rewrite (DoAddContext seen ctx scope (Arg ty))
         (InContext ctx (Arg ty))
         :ruleset context)

(rewrite (DoAddContext seen ctx scope (Const constant ty))
         (InContext ctx (Const constant ty))
         :ruleset context)

(rewrite (DoAddContext seen ctx scope (Empty ty))
         (InContext ctx (Empty ty))
         :ruleset context)




;; ######################################### Operators


(rewrite (DoAddContext seen ctx scope (Bop op c1 c2))
         (Bop op
           (DoAddContext seen ctx scope c1)
           (DoAddContext seen ctx scope c2))
               :ruleset context)
(rewrite (DoAddContext seen ctx scope (Uop op c1))
         (Uop op (DoAddContext seen ctx scope c1))
         :ruleset context)
(rewrite (DoAddContext seen ctx scope (Get c1 index))
         (Get (DoAddContext seen ctx scope c1) index)
               :ruleset context)
(rewrite (DoAddContext seen ctx scope (Alloc id c1 state ty))
         (Alloc id (DoAddContext seen ctx scope c1) (DoAddContext seen ctx scope state) ty)
         :ruleset context)
(rewrite (DoAddContext seen ctx scope (Call name c1))
         (Call name (DoAddContext seen ctx scope c1))
         :ruleset context)

(rewrite (DoAddContext seen ctx scope (Single c1))
         (Single (DoAddContext seen ctx scope c1))
         :ruleset context)
(rewrite (DoAddContext seen ctx scope (Concat c1 c2))
         (Concat
           (DoAddContext seen ctx scope c1)
           (DoAddContext seen ctx scope c2))
         :ruleset context)

;; ################################### List operators

(rewrite (DoAddContextList seen ctx scope (Nil))
         (Nil)
         :ruleset context)

(rewrite (DoAddContextList seen ctx scope (Cons c1 rest))
         (Cons (DoAddContext seen ctx scope c1)
               (DoAddContextList seen ctx scope rest))
               :ruleset context)


;; ########################################## Control flow
(rewrite (DoAddContext seen ctx scope (Switch pred branches))
         (Switch (DoAddContext seen ctx scope pred)
                 (DoAddContextList seen ctx scope branches))
         :ruleset context)


;; don't generate new context for if nodes
(rule ((= lhs (DoAddContext seen ctx scope (If pred c1 c2))))
      ((If
         (DoAddContext seen ctx scope pred)
         (DoAddContext seen ctx scope c1)
         (DoAddContext seen ctx scope c2)))
       :ruleset context)


;; full context adds context to sub-loops
(rule ((= lhs (DoAddContext seen ctx scope (DoWhile inputs outputs)))
       (= scope (Full)))
      ((let new-inputs
         (DoAddContext seen ctx scope inputs))
       (let newpath
         (PathCons lhs seen))
       (union lhs
         (DoWhile new-inputs
           (DoAddContext newpath (InLoop new-inputs outputs) scope outputs))))
       :ruleset context)


;; For stop at loop, still add context to inputs
(rule ((= lhs (DoAddContext seen ctx scope (DoWhile inputs outputs)))
       (= scope (StopAtLoop)))
      ((DoWhile
          (DoAddContext seen ctx scope inputs)
          outputs))
       :ruleset context)


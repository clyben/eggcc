; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with context.
; Users of AddContext can specify how deeply to do this copy.


(ruleset context)
(ruleset context-helpers)


;; ################################ datatypes
;; A context path is a list of (eclass, eclass) pairs.
;; In substitution, the path is used to store every context-related eclass we have visited, 
;; and the corresponding expression at that point.
;; When we visit an eclass for the second time, we have found a cycle in the egraph.
;; Then the corresponding eclasses are made equivalent.
(datatype ContextPath
  (PathNil)
  (PathCons Expr Expr ContextPath))


;; For every path P in the database,
;; we add a (Path-contains P S)
;; for every subpath S with the same endpoint.
;; We also include the empty path.
;; Ex: for path P = (PathCons a (PathCons b (PathCons c (PathNil))))
;; we have (Path-contains P P),
;; (Path-contains P (PathCons b (PathCons c (PathNil)))),
;; (Path-contains P (PathCons c (PathNil))),
;; and (Path-contains P (PathNil)).
(relation Path-contains (ContextPath ContextPath))

(rule ((= lhs (PathCons hd1 hd2 tl)))
      ((Path-contains lhs lhs))
      :ruleset context-helpers)
(rule ((Path-contains top (PathCons hd1 hd2 tl)))
      ((Path-contains top tl))
      :ruleset context-helpers)


(datatype ContextDepth
  ;; Keep making new contexts for the entire reachable egraph
  (Full)
  ;; Don't make new contexts for sub-loops
  (StopAtLoop)
  ;; Don't make any new contextx for loops or lets (still make new ones for if statements)
  (StopAtLoopOrLet))
;; we need to add these to the database so we can match on them
(Full)
(StopAtLoop)
(StopAtLoopOrLet)

;; AddFuncContext is a helper for tests, it adds full context to everything in a function.
(function AddFuncContext (Expr) Expr :unextractable)
(function AddContext (Assumption ContextDepth Expr) Expr :unextractable)
(function DoAddContext (ContextPath Assumption ContextDepth Expr) Expr :unextractable)
(function DoAddContextList (ContextPath Assumption ContextDepth ListExpr) ListExpr :unextractable)

;; ###################### sugar


;; desugar add func context
(rule ((= lhs (AddFuncContext (Function name inty outty body))))
      ((union (Function name inty outty body)
         (Function name inty outty
           (AddContext (InFunc name) (Full) body))))
       :ruleset context-helpers)


;; AddContext is sugar for DoAddContext
(rewrite (AddContext ctx depth expr)
         (DoAddContext (PathNil) ctx depth expr)
         :ruleset context-helpers)


;; ################################ saturation

;; Outer context nodes are more specific by our semantics
(rewrite (InContext ctx (InContext ctx expr))
         (InContext ctx expr)
         :ruleset context-helpers)


;; Adding context a second time does nothing, so union
(rule
  ((= lhs (DoAddContext seen ctx (Full) inner))
   (= inner (DoAddContext seen ctx (Full) expr)))
  ((union lhs inner))
  :ruleset context-helpers)


;; Adding context may not saturate for loops.
;; This is because a loop (DoWhile inputs outputs)
;; can become equal to
;; (DoWhile inputs ctx1)
;; where ctx1 = (InContext (InLoop inputs outputs) outputs)
;; Which we can add context to again:
;; (DoWhile inputs (InContext (InLoop inputs ctx1) ctx1))
;; These two contexts are equal, since the set of reachable
;; values is the same.
(rule ((= body_with_context
          (DoAddContext seen  (InLoop inputs outputs) (Full) outputs)) ;; a loop body with context
       (DoAddContext    seen2 (InLoop inputs body_with_context) ;; same inputs
                    (Full) body_with_context) ;; a loop body whose context already has context
       )
      ((union (InLoop inputs outputs) (InLoop inputs body_with_context)))
      :ruleset context-helpers)

;; key rule that detects cycles
;; It finds that we have already seen the eclass we are adding context to.
;; The corresponding eclasses are unioned, and the cyclic
;; substitution is subsumed to ensure saturation.
(rule ((= lhs (DoAddContext seen ctx scope in))
       (Path-contains seen
         (PathCons in original rest)))
      ((union lhs original)
       (subsume (DoAddContext seen ctx scope in)))
      :ruleset context-helpers)




;; ############################## Base cases- leaf nodes

(rewrite (DoAddContext seen ctx scope (Arg ty))
         (InContext ctx (Arg ty))
         :ruleset context-helpers)

(rewrite (DoAddContext seen ctx scope (Const constant ty))
         (InContext ctx (Const constant ty))
         :ruleset context-helpers)

(rewrite (DoAddContext seen ctx scope (Empty ty))
         (InContext ctx (Empty ty))
         :ruleset context-helpers)


;; ######################################### Operators


(rewrite (DoAddContext seen ctx scope (Bop op c1 c2))
         (Bop op
           (DoAddContext seen ctx scope c1)
           (DoAddContext seen ctx scope c2))
               :ruleset context-helpers)
(rewrite (DoAddContext seen ctx scope (Uop op c1))
         (Uop op (DoAddContext seen ctx scope c1))
         :ruleset context-helpers)
(rewrite (DoAddContext seen ctx scope (Get c1 index))
         (Get (DoAddContext seen ctx scope c1) index)
               :ruleset context-helpers)
(rewrite (DoAddContext seen ctx scope (Alloc id c1 state ty))
         (Alloc id (DoAddContext seen ctx scope c1) (DoAddContext seen ctx scope state) ty)
         :ruleset context-helpers)
(rewrite (DoAddContext seen ctx scope (Call name c1))
         (Call name (DoAddContext seen ctx scope c1))
         :ruleset context-helpers)

(rewrite (DoAddContext seen ctx scope (Single c1))
         (Single (DoAddContext seen ctx scope c1))
         :ruleset context-helpers)
(rewrite (DoAddContext seen ctx scope (Concat order c1 c2))
         (Concat order
           (DoAddContext seen ctx scope c1)
           (DoAddContext seen ctx scope c2))
         :ruleset context-helpers)

;; Replace existing contexts.
;; This relies on the fact that new contexts must be more specific than old ones.
;; This is a part of the semantics of InContext.
(rewrite (DoAddContext seen ctx scope (InContext ctx2 expr))
         (DoAddContext seen ctx scope expr)
         :ruleset context-helpers)

;; ################################### List operators

(rewrite (DoAddContextList seen ctx scope (Nil))
         (Nil)
         :ruleset context-helpers)

(rewrite (DoAddContextList seen ctx scope (Cons c1 rest))
         (Cons (DoAddContext seen ctx scope c1)
               (DoAddContextList seen ctx scope rest))
               :ruleset context-helpers)


;; ########################################## Control flow
(rewrite (DoAddContext seen ctx scope (Switch pred branches))
         (Switch (DoAddContext seen ctx scope pred)
                 (DoAddContextList seen ctx scope branches))
         :ruleset context-helpers)


(rule ((= lhs (DoAddContext seen ctx scope (If pred c1 c2))))
      ((let newpred
         (DoAddContext seen ctx scope pred))
       (let newpath
         (PathCons (If pred c1 c2) lhs seen))
       (union lhs
         (If newpred
           (DoAddContext newpath (InIf true newpred) scope c1)
           (DoAddContext newpath (InIf false newpred) scope c2))))
       :ruleset context)


(rule ((= lhs (DoAddContext seen ctx scope (DoWhile inputs outputs)))
       (= scope (Full)))
      ((let new-inputs
         (DoAddContext seen ctx scope inputs))
       (let newpath
         (PathCons (DoWhile inputs outputs) lhs seen))
       (union lhs
         (DoWhile new-inputs
           (DoAddContext newpath (InLoop new-inputs outputs) scope outputs))))
       :ruleset context)


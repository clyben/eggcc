; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with context.
; Users of AddContext can specify how deeply to do this copy.


(ruleset context)
(ruleset context-helpers)


;; ################################ datatypes
;; A context path is a list of (eclass, eclass) pairs.
;; In substitution, the path is used to store every context-related eclass we have visited, 
;; and the corresponding expression at that point.
;; When we visit an eclass for the second time, we have found a cycle in the egraph.
;; Then the corresponding eclasses are made equivalent.
(datatype ContextPath
  (PathNil)
  (PathCons Expr Expr ContextPath))

(relation Path-contains (ContextPath ContextPath))

(rule ((= lhs (PathCons hd1 hd2 tl)))
      ((Path-contains lhs lhs))
      :ruleset context-helpers)
(rule ((Path-contains top (PathCons hd1 hd2 tl)))
      ((Path-contains top tl)) :ruleset context-helpers)


(datatype ContextDepth
  ;; Keep making new contexts for the entire reachable egraph
  (Full)
  ;; Don't make new contexts for sub-loops
  (StopAtLoop)
  ;; Don't make any new contextx for loops or lets (still make new ones for if statements)
  (StopAtLoopOrLet))

(function AddFuncContext (Expr) Expr :unextractable)
(function AddContext (Assumption ContextDepth Expr) Expr :unextractable)
(function DoAddContext (ContextPath Assumption ContextDepth Expr) Expr :unextractable)

;; ###################### sugar


;; desugar add func context
(rule ((= lhs (AddFuncContext (Function name inty outty body))))
      ((union lhs
         (Function name inty outty
           (AddContext (InFunc name) (Full) body))))
       :ruleset context-helpers)



;; AddContext is sugar for DoAddContext
(rewrite (AddContext ctx depth expr)
         (DoAddContext (PathNil) ctx depth expr)
         :ruleset context-helpers)


;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (DoAddContext seen ctx (Full) inner))
   (= inner (DoAddContext seen ctx (Full) expr)))
  ((union lhs inner))
  :ruleset context-helpers)


;; Adding context may not saturate for loops.
;; This is because a loop (DoWhile inputs outputs)
;; can become equal to
;; (DoWhile inputs ctx1)
;; where ctx1 = (InContext (InLoop inputs outputs) outputs)
;; Which we can add context to again:
;; (DoWhile inputs (InContext (InLoop inputs ctx1) ctx1))
;; These two contexts are equal, since the set of reachable
;; values is the same.
(rule ((= body_with_context (InContext (InLoop inputs outputs) body)) ;; a loop body with context
       (InContext (InLoop inputs body_with_context) body_with_context) ;; a loop body whose context already has context
       )
      ((union (InLoop inputs outputs) (InLoop inputs old_body)))
      :ruleset context-helpers)

;; key rule that detects cycles
;; It finds that we have already seen the eclass we are adding context to.
;; The corresponding eclasses are unioned, and the cyclic
;; substitution is subsumed to ensure saturation.
(rule ((= lhs (DoAddContext seen ctx scope in))
       (Path-contains seen
         (PathCons in original ctx)))
      ((union lhs original)
       (subsume (DoAddContext seen ctx scope in) in))
      :ruleset context-helpers)




;; ############################## Base cases- leaf nodes

(rewrite (AddContext seen ctx scope (Arg ty))
         (InContext ctx (Arg ty))
         :ruleset context)







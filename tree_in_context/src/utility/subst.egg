
;; (Subst assumption scope to in) substitutes 
;; (InContext assumption to) for `(Arg scope ty)` in `in`
;; It also replaces `(Asuume anything (Arg scope ty))` with `(InContext assumption to)`
(function Subst (Assumption Scope Expr Expr) Expr :unextractable)
(function SubstList (Assumption Scope Expr ListExpr) ListExpr :unextractable)


;; Base case- leaf nodes
(rewrite (Subst assum scope to (Arg scope ty))
         (InContext assum to)
         :ruleset always-run)
;; use of != here is okay since scopes are never unioned
(rule ((= lhs (Subst assum scope to (Arg scope2 ty)))
       (!= scope scope2))
      ((union lhs
         (InContext assum (Arg scope2 ty))))
         :ruleset always-run)
(rewrite (Subst assum scope to (InContext assum2 (Arg scope ty)))
         (InContext assum to)
         :ruleset always-run)
(rule ((= lhs (Subst assum scope to (InContext assum2 (Arg scope2 ty))))
       (!= assum assum2))
      ((union lhs
         (InContext assum2 (Arg scope2 ty))))
         :ruleset always-run)

(rewrite (Subst assum scope to (Const constant))
         (InContext assum (Const constant))
         :ruleset always-run)
(rewrite (Subst assum scope to (InContext assum2 (Const constant)))
         (InContext assum (Const constant))
         :ruleset always-run)
(rewrite (Subst assum scope to (Empty))
         (InContext assum (Empty))
          :ruleset always-run)
(rewrite (Subst assum scope to (InContext assum2 (Empty)))
         (InContext assum (Empty))
         :ruleset always-run)


;; Operators
(rewrite (Subst assum scope to (Bop op c1 c2))
         (Bop op (Subst assum scope to c1)
                 (Subst assum scope to c2))
         :ruleset always-run)
(rewrite (Subst assum scope to (Uop op c1))
         (Uop op (Subst assum scope to c1))
         :ruleset always-run)
(rewrite (Subst assum scope to (Get c1 index))
         (Get (Subst assum scope to c1) index)
         :ruleset always-run)
(rewrite (Subst assum scope to (Alloc c1 ty))
         (Alloc (Subst assum scope to c1) ty)
         :ruleset always-run)
(rewrite (Subst assum scope to (Call name c1))
         (Call name (Subst assum scope to c1))
         :ruleset always-run)


;; Tuple operators
(rewrite (Subst assum scope to (Single c1))
         (Single (Subst assum scope to c1))
         :ruleset always-run)
(rewrite (Subst assum scope to (Concat order c1 c2))
         (Concat order (Subst assum scope to c1) (Subst assum scope to c2))
         :ruleset always-run)


;; Control flow
(rewrite (Subst assum scope to (Switch pred branches))
         (Switch (Subst assum scope to pred)
                 (SubstList assum scope to branches))
         :ruleset always-run)
(rewrite (Subst assum scope to (If pred c1 c2))
         (If (Subst assum scope to pred)
             (Subst assum scope to c1)
             (Subst assum scope to c2))
         :ruleset always-run)

(rewrite (Subst assum (LetScope) to (Let in out))
         (Let (Subst assum (LetScope) to in)
              out)
         :ruleset always-run)
(rewrite (Subst assum scope to (Let in out))
         (Let (Subst assum scope to in)
              (Subst assum scope to out))
         :when ((!= scope (LetScope)))
         :ruleset always-run)
(rewrite (Subst assum (LoopScope) to (DoWhile in out))
         (DoWhile (Subst assum (LoopScope) to in)
                  out)
         :ruleset always-run)
(rewrite (Subst assum scope to (DoWhile in out))
         (DoWhile (Subst assum scope to in)
                  (Subst assum scope to out))
          :when ((!= scope (LoopScope)))
          :ruleset always-run)

;; List operators
(rewrite (SubstList assum scope to (Cons c1 c2))
         (Cons (Subst assum scope to c1)
               (SubstList assum scope to c2))
         :ruleset always-run)
(rewrite (SubstList assum scope to (Nil))
         (Nil)
         :ruleset always-run)
(function ListExpr-length (ListExpr) i64)
(function ListExpr-ith (ListExpr i64) Expr :unextractable)
(function ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(function Append (ListExpr Expr) ListExpr :unextractable)

(rule ((Switch pred branch)) ((union (ListExpr-suffix branch 0) branch)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
   (Cons a (Append b e))
   :ruleset always-run)
(rewrite (Append (Nil) e)
   (Cons e (Nil))
   :ruleset always-run)

(function tuple-ith (Expr i64) Expr :unextractable)
(function tuple-length (Expr) i64 :unextractable)

(rule ((HasType expr (TupleT tl))
       (= len (TypeList-length tl)))
      ((set (tuple-length expr) len)) :ruleset always-run)

(rule ((Single expr)) ((union (tuple-ith (Single expr) 0) expr)) :ruleset always-run)
(rule ((Concat ord expr1 expr2)
       (= ith (tuple-ith expr1 i)))
       ((union (tuple-ith (Concat ord expr1 expr2) i) ith)) :ruleset always-run)

(rule ((Concat ord expr1 expr2)
       (= len1 (tuple-length expr1))
       (= ith (tuple-ith expr2 i)))
       ((union (tuple-ith (Concat ord expr1 expr2) (+ len1 i)) ith)) :ruleset always-run)

;; This Expr size actually do the same thing as cost function, can be removed afterwards.
(function Expr-size (Expr) i64 :merge (min old new))
(function ListExpr-size (ListExpr) i64 :merge (min old new))

(rule ((= expr (Function name tyin tyout out)) 
       (= sum (Expr-size out))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Const n ty))) 
      ((set (Expr-size expr) 1))  :ruleset always-run)

(rule ((= expr (Bop op x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Uop op x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Get tup i)) 
       (= sum (Expr-size tup))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Concat order x y)) 
       (= sum (+ (Expr-size y) (Expr-size x)))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Single x)) 
       (= sum (Expr-size x))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)

(rule ((= expr (Switch pred branches)) 
       (= sum (+ (ListExpr-size branches) (Expr-size pred)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (If pred then else)) 
       (= sum (+ (Expr-size else) (+ (Expr-size then) (Expr-size pred))))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (DoWhile in pred-and-output)) 
       (= sum (+ (Expr-size pred-and-output) (Expr-size in)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Let in out)) 
       (= sum (+ (Expr-size out) (Expr-size in)))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (Arg ty))) 
      ((set (Expr-size expr) 1)) :ruleset always-run)

(rule ((= expr (Call func arg)) 
       (= sum (Expr-size arg))) 
      ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((Empty ty)) ((set (Expr-size (Empty ty)) 0))  :ruleset always-run)

(rule ((= expr (Cons hd tl)) 
       (= sum (+ (ListExpr-size tl) (Expr-size hd)))) 
      ((set (ListExpr-size expr) sum)) :ruleset always-run)

(rule ((Nil)) 
      ((set (ListExpr-size (Nil)) 0))  :ruleset always-run)

(rule ((= expr (Alloc e ty)) 
        (= sum (Expr-size e))) 
        ((set (Expr-size expr) (+ sum 1))) :ruleset always-run)

(rule ((= expr (InContext assumption e)) 
       (= sum (Expr-size e))) 
      ((set (Expr-size expr) sum)) :ruleset always-run)


(function tuple-of-get-arg (Type i64) Expr :unextractable)
(function tuple-of-get-arg-helper (Type i64 i64) Expr :unextractable)

(rewrite (tuple-of-get-arg ty n) (tuple-of-get-arg-helper ty n 0) :ruleset always-run)
(rewrite (tuple-of-get-arg-helper ty 1 x) (Single (Get (Arg ty) x)) :ruleset always-run)
(rule ((= f (tuple-of-get-arg-helper ty a b)) (> a 1))
      ((union f 
         (Concat par
               (Get (Arg ty) b) 
               (tuple-of-get-arg-helper ty (- a 1) (+ b 1))))) :ruleset always-run)
;; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :unextractable :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :unextractable :merge (or old new))

;; in default, when there is a find, set is-inv to false
(rule ((BodyContainsExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((BodyContainsListExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr loop list) 
       (= loop (DoWhile inputs pred_out))) 
      ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)

(ruleset boundary-analysis)
;; An Expr is on boundary when it is invariant and its parent is not
;                       loop invariant-expr
(relation boundary-Expr (Expr Expr))

;; boundary for ListExpr's children
(rule ((= true (is-inv-Expr loop expr))
       (= false (is-inv-ListExpr loop list))
       (= expr (ListExpr-ith list i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; if a output branch/pred is invariant, it's also boundary-Expr
(rule ((= true (is-inv-Expr loop expr))
       (= loop (DoWhile in pred_out))
       (= expr (tuple-ith pred_out i))) 
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; a ListExpr could be on invariant boundary if it occur in switch
;; but it's unsound to hoist any of it's children

(function hoisted-loop (Expr) bool :merge (or old new))
(rule ((= loop (DoWhile in pred_out))) 
      ((set (hoisted-loop loop) false)) :ruleset always-run)

(function InExtendedLoop (Expr Expr Expr) Assumption )

(ruleset loop-inv-motion)

;; This rule allow hoist the generated new loop again
;; which cause trouble when interleaves with loop unrolling in milestone
;; The way to fix was to restrict the unrolling number
;; TODO: replace Expr-size after cost model is ready
(rule ((boundary-Expr loop inv)
       (> (Expr-size inv) 1)
       (= loop (DoWhile in pred_out))
       (HasType in (TupleT tylist))
       (HasType inv inv_type)
       (= in_type (TupleT tylist))
       (= false (hoisted-loop loop))
       (= len (tuple-length in)))
      (;; change the args in the hoisted from inloop to inlet
       ;(let hoisted (subst-arg-scope inv (LoopScope) (LetScope)))
       ;; create a list of [(Get (Arg new_let_id) 0) ... hoisted_term]
       (let new_input (Concat par (tuple-of-get-arg in_type len) (Single inv)))
       ;; append (Get (Arg id) len+1) to end of output
       (let new_in_type (TupleT (TCons inv_type tylist)))
       (let new_out_branch (Get (Arg new_in_type) len))
       (let assum (InExtendedLoop in pred_out new_input))
       (let substed_pred_out (Subst assum (Arg new_in_type) pred_out))
       (let new_pred_out (Concat par substed_pred_out new_out_branch))
       (let inv_in_new_loop (Subst assum (Arg new_in_type) inv))
       (let new_loop (DoWhile new_input new_pred_out))
       (union (InContext (InLoop new_input new_pred_out) inv_in_new_loop) 
              (InContext (InLoop new_input new_pred_out) new_out_branch))
       ;; and two loop can be unioned.
       (let let_wrapper (Let new_loop (tuple-of-get-arg new_in_type len)))
       (union loop let_wrapper)
       (union assum (InLoop new_input new_pred_out))
       ;; don't hoist same loop again
       (set (hoisted-loop loop) true))
       :ruleset loop-inv-motion)
   
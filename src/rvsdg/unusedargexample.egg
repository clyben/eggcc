(datatype Literal)
(datatype Expr)
(datatype Operand)
(datatype Body)

(sort VecOperand (Vec Operand))
(datatype VecOperandWrapper
  (VO VecOperand))
(sort VecVecOperand (Vec VecOperandWrapper))

;; Type
(datatype Type
    (IntT)
    (BoolT)
    (FloatT)
    (CharT)
    (PointerT Type))

;; Literal
(function Num (i64) Literal)
(function Float (f64) Literal)
(function Char (String) Literal)

;; Expr
(datatype ConstOps (const))
(function Const (ConstOps Type Literal) Expr)
(function Call (String VecOperand) Expr)
(function add (Operand Operand) Expr)
(function sub (Operand Operand) Expr)
(function mul (Operand Operand) Expr)
(function div (Operand Operand) Expr)
(function eq (Operand Operand) Expr)
(function lt (Operand Operand) Expr)
(function gt (Operand Operand) Expr)
(function le (Operand Operand) Expr)
(function ge (Operand Operand) Expr)
(function not (Operand Operand) Expr)
(function and (Operand Operand) Expr)
(function or (Operand Operand) Expr)

;; Operand
(function Arg (i64) Operand)
(function Node (Body) Operand)
(function Project (i64 Body) Operand)

;; Body
(function PureOp (Expr) Body)
(function Gamma (Operand VecOperand VecVecOperand) Body) ;; branching
(function Theta (Operand VecOperand VecOperand) Body) ;; loop


;; procedure f(n):
;;   i = 0
;;   ans = 0
;;   do:
;;     ans += i*5;
;;     i += 1
;;   while(i < n);
;;   return ansm





;; ;; inputs: [n]
(Project 0
    (Theta
       ;     i       n
        (lt (Arg 1) (Arg 2)) ;; pred
        (vec-of ;; inputs
            (Node (PureOp (Const 0))) ;; accumulator
            (Node (PureOp (Const 0))) ;; loop var
            (Arg 0) ;; n
            )
        (vec-of ;; outputs
            (Node (PureOp (add (Arg 0) ;; ans
                (Node (PureOp (mul 
                    (Arg 1) ;; i
                    (Node (PureOp (Const 5))))))))) ;; ans = i*5
            (Node (PureOp (add (Arg 1) (Node (PureOp (Const 1)))))) ;; i += 1
            (Arg 2) ;; n
        ))
)


;; try one- can't rewrite the theta, need to write project
;;(rule ((= lhs (Theta pred inputs outputs))
;;       (Arg i)
;;       (= (vec-get output i) (Arg i)))
;;      ((union lhs...)))


;; (Arg 0) (Arg 1) (Arg 2)
;; (Arg 0)         (Arg 1)


(rule ((Project ith theta)
       (= theta (Theta pred inputs outputs))
       (= (vec-get output i) (Arg i))
       (= theinput (vec-get inputs i))
       (< ith i)
       )
      ((union (Project ith theta)
              (Project ith
                (Theta (Subst theinput (Arg i) pred)
                       (vec-remove inputs i)
                       (Shift (vec-remove outputs i) 0 i))))))




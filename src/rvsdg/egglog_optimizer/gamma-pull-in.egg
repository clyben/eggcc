(sort IntSet (Set i64))

;; Note that because the merge function is set-union 
;; instead of set-intersect (which is sound but requires a 
;; different set of rules for Node and Project),
;; we cannot handle cases like
;; if (...) x else x - x even accompanied with rules like x - x => 0

;; It is critical to run these rules after subst rule but before 
;; gamma-pull-in optimization rule
(function arg-used-VecOperand (VecOperand) IntSet :merge (set-union old new))
(rule ((= operand (VecOperand-get operands i))
       (= operand (Arg arg)))
      ((set (arg-used-VecOperand operands) (set-of arg))))

(rule ((= operand (VecOperand-get operands i))
       (= operand (Node body))
       (Body-contains-Operand body j (Arg arg)))
      ((set (arg-used-VecOperand operands) (set-of arg))))

(rule ((= operand (VecOperand-get operands i))
       (= operand (Project k body))
       (Body-contains-Operand body j (Arg arg)))
      ((set (arg-used-VecOperand operands) (set-of arg))))


;; Gamma optimization
;; Note this rule can also suffer from exponential explosion 
;; (1) multiple arguments can be used in one branch and not the other,
;; in which case this rule can generate exponential combination of pulled-in programs
;; (2) this rule introduce new arguments, all of which are used in one branch 
;; but not the other, causing the rule to be applied again.
(rule ((= gamma (Gamma pred inputs outputs))
       (= input (VecOperand-get inputs i))
       (= els (vec-get outputs 0))
       (= thn (vec-get outputs 1))

       (= els-args (arg-used-VecOperand els))
       (= thn-args (arg-used-VecOperand thn))
       (set-contains els-args i)
       (set-not-contains thn-args i)
       )
      (
        ;; Step 1: build the new inputs: remove (Arg i) and 
        ;; introduce arguments used by els-args
        (let els-args-vec (set->vec els-args))
        (let new-inputs (vec-append (vec-remove inputs i) els-args-vec))

        ;; Step 2: build the pulled-in input by substituting contexts
        (let subst-map (map-of (vec-get args-vec i) (Arg i) ...))
        (let new-input (SubstOperandMap subst-map input))

        ;; Step 3: build the new outputs: substitute (Arg i) with the 
        ;; input built in the last step, and shift all other inputs by one
        (let new-outputs (ShiftVecVecOperand (SubstVecVecOperand i new-input outputs) i 1))

        ;; Step 3: union
        (let new-gamma (Gamma pred new-inputs new-outputs))
        (union new-gamma gamma)
      ))

;; TODO list
;; 1. implement arg-used-VecOperand; ensure the rule is monotonic (maybe with scheduling)
;; 2. implement set->vec
;; 3. build subst-map
;; 4. implement SubstOperandMap

;; Gamma optimization
;; Note this rule can also suffer from exponential explosion 
;; (1) multiple arguments can be used in one branch and not the other,
;; in which case this rule can generate exponential combination of pulled-in programs
;; (2) this rule introduce new arguments, all of which are used in one branch 
;; but not the other, causing the rule to be applied again.
(rule ((= gamma (Gamma pred (VO inps) outputs))
       (= inp (VecOperand-get (VO inps) i))
       (= els (VecVecOperand-get outputs 0))
       (= thn (VecVecOperand-get outputs 1))

       (= els-args (arg-used-VecOperand els))
       (= thn-args (arg-used-VecOperand thn))
       (set-contains els-args i)
       (set-not-contains thn-args i)
       )
      (
        ;; Step 1: build the new inps: remove (Arg i) and 
        ;; introduce arguments used by els-args
        (let els-args-vec (VI (set->vec els-args)))
        (let els-args-vec-operand (MapArgOverVec els-args-vec))
        (let new-inps (VecAppend (VO (vec-remove inps i)) els-args-vec-operand))

        ;; Step 2: build the pulled-in inp by substituting contexts
        (let subst-map (BuildSubstMapFrom els-args-vec))
        (let new-inp (SubstOperandMap inp subst-map))

        ;; Step 3: build the new outputs: substitute (Arg i) with the 
        ;; inp built in the last step, and shift all other inps by one
        (let new-outputs (ShiftVecVecOperand (SubstVecVecOperand outputs i new-inp) i 1))

        ;; Step 3: union
        (let new-gamma (Gamma pred new-inps new-outputs))
        (union new-gamma gamma)
      ))

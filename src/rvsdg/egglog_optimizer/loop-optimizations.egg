
;; unroll loops
(rule ((= theta (Theta pred (VO inputs) (VO outputs))))
                          ;;            arguments body
      ((let after-one-iter
         (SubstVecOperandAll (VO outputs) (VO inputs)))
       ;; (vec-of (Arg 0) (Arg 1) ...)
       (let pass-through (PassThroughArguments (vec-length outputs)))
       (union theta
          (Gamma
            (SubstOperandAll pred (VO inputs))
            after-one-iter
            (VVO
              (vec-of
                ;; in the false case, we are done
                pass-through
                ;; otherwise do the rest of the loop
                (BodyToVecOperand
                (vec-length outputs)
                (Theta pred pass-through
                            (VO outputs)))))))))

;; split loops with range checks
;; TODO: this might be unsound! it only copies the first output from the inner gamma,
;;       when it should probably copy all of them
(rule ((= theta (Theta theta_pred theta_inputs theta_outputs))
       (= theta_pred (Node (PureOp (blt BoolT (Arg 1) b))))

       (= (VecOperand-length theta_inputs) 2)
       (= (VecOperand-get theta_inputs 1) (Node (PureOp (Const IntT const (Num 0)))))

       (= (VecOperand-length theta_outputs) 2)
       (= (VecOperand-get theta_outputs 0) (Project 0 gamma))
       (= (VecOperand-get theta_outputs 1) (Node (PureOp (badd IntT
                  (Arg 1)
                  (Node (PureOp (Const IntT const (Num 1))))))))

       (= gamma (Gamma gamma_pred gamma_inputs gamma_outputs))
       (= gamma_pred (Node (PureOp (blt BoolT (Arg 1) a))))

       (= (VecOperand-get gamma_inputs 0) (Arg 0))

       (= (VecVecOperand-length gamma_outputs) 2)
       (= (VecVecOperand-get gamma_outputs 1) then_vec)
       (= (VecVecOperand-get gamma_outputs 0) else_vec)

       (= (ival a) (IntI a1 a2))
       (= (ival b) (IntI b1 b2))
       (<= a2 b1))

      ((let upper (Theta gamma_pred
                         theta_inputs
                         (VO (vec-of (VecOperand-get then_vec 0) (VecOperand-get theta_outputs 1)))))

       (let lower (Theta theta_pred
                         (PassThroughArguments 2)
                         (VO (vec-of (VecOperand-get else_vec 0) (VecOperand-get theta_outputs 1)))))


       (let final (Gamma (Node (PureOp (blt (BoolT) a b)))
                         (VO (vec-of (Project 0 upper) a))
                         (VVO (vec-of (VO (vec-of (Project 0 lower) (Project 1 lower)))
                                      (PassThroughArguments 2)))))

       (union theta final)))
       ; (union theta (OperandGroup (VO (vec-of (Node (PureOp (Const IntT const (Num 1))))
       ;                                        (Node (PureOp (Const IntT const (Num 1))))))))))

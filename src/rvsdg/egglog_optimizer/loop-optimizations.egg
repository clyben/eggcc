
;; unroll loops
(rule ((= theta (Theta pred (VO inputs) (VO outputs))))
                          ;;            arguments body
      ((let after-one-iter
         (SubstVecOperandAll (VO outputs) (VO inputs)))
       ;; (vec-of (Arg 0) (Arg 1) ...)
       (let pass-through (PassThroughArguments (vec-length outputs)))
       (union theta
          (Gamma
            (SubstOperandAll pred (VO inputs))
            after-one-iter
            (VVO
              (vec-of
                ;; in the false case, we are done
                pass-through
                ;; otherwise do the rest of the loop
                (BodyToVecOperand
                (vec-length outputs)
                (Theta pred pass-through
                            (VO outputs)))))))))

;; split loops with range checks:

;; i = 0
;; do:
;;  if i < 5:
;;    print 1
;;  else:
;;    print 2
;; while (i < 10)
;; print i
;; --------------
;; i = 0
;; do:
;;  print 1
;; while (i < 5)
;; if (i < 10):
;;  do:
;;    print 2
;;  while (i < 10)
;; print i

;; TODO: this might be unsound! it only copies the first output from the inner gamma,
;;       when it should probably copy all of them. We can't assert soundness right now
;;       because the pass-though optimization doesn't remove ports. Maybe doing an
;;       "unused" analysis of the other ports would work?
(rule ((= theta (Theta theta_pred theta_inputs theta_outputs))
       (= i_plus_one (Node (PureOp (badd IntT
                                         (Arg 1)
                                         (Node (PureOp (Const IntT const (Num 1))))))))
       (= theta_pred (Node (PureOp (blt BoolT i_plus_one b))))

       (= (VecOperand-length theta_inputs) 2)
       (= (VecOperand-get theta_inputs 1) (Node (PureOp (Const IntT const (Num 0)))))

       (= (VecOperand-length theta_outputs) 2)
       (= (VecOperand-get theta_outputs 0) (Project 0 gamma))
       (= (VecOperand-get theta_outputs 1) i_plus_one)

       (= gamma (Gamma gamma_pred gamma_inputs gamma_outputs))
       (= gamma_pred (Node (PureOp (blt BoolT (Arg 1) a))))

       (= (VecOperand-get gamma_inputs 0) (Arg 0))

       (= (VecVecOperand-length gamma_outputs) 2)
       (= (VecVecOperand-get gamma_outputs 1) then_vec)
       (= (VecVecOperand-get gamma_outputs 0) else_vec)

       (= (ival a) (IntI a1 a2))
       (= (ival b) (IntI b1 b2))
       (<= a2 b1))

      ((let upper (Theta (Node (PureOp (blt BoolT i_plus_one a)))
                         theta_inputs
                         (VO (vec-of (VecOperand-get then_vec 0)
                                     (VecOperand-get theta_outputs 1)))))

       (let lower (Theta (Node (PureOp (blt BoolT i_plus_one b)))
                         (PassThroughArguments 2)
                         (VO (vec-of (VecOperand-get else_vec 0)
                                     (VecOperand-get theta_outputs 1)))))


       (let final (Gamma (Node (PureOp (blt (BoolT) a b)))
                         (VO (vec-of (Project 0 upper) a))
                         (VVO (vec-of (PassThroughArguments 2)
                                      (VO (vec-of (Project 0 lower) b))))))

       (union theta final)))
       ; (union theta final)
       ; (delete (Theta theta_pred theta_inputs theta_outputs))))

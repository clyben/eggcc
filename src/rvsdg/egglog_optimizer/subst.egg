;; Substitution
(ruleset subst)

;;                   e  [ x -> v ]
(function SubstExpr (Expr i64 Operand) Expr)
(function SubstOperand (Operand i64 Operand) Operand)
(function SubstBody (Body i64 Operand) Body)
(function SubstVecOperand (VecOperand i64 Operand) VecOperand)
(function SubstVecVecOperand (VecVecOperand i64 Operand) VecVecOperand)

;;  each operand in the vector substitutes into an arg
;;  corresponding to the index
;;                   (vec of arguments, expression to substitute into)
(function SubstExprAll (VecOperand Expr) Expr)
;;; (vec of arguments, vec to substitute into
(function SubstVecOperandAll (VecOperand VecOperand) VecOperand)


(rewrite (SubstExpr (Const ty ops lit) x v) (Const ty ops lit) :ruleset subst)
(rewrite (SubstExpr (Call ty f args) x v) (Call ty f (SubstVecOperand args x v)) :ruleset subst)
(rewrite (SubstExpr (badd ty a b) x v) (badd ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bsub ty a b) x v) (bsub ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bmul ty a b) x v) (bmul ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bdiv ty a b) x v) (bdiv ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (beq ty a b) x v) (beq ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (blt ty a b) x v) (blt ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bgt ty a b) x v) (bgt ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (ble ty a b) x v) (ble ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bge ty a b) x v) (bge ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bnot ty a b) x v) (bnot ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (band ty a b) x v) (band ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bor ty a b) x v) (bor ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)

(rewrite (SubstOperand (Arg x) x v) v :ruleset subst)
(rule ((= f (SubstOperand (Arg y) x v)) (!= y x))
      ((union f (Arg y))) :ruleset subst)
(rewrite (SubstOperand (Node b) x v) (Node (SubstBody b x v)) :ruleset subst)
(rewrite (SubstOperand (Project i b) x v) (Project i (SubstBody b x v)) :ruleset subst)

(rewrite (SubstBody (PureOp e) x v) (PureOp (SubstExpr e x v)) :ruleset subst)
;; Subst doesn't cross regions - so we subst into the inputs but not outputs
;; Node that a Gamma node's idx is on the outside, so it gets affected, but not
;; a Theta node's predicate
(rewrite (SubstBody (Gamma pred inputs outputs) x v) (Gamma (SubstOperand pred x v) (SubstVecOperand inputs x v) outputs) :ruleset subst)
(rewrite (SubstBody (Theta pred inputs outputs) x v) (Theta pred (SubstVecOperand inputs x v) outputs) :ruleset subst)

;; params: vec, var, op, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecOperandHelper (VecOperand i64 Operand i64) VecOperand)
(rewrite (SubstVecOperand vec x v) (SubstVecOperandHelper vec x v 0) :ruleset subst)
(rule
  (
    (= f (SubstVecOperandHelper (VO vec) x v i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (SubstVecOperandHelper (VO vec) x v i)
      (SubstVecOperandHelper
        (VO (vec-set vec i (SubstOperand (vec-get vec i) x v)))
        x v (+ i 1)
        ))
  ) :ruleset subst)

(rule
  (
    (= f (SubstVecOperandHelper (VO vec) x v i))
    (= i (vec-length vec))
  )
  ( 
    (union (SubstVecOperandHelper (VO vec) x v i) (VO vec))
  ) :ruleset subst)


;; params: vec, var, op, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecVecOperandHelper (VecVecOperand i64 Operand i64) VecVecOperand)
(rewrite (SubstVecVecOperand vec x v) (SubstVecVecOperandHelper vec x v 0) :ruleset subst)
(rule
  (
    (= f (SubstVecVecOperandHelper (VVO vec) x v i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (SubstVecVecOperandHelper (VVO vec) x v i)
      (SubstVecVecOperandHelper
        (VVO (vec-set vec i (SubstVecOperand (vec-get vec i) x v)))
        x v (+ i 1)
        ))
  ) :ruleset subst)

(rule
  (
    (= f (SubstVecVecOperandHelper (VVO vec) x v i))
    (= i (vec-length vec))
  )
  ( 
    (union (SubstVecVecOperandHelper (VVO vec) x v i) (VVO vec))
  ) :ruleset subst)
 



;; ###########################################
;; handle SubstExprAll and SubstVecOperandAll

;;       (vec of arguments, progress through that vec, and the expression to substitute into
;; progress means that for all indices before it, we already did the subtitution
(function SubstExprAllHelper (VecOperand i64 Expr) Expr :cost 100)
(rewrite (SubstExprAll arg-vec expr)
         (SubstExprAllHelper arg-vec 0 expr)
         :ruleset subst)

(rule
  ((= helper (SubstExprAllHelper (VO arg-vec) progress expr))
   (< progress (vec-length arg-vec)))
  ((union helper
          (SubstExprAllHelper
            (VO arg-vec)
            ;; increment progress
            (+ progress 1)
            ;; substitute the current argument into the expression
            (SubstExpr expr progress (vec-get arg-vec progress)))))
    :ruleset subst)

;; base case: we are done substituting
(rule
  ((= helper (SubstExprAllHelper (VO arg-vec) progress expr))
   (= progress (vec-length arg-vec)))
  ((union helper expr))
  :ruleset subst)


;; same as SubstExprAllHelper, but substituting into a vec of operands
(function SubstVecOperandAllHelper (VecOperand i64 VecOperand) VecOperand :cost 100)
(rewrite (SubstVecOperandAll arg-vec expr)
         (SubstVecOperandAllHelper arg-vec 0 expr)
         :ruleset subst)

(rule
  ((= helper (SubstVecOperandAllHelper (VO arg-vec) progress expr))
   (< progress (vec-length arg-vec)))
  ((union helper
          (SubstVecOperandAllHelper
            (VO arg-vec)
            ;; increment progress
            (+ progress 1)
            ;; substitute the current argument into the expression
            (SubstVecOperand expr progress (vec-get arg-vec progress)))))
  :ruleset subst)

;; base case: we are done substituting
(rule
  ((= helper (SubstVecOperandAllHelper (VO arg-vec) progress expr))
   (= progress (vec-length arg-vec)))
  ((union helper expr))
  :ruleset subst)


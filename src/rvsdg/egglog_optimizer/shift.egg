;; Shift
(ruleset shift)

;; Within e, replace all (Args x) where x > last-unshifted
;; with (Args (x + amt))
;;                             e             last-unshifted  amt
(function ShiftExpr           (Expr          i64             i64) Expr)
(function ShiftOperand        (Operand       i64             i64) Operand)
(function ShiftBody           (Body          i64             i64) Body)
(function ShiftVecOperand     (VecOperand    i64             i64) VecOperand)
(function ShiftVecVecOperand  (VecVecOperand i64             i64) VecVecOperand)

(rewrite (ShiftExpr (Const ty ops lit) last-unshifted amt) (Const ty ops lit) :ruleset shift)
(rewrite (ShiftExpr (Call ty f args) last-unshifted amt) (Call ty f (ShiftVecOperand args last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (add ty a b) last-unshifted amt) (add ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (sub ty a b) last-unshifted amt) (sub ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (mul ty a b) last-unshifted amt) (mul ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (div ty a b) last-unshifted amt) (div ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (eq ty a b) last-unshifted amt) (eq ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (lt ty a b) last-unshifted amt) (lt ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (gt ty a b) last-unshifted amt) (gt ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (le ty a b) last-unshifted amt) (le ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (ge ty a b) last-unshifted amt) (ge ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (not ty a b) last-unshifted amt) (not ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (and ty a b) last-unshifted amt) (and ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (or ty a b) last-unshifted amt) (or ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)

(rule ((= f (ShiftOperand (Arg x) last-unshifted amt)) (<= x last-unshifted))
      ((union f (Arg x))) :ruleset shift)
(rule ((= f (ShiftOperand (Arg x) last-unshifted amt)) (> x last-unshifted))
      ((union f (Arg (+ x amt)))) :ruleset shift)

(rewrite (ShiftOperand (Node b) last-unshifted amt) (Node (ShiftBody b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftOperand (Project i b) last-unshifted amt) (Project i (ShiftBody b last-unshifted amt)) :ruleset shift)

(rewrite (ShiftBody (PureOp e) last-unshifted amt) (PureOp (ShiftExpr e last-unshifted amt)) :ruleset shift)
;; Shift doesn't cross regions - so we shift into the inputs but not outputs
;; Node that a Gamma node's idx is on the outside, so it gets affected, but not
;; a Theta node's predicate
(rewrite (ShiftBody (Gamma pred inputs outputs) last-unshifted amt) (Gamma (ShiftOperand pred last-unshifted amt) (ShiftVecOperand inputs last-unshifted amt) outputs) :ruleset shift)
(rewrite (ShiftBody (Theta pred inputs outputs) last-unshifted amt) (Theta pred (ShiftVecOperand inputs last-unshifted amt) outputs) :ruleset shift)

;; params: vec, var, op, next index to shift
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function ShiftVecOperandHelper (VecOperand i64 i64 i64) VecOperand)
(rewrite (ShiftVecOperand vec last-unshifted amt) (ShiftVecOperandHelper vec last-unshifted amt 0) :ruleset shift)
(rule
  (
    (= f (ShiftVecOperandHelper (VO vec) last-unshifted amt i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (ShiftVecOperandHelper (VO vec) last-unshifted amt i)
      (ShiftVecOperandHelper
        (VO (vec-set vec i (ShiftOperand (vec-get vec i) last-unshifted amt)))
        last-unshifted amt (+ i 1)
        ))
  ) :ruleset shift)

(rule
  (
    (= f (ShiftVecOperandHelper (VO vec) last-unshifted amt i))
    (= i (vec-length vec))
  )
  ( 
    (union (ShiftVecOperandHelper (VO vec) last-unshifted amt i) (VO vec))
  ) :ruleset shift)


;; params: vec, var, op, next index to shift
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function ShiftVecVecOperandHelper (VecVecOperand i64 i64 i64) VecVecOperand)
(rewrite (ShiftVecVecOperand vec last-unshifted amt) (ShiftVecVecOperandHelper vec last-unshifted amt 0) :ruleset shift)
(rule
  (
    (= f (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i)
      (ShiftVecVecOperandHelper
        (VVO (vec-set vec i (ShiftVecOperand (vec-get vec i) last-unshifted amt)))
        last-unshifted amt (+ i 1)
        ))
  ) :ruleset shift)

(rule
  (
    (= f (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i))
    (= i (vec-length vec))
  )
  ( 
    (union (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i) (VVO vec))
  ) :ruleset shift)

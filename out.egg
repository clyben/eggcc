; Every term is an `Expr` or a `ListExpr`.
(datatype Expr)
; Used for constructing a list of branches for `Switch`es
; or a list of functions in a `Program`.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype BaseType
  (IntT)
  (BoolT)
  ; a pointer to a memory region with a particular type
  (PointerT BaseType)
  (StateT))


(datatype Type
  ; a primitive type
  (Base BaseType)
  ; a typed tuple. Use an empty tuple as a unit type.
  ; state edge also has unit type
  (TupleT TypeList)
)

(function TNil () TypeList)
(function TCons (BaseType TypeList) TypeList) ; Head element should never be a tuple


; =================================
; Leaf nodes
; Constants, argument, and empty tuple
; =================================

; Only a single argument is bound- if multiple values are needed, arg will be a tuple.
; e.g. `(Get (Arg tuple_type) 1)` gets the second value in the argument with some tuple_type.
(function Arg (Type) Expr)

; Constants
(datatype Constant
  (Int i64)
  (Bool bool))
; All leaf nodes need the type of the argument
; Type is the type of the bound argument in scope
(function Const (Constant Type) Expr)

; An empty tuple.
; Type is the type of the bound argument in scope
(function Empty (Type) Expr)


; =================================
; Operators
; =================================

(datatype TernaryOp
  ; given a pointer, value, and a state edge
  ; writes the value to the pointer and returns
  ; the resulting state edge
  (Write))
(datatype BinaryOp
  (Add)
  (Sub)
  (Div)
  (Mul)
  (LessThan)
  (GreaterThan)
  (LessEq)
  (GreaterEq)
  (Eq)
  (And)
  (Or)
  ; given a pointer and a state edge
  ; loads the value at the pointer and returns (value, state edge)
  (Load)
  ; Takes a pointer and an integer, and offsets
  ; the pointer by the integer
  (PtrAdd)
  ; given and value and a state edge, prints the value as a side-effect
  ; the value must be a base value, not a tuple
  ; returns an empty tuple
  (Print)
  ; given a pointer and state edge, frees the whole memory region at the pointer
  (Free))
(datatype UnaryOp
  (Not))

; Operators
(function Top   (TernaryOp Expr Expr Expr) Expr)
(function Bop   (BinaryOp Expr Expr) Expr)
(function Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(function Get   (Expr i64) Expr)
; (Alloc amount state_edge pointer_type)
; allocate an integer amount of memory for a particular type
; returns a pointer to the allocated memory
(function Alloc (i64 Expr Expr BaseType)      Expr)
;               name of func   arg
(function Call (String         Expr) Expr)



; =================================
; Tuple operations
; =================================

; `Empty`, `Single` and `Concat` create tuples.
; 1. Use `Empty` for an empty tuple.
; 2. Use `Single` for a tuple with one element.
; 3. Use `Concat` to append the elements from two tuples together.
; Nested tuples are not allowed.


; A tuple with a single element.
; Necessary because we only use `Concat` to add to tuples.
(function Single (Expr) Expr)
; Concat appends the elemnts from two tuples together
; e.g. (Concat (Concat (Single a) (Single b))
;              (Concat (Single c) (Single d))) = (a, b, c, d)
;                 order   expr1       expr2
(function Concat (Expr        Expr)       Expr)



; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; Does not create a region.
; pred must be an integer
;                 pred     branches     chosen
(function Switch (Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred then else
(function If (Expr Expr Expr) Expr)


; A do-while loop.
; Evaluates the input, then evaluates the body.
; Keeps looping while the predicate is true.
; input must have the same type as (output1, output2, ..., outputi)
; input must be a tuple 
; pred must be a boolean
; pred-and-body must be a flat tuple (pred, out1, out2, ..., outi)
; input must be the same type as (out1, out2, ..., outi)
;                  input   pred-and-body
(function DoWhile (Expr    Expr)                   Expr)




; =================================
; InContext
; =================================

(datatype Assumption
  ; Assume nothing
  (NoContext)
  ; The term is in a loop with `input` and `pred_output`.
  ; InLoop is a special context because it describes the argument of the loop. It is a *scope context*.
  ;      input    pred_output
  (InLoop Expr     Expr)
  ; Assume that the expression matches the boolean
  (InIf bool Expr)
)

; InContext allows creating context-specific terms.
(function InContext (Assumption Expr) Expr)


; =================================
; Top-level expressions
; =================================
(sort ProgramType)
; An entry function and a list of additional functions.
;                      entry function     other functions
(function Program     (Expr               ListExpr) ProgramType)
;                   name   input ty  output ty  output
(function Function (String Type      Type       Expr)      Expr)



; Rulesets
(ruleset always-run)
(ruleset error-checking)

(ruleset type-analysis)
(ruleset type-helpers)       ;; these rules need to saturate between every iter of type-analysis rules

(function TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-helpers)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-helpers)

(function TypeList-length (TypeList) i64)
(function TypeList-ith (TypeList i64) BaseType :unextractable)
(function TypeList-suffix (TypeList i64) TypeList :unextractable)

(rule ((TupleT tylist)) ((union (TypeList-suffix tylist 0) tylist)) :ruleset type-helpers)

(rule ((= (TypeList-suffix top n) (TCons hd tl)))
    ((union (TypeList-ith top n) hd)
     (union (TypeList-suffix top (+ n 1)) tl)) :ruleset type-helpers)

(rule ((= (TypeList-suffix list n) (TNil)))
    ((set (TypeList-length list) n)) :ruleset type-helpers)


(relation HasType (Expr Type))

;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; OKAY to compare types for equality because we never union types.
      )
      ((panic "type mismatch, better error message later :(")) ; once egglog allows non-literal panics
      :ruleset type-analysis)

(relation HasArgType (Expr Type))

(rule ((HasArgType (Arg t1) t2)
       (!= t1 t2))
      ((panic "arg type mismatch"))
      :ruleset type-analysis)

(rule ((= lhs (Function name in out body))
       (HasArgType body ty)
       (HasArgType body ty2)
       (!= ty ty2))
      ((panic "arg type mismatch in function"))
      :ruleset type-analysis)

; Propagate arg types up
(rule ((= lhs (Uop _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType a ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Bop _ a b))
       (HasArgType b ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Get e _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Alloc _id e state _))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Call _ e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Single e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e1 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Concat e1 e2))
       (HasArgType e2 ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((HasArgType (Switch pred (Cons branch (Nil))) ty))
      (
        (HasArgType pred ty)
        (HasArgType branch ty)
      )
      :ruleset type-analysis)
(rule ((= lhs (Switch pred (Cons branch rest)))
       (HasArgType pred ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred (Cons branch rest)))
       (HasArgType branch ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
;; demand with one fewer branches
(rule ((= lhs (Switch pred (Cons branch rest))))
      ((Switch pred rest))
      :ruleset type-analysis)
(rule ((= lhs (Switch pred (Cons branch rest)))
       (HasArgType (Switch pred rest) ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c t e))
       (HasArgType c ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c t e))
       (HasArgType t ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (If c t e))
       (HasArgType e ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (DoWhile ins body))
       (HasArgType ins ty))
      ((HasArgType lhs ty))
      :ruleset type-analysis)
; Don't push arg types through Program, Function, DoWhile, Let exprs because
; these create new arg contexts.

; Primitives
(rule ((= lhs (Const (Int i) ty)))
      ((HasType lhs (Base (IntT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b) ty)))
      ((HasType lhs (Base (BoolT)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (Empty ty)))
      ((HasType lhs (TupleT (TNil)))
       (HasArgType lhs ty))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not) expected bool, received {?}"))
      :ruleset type-analysis)


(rule (
        (= lhs (Bop (Print) e state))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Print) e state))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset type-analysis)


(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (PointerT _ty))))
      ((HasType lhs (Base (StateT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (Base (IntT))))
      ((panic "Free expected pointer, received integer"))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Free) e s))
       (HasType e (TupleT _ty)))
      ((panic "Free expected pointer, received tuple"))
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Load) e state))
        (HasType e (Base (PointerT ty)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (Base (IntT)))
      )
      ((panic "(Load) expected pointer, received int"))
      :ruleset type-analysis)
(rule (
        (= lhs (Bop (Load) e state))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset type-analysis)

; Binary ops
(rule (
        (= lhs (Bop (Add) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Add) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Add) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Add) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (Sub) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Sub) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Sub) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Sub) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (Mul) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Mul) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Mul) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Mul) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (LessThan) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (LessThan) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(LessThan) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(LessThan) expected int, received {?}")
      )
      :ruleset type-analysis)  


(rule (
        (= lhs (Bop (LessEq) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (LessEq) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(LessThan) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(LessThan) expected int, received {?}")
      )
      :ruleset type-analysis)


(rule (
        (= lhs (Bop (GreaterEq) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (GreaterEq) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(LessThan) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(LessThan) expected int, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Eq) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Eq) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Eq) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Eq) expected int, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (GreaterThan) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (GreaterThan) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(GreaterThan) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(GreaterThan) expected int, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (And) e1 e2))
        (HasType e1 (Base (BoolT)))
        (HasType e2 (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (And) e1 e2)))
      (
        (ExpectType e1 (Base (BoolT)) "(And) expected bool, received {?}")
        (ExpectType e2 (Base (BoolT)) "(And) expected bool, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Or) e1 e2))
        (HasType e1 (Base (BoolT)))
        (HasType e2 (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Or) e1 e2)))
      (
        (ExpectType e1 (Base (BoolT)) "(Or) expected bool, received {?}")
        (ExpectType e2 (Base (BoolT)) "(Or) expected bool, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Top (Write) ptr val state))
        (HasType ptr (Base (PointerT ty)))
        (HasType val (Base t)) ; TODO need to support pointers to pointers
      )
      ((HasType lhs (Base (StateT)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
       (= lhs (Top (Write) ptr val state))
       (HasType ptr (Base (PointerT ty))))
      ((ExpectType val (Base ty) "(Write) type mismatch, received {?}"))
      :ruleset type-analysis)
      
       

(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (Base (PointerT ty)))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (Base (PointerT ty))))
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc _id amt state ty))) 
      ((ExpectType amt (Base (IntT)) "(Alloc) expected int, got {?}"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc _id amt state ty))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (TupleT (TCons ty (TCons (StateT) (TNil))))))
      :ruleset type-analysis)

(rule (
        (= lhs (Get e i))
        (HasType e (TupleT tylist))
      )
      ; TypeList-ith needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (Base (TypeList-ith tylist i)))) 
      :ruleset type-analysis)

(rule (
       (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
       (>= i len))
      ((panic "index out of bounds"))
      :ruleset type-analysis)
(rule (
      (HasType (Get expr i) (TupleT tl))
       (= (TypeList-length tl) len)
        (< i 0)
      )
      ((panic "negative index"))
      :ruleset type-analysis)

; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset type-analysis)

(rule (
        (= lhs (Single e))
        (HasType e (Base basety))
      )
      ((HasType lhs (TupleT (TCons basety (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ; TLConcat needs to compute immediately, so we need to saturate type-helpers
      ; rules between every iter of type-analysis rules.
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)

; =================================
; Control flow
; =================================
(rule ((= lhs (If pred then else)))
      ((ExpectType pred (Base (BoolT)) "If predicate must be boolean"))
      :ruleset type-analysis)
(rule (
        (= lhs (If pred then else))
        (HasType pred (Base (BoolT)))
        (HasType then ty)
        (HasType else ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (If pred then else))
        (HasType pred (Base (BoolT)))
        (HasType then tya)
        (HasType else tyb)
        (!= tya tyb)
      )
      ((panic "if branches had different types"))
      :ruleset type-analysis)



(rule ((= lhs (Switch pred branches)))
      ((ExpectType pred (Base (IntT)) "Switch predicate must be integer"))
      :ruleset type-analysis)

; base case: single branch switch has type of branch
(rule (
        (= lhs (Switch pred (Cons branch (Nil))))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; recursive case: peel off a layer
(rule ((Switch pred (Cons branch rest)))
      ((Switch pred rest))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
        (HasType (Switch pred rest) ty) ; rest of the branches also have type ty
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch tya)
        (HasType (Switch pred rest) tyb)
        (!= tya tyb)
      )
      ((panic "switch branches had different types"))
      :ruleset type-analysis)

(rule ((Arg ty))
      (
        (HasType (Arg ty) ty)
        (HasArgType (Arg ty) ty)
      )
      :ruleset type-analysis)


(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset type-analysis)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base (PointerT ty)))
      )
      ((panic "loop input must be tuple"))
      :ruleset type-analysis)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset type-analysis)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base (PointerT ty)))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist))
      )
      ((HasArgType pred-body (TupleT tylist)))
      :ruleset type-analysis)

(rule ((= lhs (DoWhile inp pred-body)))
      ((ExpectType (Get pred-body 0) (Base (BoolT)) "loop pred must be bool"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist)) ; input is a tuple
        ; pred-body is a tuple where the first elt is a bool
        ; and the rest of the list matches the input type
        (HasType pred-body (TupleT (TCons (BoolT) tylist)))
      )
      ((HasType lhs (TupleT tylist))) ; whole thing has type of inputs/outputs
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT in-tys))
        (HasType pred-body (TupleT (TCons (BoolT) out-tys)))
        (!= in-tys out-tys)
      )
      ((panic "input types and output types don't match"))
      :ruleset type-analysis)

; =================================
; Functions
; =================================

(rule ((= lhs (Function name in-ty out-ty body)))
      (
        ; Arg should have the specified type in the body
        (HasArgType body in-ty)
        ; Expect the body to have the specified output type
        (ExpectType body out-ty "Function body had wrong type")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (Function name in-ty out-ty body)
      )
      ; Expect the arg to have the right type for the function
      ((ExpectType arg in-ty "function called with wrong arg type"))
      :ruleset type-analysis)

(rule (
        (= lhs (Call name arg))
        (Function name in-ty out-ty body)
        (HasType arg in-ty)
        ; We don't need to check the type of the function body, it will
        ; be checked elsewhere. If we did require (HasType body out-ty),
        ; recursive functions would not get assigned a type.
      )
      ((HasType lhs out-ty))
      :ruleset type-analysis)

; =================================
; InContext
; =================================
(rule (
        (= lhs (InContext ass expr))
        (HasType expr ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule ((= lhs (InContext ass expr))
       (HasArgType expr argtype))
      ((HasArgType lhs argtype))
      :ruleset type-analysis)
(ruleset interval-analysis)



(datatype Interval
  (BoolI bool bool)
  (IntI i64 i64)
  (interval-intersect Interval Interval)
  (interval-union Interval Interval))

; Interval combinators
(rewrite (interval-intersect (IntI la ha) (IntI lb hb))
         (IntI (max la lb) (min ha hb))
         :ruleset interval-analysis)
(rewrite (interval-union (IntI la ha) (IntI lb hb))
         (IntI (min la lb) (max ha hb))
         :ruleset interval-analysis)
(rewrite (interval-intersect (BoolI la ha) (BoolI lb hb))
         (BoolI (or la lb) (and ha hb))
         :ruleset interval-analysis)
(rewrite (interval-union (BoolI la ha) (BoolI lb hb))
         (BoolI (and la lb) (or ha hb))
         :ruleset interval-analysis)

; Interval Table
(function ival (Expr) Interval
  :merge (interval-intersect old new))

; =================================
; Constants
; =================================
(rule ((= lhs (Const (Int x) ty)))
      ((set (ival lhs) (IntI x x)))
      :ruleset interval-analysis)

(rule ((= lhs (Const (Bool x) ty)))
      ((set (ival lhs) (BoolI x x)))
      :ruleset interval-analysis)

; =================================
; Constant Folding
; =================================
(rule (
       (= (IntI x x) (ival expr))
       (HasArgType expr ty)
      )
      ((union expr (Const (Int x) ty)))
      :ruleset interval-analysis)

(rule (
       (= (BoolI x x) (ival expr))
       (HasArgType expr ty)
      )
      ((union expr (Const (Bool x) ty)))
      :ruleset interval-analysis)

; =================================
; Arithmetic
; =================================
; + a b interval is (+ la lb) (+ ha hb)
(rule (
       (= lhs (Bop (Add) x y))
       (= (ival x) (IntI la ha))
       (= (ival y) (IntI lb hb))
      )
      ((set (ival lhs) (IntI (+ la hb) (+ ha hb))))
      :ruleset interval-analysis)

; < a b interval is (< ha lb) (< la hb)
(rule (
        (= lhs (Bop (LessThan) a b))
        (= (IntI la ha) (ival a))
        (= (IntI lb hb) (ival b))
      )
      ((set (ival lhs) (BoolI (bool-< ha lb) (bool-< la hb))))
      :ruleset interval-analysis)

; =================================
; Conditionals
; =================================
(rule (
        (= lhs (If cond thn els))
        (= thn-ival (ival thn))
        (= els-ival (ival els))
      )
      ((set (ival lhs) (interval-union thn-ival els-ival)))
      :ruleset interval-analysis)

(function ListExpr-length (ListExpr) i64)
(function ListExpr-ith (ListExpr i64) Expr :unextractable)
(function ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(function Append (ListExpr Expr) ListExpr :unextractable)

(rule ((Switch pred branch)) ((union (ListExpr-suffix branch 0) branch)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
   (Cons a (Append b e))
   :ruleset always-run)
(rewrite (Append (Nil) e)
   (Cons e (Nil))
   :ruleset always-run)

(function tuple-length (Expr) i64 :unextractable)

(rule ((HasType expr (TupleT tl))
       (= len (TypeList-length tl)))
      ((set (tuple-length expr) len)) :ruleset always-run)

;; Create a Get for every index, and rewrite it to see through Concat
(rule ((Single expr)) ((union (Get (Single expr) 0) expr)) :ruleset always-run)
;; initial get
(rule ((Concat expr1 expr2)
       (> (tuple-length (Concat expr1 expr2)) 0))
      ((Get (Concat expr1 expr2) 0))
      :ruleset always-run)
;; next get
(rule ((= concat (Concat expr1 expr2))
       (= len (tuple-length concat))
       (= ith (Get concat i))
       (< (+ i 1) len)
       )
       ((Get (Concat expr1 expr2) (+ 1 i)))
       :ruleset always-run)

;; descend left
(rule ((Get (Concat expr1 expr2) i)
       (= (tuple-length expr1) len1)
       (< i len1))
      ((union (Get (Concat expr1 expr2) i)
              (Get expr1 i)))
       :ruleset always-run)
;; descend right
(rule ((Get (Concat expr1 expr2) i)
       (= (tuple-length expr1) len1)
       (>= i len1))
      ((union (Get (Concat expr1 expr2) i)
              (Get expr2 (- i len1))))
       :ruleset always-run)


(relation IsLeaf (Expr))
(rule ((Arg ty)) ((IsLeaf (Arg ty))) :ruleset always-run)
(rule ((Const val ty)) ((IsLeaf (Const val ty))) :ruleset always-run)
(rule ((Empty ty)) ((IsLeaf (Empty ty))) :ruleset always-run)

(rewrite (Concat (Concat a b) c)
         (Concat a (Concat b c))
         :ruleset always-run)

(relation ExprIsValid (Expr))
(relation ListExprIsValid (ListExpr))
(rule ((ExprIsValid (Function _name _tyin _tyout _out))) ((ExprIsValid _out)) :ruleset always-run)
(rule ((ExprIsValid (Top _op _x _y _z))) ((ExprIsValid _x)
(ExprIsValid _y)
(ExprIsValid _z)) :ruleset always-run)
(rule ((ExprIsValid (Bop _op _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Uop _op _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Get _tup _i))) ((ExprIsValid _tup)) :ruleset always-run)
(rule ((ExprIsValid (Concat _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Single _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Switch _pred _branches))) ((ExprIsValid _pred)
(ListExprIsValid _branches)) :ruleset always-run)
(rule ((ExprIsValid (If _pred _then _else))) ((ExprIsValid _pred)
(ExprIsValid _then)
(ExprIsValid _else)) :ruleset always-run)
(rule ((ExprIsValid (DoWhile _in _pred-and-output))) ((ExprIsValid _in)
(ExprIsValid _pred-and-output)) :ruleset always-run)
(rule ((ExprIsValid (Call _func _arg))) ((ExprIsValid _arg)) :ruleset always-run)
(rule ((ListExprIsValid (Cons _hd _tl))) ((ExprIsValid _hd)
(ListExprIsValid _tl)) :ruleset always-run)
(rule ((ExprIsValid (Alloc _id _e _state _ty))) ((ExprIsValid _e)
(ExprIsValid _state)) :ruleset always-run)
(rule ((ExprIsValid (InContext _assumption _e))) ((ExprIsValid _e)) :ruleset always-run)
(relation BodyContainsExpr (Expr Expr))
(relation BodyContainsListExpr (Expr ListExpr))
(rule ((DoWhile _in _pred-and-output)) ((BodyContainsExpr (DoWhile _in _pred-and-output) _pred-and-output)) :ruleset always-run)
(rule ((BodyContainsExpr body (Function _name _tyin _tyout _out))) ((BodyContainsExpr body _out)) :ruleset always-run)
(rule ((BodyContainsExpr body (Top _op _x _y _z))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y) (BodyContainsExpr body _z)) :ruleset always-run)
(rule ((BodyContainsExpr body (Bop _op _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Uop _op _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Get _tup _i))) ((BodyContainsExpr body _tup)) :ruleset always-run)
(rule ((BodyContainsExpr body (Concat _x _y))) ((BodyContainsExpr body _x) (BodyContainsExpr body _y)) :ruleset always-run)
(rule ((BodyContainsExpr body (Single _x))) ((BodyContainsExpr body _x)) :ruleset always-run)
(rule ((BodyContainsExpr body (Switch _pred _branches))) ((BodyContainsExpr body _pred) (BodyContainsListExpr body _branches)) :ruleset always-run)
(rule ((BodyContainsExpr body (If _pred _then _else))) ((BodyContainsExpr body _pred) (BodyContainsExpr body _then) (BodyContainsExpr body _else)) :ruleset always-run)
(rule ((BodyContainsExpr body (DoWhile _in _pred-and-output))) ((BodyContainsExpr body _in)) :ruleset always-run)
(rule ((BodyContainsExpr body (Call _func _arg))) ((BodyContainsExpr body _arg)) :ruleset always-run)
(rule ((BodyContainsListExpr body (Cons _hd _tl))) ((BodyContainsExpr body _hd) (BodyContainsListExpr body _tl)) :ruleset always-run)
(rule ((BodyContainsExpr body (Alloc _id _e _state _ty))) ((BodyContainsExpr body _e) (BodyContainsExpr body _state)) :ruleset always-run)
(rule ((BodyContainsExpr body (InContext _assumption _e))) ((BodyContainsExpr body _e)) :ruleset always-run)

        (relation ExprIsPure (Expr))
        (relation ListExprIsPure (ListExpr))
        (relation BinaryOpIsPure (BinaryOp))
        (relation UnaryOpIsPure (UnaryOp))
(BinaryOpIsPure (Add))
(BinaryOpIsPure (Sub))
(BinaryOpIsPure (Mul))
(BinaryOpIsPure (Div))
(BinaryOpIsPure (Eq))
(BinaryOpIsPure (LessThan))
(BinaryOpIsPure (GreaterThan))
(BinaryOpIsPure (LessEq))
(BinaryOpIsPure (GreaterEq))
(BinaryOpIsPure (And))
(BinaryOpIsPure (Or))
(BinaryOpIsPure (PtrAdd))
(UnaryOpIsPure (Not))

                (rule ((Function _name _tyin _tyout _out) (ExprIsPure _out))
                      ((ExprIsPure (Function _name _tyin _tyout _out)))
                      :ruleset always-run)

                (rule ((Const _n _ty))
                      ((ExprIsPure (Const _n _ty)))
                      :ruleset always-run)

                (rule ((Top _op _x _y _z) (ExprIsPure _x) (ExprIsPure _y) (ExprIsPure _z))
                      ((ExprIsPure (Top _op _x _y _z)))
                      :ruleset always-run)

                (rule ((Bop _op _x _y) (BinaryOpIsPure _op) (ExprIsPure _x) (ExprIsPure _y))
                      ((ExprIsPure (Bop _op _x _y)))
                      :ruleset always-run)

                (rule ((Uop _op _x) (UnaryOpIsPure _op) (ExprIsPure _x))
                      ((ExprIsPure (Uop _op _x)))
                      :ruleset always-run)

                (rule ((Get _tup _i) (ExprIsPure _tup))
                      ((ExprIsPure (Get _tup _i)))
                      :ruleset always-run)

                (rule ((Concat _x _y) (ExprIsPure _x) (ExprIsPure _y))
                      ((ExprIsPure (Concat _x _y)))
                      :ruleset always-run)

                (rule ((Single _x) (ExprIsPure _x))
                      ((ExprIsPure (Single _x)))
                      :ruleset always-run)

                (rule ((Switch _pred _branches) (ExprIsPure _pred) (ListExprIsPure _branches))
                      ((ExprIsPure (Switch _pred _branches)))
                      :ruleset always-run)

                (rule ((If _pred _then _else) (ExprIsPure _pred) (ExprIsPure _then) (ExprIsPure _else))
                      ((ExprIsPure (If _pred _then _else)))
                      :ruleset always-run)

                (rule ((DoWhile _in _pred-and-output) (ExprIsPure _in) (ExprIsPure _pred-and-output))
                      ((ExprIsPure (DoWhile _in _pred-and-output)))
                      :ruleset always-run)

                (rule ((Arg _ty))
                      ((ExprIsPure (Arg _ty)))
                      :ruleset always-run)

            (rule ((Call _f _arg) (ExprIsPure _arg) (ExprIsPure (Function _f inty outty out)))
                  ((ExprIsPure (Call _f _arg)))
                  :ruleset always-run)

                (rule ((Empty _ty))
                      ((ExprIsPure (Empty _ty)))
                      :ruleset always-run)

                (rule ((Cons _hd _tl) (ExprIsPure _hd) (ListExprIsPure _tl))
                      ((ListExprIsPure (Cons _hd _tl)))
                      :ruleset always-run)

                (rule ((Nil))
                      ((ListExprIsPure (Nil)))
                      :ruleset always-run)


                (rule ((InContext _assumption _e) (ExprIsPure _e))
                      ((ExprIsPure (InContext _assumption _e)))
                      :ruleset always-run)

        (ruleset conditional-invariant-code-motion)
        (relation DemandSameIgnoring (ListExpr))
        (rule ((DemandSameIgnoring (Cons hd tl))) ((DemandSameIgnoring tl)) :ruleset always-run)
        (rule ((Switch pred exprs)) ((DemandSameIgnoring exprs)) :ruleset always-run)

                ; Compute SameFunctionIgnoring-out, which detects opportunities for lifting
                ; Functions through control flow when only the out field varies
                (relation SameFunctionIgnoring-out (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Function _name _tyin _tyout e1) (Nil))))
                      ((SameFunctionIgnoring-out (Cons (Function _name _tyin _tyout e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Function _name _tyin _tyout e1) (Cons (Function _name _tyin _tyout e2) rest)))
                       (SameFunctionIgnoring-out (Cons (Function _name _tyin _tyout e2) rest)))
                      ((SameFunctionIgnoring-out (Cons (Function _name _tyin _tyout e1) (Cons (Function _name _tyin _tyout e2) rest))))
                      :ruleset always-run)

                ; Given a list of Functions, return a list of each Function's out field
                (function Map-Function-out (ListExpr) ListExpr)
                (rewrite (Map-Function-out (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Function-out (Cons (Function _name _tyin _tyout e1) rest))
                         (Cons e1 (Map-Function-out rest))
                         :ruleset always-run)

                ; Lift Function when only out varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameFunctionIgnoring-out exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Function _name _tyin _tyout e1) rest)))
                      ((union (Switch pred exprs)
                              (Function _name _tyin _tyout (Switch pred (Map-Function-out exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Function _name _tyin _tyout e1) (Function _name _tyin _tyout e2))
                         (Function _name _tyin _tyout (If c e1 e2))
                         :when ((ExprIsValid (If c (Function _name _tyin _tyout e1) (Function _name _tyin _tyout e2))))
                         :ruleset conditional-invariant-code-motion)


                ; Compute SameTopIgnoring-x, which detects opportunities for lifting
                ; Tops through control flow when only the x field varies
                (relation SameTopIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Top _op e1 _y _z) (Nil))))
                      ((SameTopIgnoring-x (Cons (Top _op e1 _y _z) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Top _op e1 _y _z) (Cons (Top _op e2 _y _z) rest)))
                       (SameTopIgnoring-x (Cons (Top _op e2 _y _z) rest)))
                      ((SameTopIgnoring-x (Cons (Top _op e1 _y _z) (Cons (Top _op e2 _y _z) rest))))
                      :ruleset always-run)

                ; Given a list of Tops, return a list of each Top's x field
                (function Map-Top-x (ListExpr) ListExpr)
                (rewrite (Map-Top-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Top-x (Cons (Top _op e1 _y _z) rest))
                         (Cons e1 (Map-Top-x rest))
                         :ruleset always-run)

                ; Lift Top when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameTopIgnoring-x exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Top _op e1 _y _z) rest)))
                      ((union (Switch pred exprs)
                              (Top _op (Switch pred (Map-Top-x exprs)) _y _z)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Top _op e1 _y _z) (Top _op e2 _y _z))
                         (Top _op (If c e1 e2) _y _z)
                         :when ((ExprIsValid (If c (Top _op e1 _y _z) (Top _op e2 _y _z))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameTopIgnoring-y, which detects opportunities for lifting
                ; Tops through control flow when only the y field varies
                (relation SameTopIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Top _op _x e1 _z) (Nil))))
                      ((SameTopIgnoring-y (Cons (Top _op _x e1 _z) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Top _op _x e1 _z) (Cons (Top _op _x e2 _z) rest)))
                       (SameTopIgnoring-y (Cons (Top _op _x e2 _z) rest)))
                      ((SameTopIgnoring-y (Cons (Top _op _x e1 _z) (Cons (Top _op _x e2 _z) rest))))
                      :ruleset always-run)

                ; Given a list of Tops, return a list of each Top's y field
                (function Map-Top-y (ListExpr) ListExpr)
                (rewrite (Map-Top-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Top-y (Cons (Top _op _x e1 _z) rest))
                         (Cons e1 (Map-Top-y rest))
                         :ruleset always-run)

                ; Lift Top when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameTopIgnoring-y exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Top _op _x e1 _z) rest)))
                      ((union (Switch pred exprs)
                              (Top _op _x (Switch pred (Map-Top-y exprs)) _z)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Top _op _x e1 _z) (Top _op _x e2 _z))
                         (Top _op _x (If c e1 e2) _z)
                         :when ((ExprIsValid (If c (Top _op _x e1 _z) (Top _op _x e2 _z))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameTopIgnoring-z, which detects opportunities for lifting
                ; Tops through control flow when only the z field varies
                (relation SameTopIgnoring-z (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Top _op _x _y e1) (Nil))))
                      ((SameTopIgnoring-z (Cons (Top _op _x _y e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Top _op _x _y e1) (Cons (Top _op _x _y e2) rest)))
                       (SameTopIgnoring-z (Cons (Top _op _x _y e2) rest)))
                      ((SameTopIgnoring-z (Cons (Top _op _x _y e1) (Cons (Top _op _x _y e2) rest))))
                      :ruleset always-run)

                ; Given a list of Tops, return a list of each Top's z field
                (function Map-Top-z (ListExpr) ListExpr)
                (rewrite (Map-Top-z (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Top-z (Cons (Top _op _x _y e1) rest))
                         (Cons e1 (Map-Top-z rest))
                         :ruleset always-run)

                ; Lift Top when only z varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameTopIgnoring-z exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Top _op _x _y e1) rest)))
                      ((union (Switch pred exprs)
                              (Top _op _x _y (Switch pred (Map-Top-z exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Top _op _x _y e1) (Top _op _x _y e2))
                         (Top _op _x _y (If c e1 e2))
                         :when ((ExprIsValid (If c (Top _op _x _y e1) (Top _op _x _y e2))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameBopIgnoring-x, which detects opportunities for lifting
                ; Bops through control flow when only the x field varies
                (relation SameBopIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Bop _op e1 _y) (Nil))))
                      ((SameBopIgnoring-x (Cons (Bop _op e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Bop _op e1 _y) (Cons (Bop _op e2 _y) rest)))
                       (SameBopIgnoring-x (Cons (Bop _op e2 _y) rest)))
                      ((SameBopIgnoring-x (Cons (Bop _op e1 _y) (Cons (Bop _op e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of Bops, return a list of each Bop's x field
                (function Map-Bop-x (ListExpr) ListExpr)
                (rewrite (Map-Bop-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Bop-x (Cons (Bop _op e1 _y) rest))
                         (Cons e1 (Map-Bop-x rest))
                         :ruleset always-run)

                ; Lift Bop when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameBopIgnoring-x exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Bop _op e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (Bop _op (Switch pred (Map-Bop-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Bop _op e1 _y) (Bop _op e2 _y))
                         (Bop _op (If c e1 e2) _y)
                         :when ((ExprIsValid (If c (Bop _op e1 _y) (Bop _op e2 _y))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameBopIgnoring-y, which detects opportunities for lifting
                ; Bops through control flow when only the y field varies
                (relation SameBopIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Bop _op _x e1) (Nil))))
                      ((SameBopIgnoring-y (Cons (Bop _op _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Bop _op _x e1) (Cons (Bop _op _x e2) rest)))
                       (SameBopIgnoring-y (Cons (Bop _op _x e2) rest)))
                      ((SameBopIgnoring-y (Cons (Bop _op _x e1) (Cons (Bop _op _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of Bops, return a list of each Bop's y field
                (function Map-Bop-y (ListExpr) ListExpr)
                (rewrite (Map-Bop-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Bop-y (Cons (Bop _op _x e1) rest))
                         (Cons e1 (Map-Bop-y rest))
                         :ruleset always-run)

                ; Lift Bop when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameBopIgnoring-y exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Bop _op _x e1) rest)))
                      ((union (Switch pred exprs)
                              (Bop _op _x (Switch pred (Map-Bop-y exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Bop _op _x e1) (Bop _op _x e2))
                         (Bop _op _x (If c e1 e2))
                         :when ((ExprIsValid (If c (Bop _op _x e1) (Bop _op _x e2))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameUopIgnoring-x, which detects opportunities for lifting
                ; Uops through control flow when only the x field varies
                (relation SameUopIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Uop _op e1) (Nil))))
                      ((SameUopIgnoring-x (Cons (Uop _op e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Uop _op e1) (Cons (Uop _op e2) rest)))
                       (SameUopIgnoring-x (Cons (Uop _op e2) rest)))
                      ((SameUopIgnoring-x (Cons (Uop _op e1) (Cons (Uop _op e2) rest))))
                      :ruleset always-run)

                ; Given a list of Uops, return a list of each Uop's x field
                (function Map-Uop-x (ListExpr) ListExpr)
                (rewrite (Map-Uop-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Uop-x (Cons (Uop _op e1) rest))
                         (Cons e1 (Map-Uop-x rest))
                         :ruleset always-run)

                ; Lift Uop when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameUopIgnoring-x exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Uop _op e1) rest)))
                      ((union (Switch pred exprs)
                              (Uop _op (Switch pred (Map-Uop-x exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Uop _op e1) (Uop _op e2))
                         (Uop _op (If c e1 e2))
                         :when ((ExprIsValid (If c (Uop _op e1) (Uop _op e2))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameGetIgnoring-tup, which detects opportunities for lifting
                ; Gets through control flow when only the tup field varies
                (relation SameGetIgnoring-tup (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Get e1 _i) (Nil))))
                      ((SameGetIgnoring-tup (Cons (Get e1 _i) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Get e1 _i) (Cons (Get e2 _i) rest)))
                       (SameGetIgnoring-tup (Cons (Get e2 _i) rest)))
                      ((SameGetIgnoring-tup (Cons (Get e1 _i) (Cons (Get e2 _i) rest))))
                      :ruleset always-run)

                ; Given a list of Gets, return a list of each Get's tup field
                (function Map-Get-tup (ListExpr) ListExpr)
                (rewrite (Map-Get-tup (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Get-tup (Cons (Get e1 _i) rest))
                         (Cons e1 (Map-Get-tup rest))
                         :ruleset always-run)

                ; Lift Get when only tup varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameGetIgnoring-tup exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Get e1 _i) rest)))
                      ((union (Switch pred exprs)
                              (Get (Switch pred (Map-Get-tup exprs)) _i)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Get e1 _i) (Get e2 _i))
                         (Get (If c e1 e2) _i)
                         :when ((ExprIsValid (If c (Get e1 _i) (Get e2 _i))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameConcatIgnoring-x, which detects opportunities for lifting
                ; Concats through control flow when only the x field varies
                (relation SameConcatIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Concat e1 _y) (Nil))))
                      ((SameConcatIgnoring-x (Cons (Concat e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Concat e1 _y) (Cons (Concat e2 _y) rest)))
                       (SameConcatIgnoring-x (Cons (Concat e2 _y) rest)))
                      ((SameConcatIgnoring-x (Cons (Concat e1 _y) (Cons (Concat e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of Concats, return a list of each Concat's x field
                (function Map-Concat-x (ListExpr) ListExpr)
                (rewrite (Map-Concat-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Concat-x (Cons (Concat e1 _y) rest))
                         (Cons e1 (Map-Concat-x rest))
                         :ruleset always-run)

                ; Lift Concat when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameConcatIgnoring-x exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Concat e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (Concat (Switch pred (Map-Concat-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Concat e1 _y) (Concat e2 _y))
                         (Concat (If c e1 e2) _y)
                         :when ((ExprIsValid (If c (Concat e1 _y) (Concat e2 _y))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameConcatIgnoring-y, which detects opportunities for lifting
                ; Concats through control flow when only the y field varies
                (relation SameConcatIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Concat _x e1) (Nil))))
                      ((SameConcatIgnoring-y (Cons (Concat _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Concat _x e1) (Cons (Concat _x e2) rest)))
                       (SameConcatIgnoring-y (Cons (Concat _x e2) rest)))
                      ((SameConcatIgnoring-y (Cons (Concat _x e1) (Cons (Concat _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of Concats, return a list of each Concat's y field
                (function Map-Concat-y (ListExpr) ListExpr)
                (rewrite (Map-Concat-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Concat-y (Cons (Concat _x e1) rest))
                         (Cons e1 (Map-Concat-y rest))
                         :ruleset always-run)

                ; Lift Concat when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameConcatIgnoring-y exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Concat _x e1) rest)))
                      ((union (Switch pred exprs)
                              (Concat _x (Switch pred (Map-Concat-y exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Concat _x e1) (Concat _x e2))
                         (Concat _x (If c e1 e2))
                         :when ((ExprIsValid (If c (Concat _x e1) (Concat _x e2))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameSingleIgnoring-x, which detects opportunities for lifting
                ; Singles through control flow when only the x field varies
                (relation SameSingleIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Single e1) (Nil))))
                      ((SameSingleIgnoring-x (Cons (Single e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Single e1) (Cons (Single e2) rest)))
                       (SameSingleIgnoring-x (Cons (Single e2) rest)))
                      ((SameSingleIgnoring-x (Cons (Single e1) (Cons (Single e2) rest))))
                      :ruleset always-run)

                ; Given a list of Singles, return a list of each Single's x field
                (function Map-Single-x (ListExpr) ListExpr)
                (rewrite (Map-Single-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Single-x (Cons (Single e1) rest))
                         (Cons e1 (Map-Single-x rest))
                         :ruleset always-run)

                ; Lift Single when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameSingleIgnoring-x exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Single e1) rest)))
                      ((union (Switch pred exprs)
                              (Single (Switch pred (Map-Single-x exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Single e1) (Single e2))
                         (Single (If c e1 e2))
                         :when ((ExprIsValid (If c (Single e1) (Single e2))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameSwitchIgnoring-pred, which detects opportunities for lifting
                ; Switchs through control flow when only the pred field varies
                (relation SameSwitchIgnoring-pred (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Switch e1 _branches) (Nil))))
                      ((SameSwitchIgnoring-pred (Cons (Switch e1 _branches) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Switch e1 _branches) (Cons (Switch e2 _branches) rest)))
                       (SameSwitchIgnoring-pred (Cons (Switch e2 _branches) rest)))
                      ((SameSwitchIgnoring-pred (Cons (Switch e1 _branches) (Cons (Switch e2 _branches) rest))))
                      :ruleset always-run)

                ; Given a list of Switchs, return a list of each Switch's pred field
                (function Map-Switch-pred (ListExpr) ListExpr)
                (rewrite (Map-Switch-pred (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Switch-pred (Cons (Switch e1 _branches) rest))
                         (Cons e1 (Map-Switch-pred rest))
                         :ruleset always-run)

                ; Lift Switch when only pred varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameSwitchIgnoring-pred exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Switch e1 _branches) rest)))
                      ((union (Switch pred exprs)
                              (Switch (Switch pred (Map-Switch-pred exprs)) _branches)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Switch e1 _branches) (Switch e2 _branches))
                         (Switch (If c e1 e2) _branches)
                         :when ((ExprIsValid (If c (Switch e1 _branches) (Switch e2 _branches))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameIfIgnoring-pred, which detects opportunities for lifting
                ; Ifs through control flow when only the pred field varies
                (relation SameIfIgnoring-pred (ListExpr))
                (rule ((DemandSameIgnoring (Cons (If e1 _then _else) (Nil))))
                      ((SameIfIgnoring-pred (Cons (If e1 _then _else) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (If e1 _then _else) (Cons (If e2 _then _else) rest)))
                       (SameIfIgnoring-pred (Cons (If e2 _then _else) rest)))
                      ((SameIfIgnoring-pred (Cons (If e1 _then _else) (Cons (If e2 _then _else) rest))))
                      :ruleset always-run)

                ; Given a list of Ifs, return a list of each If's pred field
                (function Map-If-pred (ListExpr) ListExpr)
                (rewrite (Map-If-pred (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-If-pred (Cons (If e1 _then _else) rest))
                         (Cons e1 (Map-If-pred rest))
                         :ruleset always-run)

                ; Lift If when only pred varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameIfIgnoring-pred exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (If e1 _then _else) rest)))
                      ((union (Switch pred exprs)
                              (If (Switch pred (Map-If-pred exprs)) _then _else)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (If e1 _then _else) (If e2 _then _else))
                         (If (If c e1 e2) _then _else)
                         :when ((ExprIsValid (If c (If e1 _then _else) (If e2 _then _else))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameIfIgnoring-then, which detects opportunities for lifting
                ; Ifs through control flow when only the then field varies
                (relation SameIfIgnoring-then (ListExpr))
                (rule ((DemandSameIgnoring (Cons (If _pred e1 _else) (Nil))))
                      ((SameIfIgnoring-then (Cons (If _pred e1 _else) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (If _pred e1 _else) (Cons (If _pred e2 _else) rest)))
                       (SameIfIgnoring-then (Cons (If _pred e2 _else) rest)))
                      ((SameIfIgnoring-then (Cons (If _pred e1 _else) (Cons (If _pred e2 _else) rest))))
                      :ruleset always-run)

                ; Given a list of Ifs, return a list of each If's then field
                (function Map-If-then (ListExpr) ListExpr)
                (rewrite (Map-If-then (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-If-then (Cons (If _pred e1 _else) rest))
                         (Cons e1 (Map-If-then rest))
                         :ruleset always-run)

                ; Lift If when only then varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameIfIgnoring-then exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (If _pred e1 _else) rest)))
                      ((union (Switch pred exprs)
                              (If _pred (Switch pred (Map-If-then exprs)) _else)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (If _pred e1 _else) (If _pred e2 _else))
                         (If _pred (If c e1 e2) _else)
                         :when ((ExprIsValid (If c (If _pred e1 _else) (If _pred e2 _else))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameIfIgnoring-else, which detects opportunities for lifting
                ; Ifs through control flow when only the else field varies
                (relation SameIfIgnoring-else (ListExpr))
                (rule ((DemandSameIgnoring (Cons (If _pred _then e1) (Nil))))
                      ((SameIfIgnoring-else (Cons (If _pred _then e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (If _pred _then e1) (Cons (If _pred _then e2) rest)))
                       (SameIfIgnoring-else (Cons (If _pred _then e2) rest)))
                      ((SameIfIgnoring-else (Cons (If _pred _then e1) (Cons (If _pred _then e2) rest))))
                      :ruleset always-run)

                ; Given a list of Ifs, return a list of each If's else field
                (function Map-If-else (ListExpr) ListExpr)
                (rewrite (Map-If-else (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-If-else (Cons (If _pred _then e1) rest))
                         (Cons e1 (Map-If-else rest))
                         :ruleset always-run)

                ; Lift If when only else varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameIfIgnoring-else exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (If _pred _then e1) rest)))
                      ((union (Switch pred exprs)
                              (If _pred _then (Switch pred (Map-If-else exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (If _pred _then e1) (If _pred _then e2))
                         (If _pred _then (If c e1 e2))
                         :when ((ExprIsValid (If c (If _pred _then e1) (If _pred _then e2))))
                         :ruleset conditional-invariant-code-motion)


                ; Compute SameCallIgnoring-arg, which detects opportunities for lifting
                ; Calls through control flow when only the arg field varies
                (relation SameCallIgnoring-arg (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Call _func e1) (Nil))))
                      ((SameCallIgnoring-arg (Cons (Call _func e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Call _func e1) (Cons (Call _func e2) rest)))
                       (SameCallIgnoring-arg (Cons (Call _func e2) rest)))
                      ((SameCallIgnoring-arg (Cons (Call _func e1) (Cons (Call _func e2) rest))))
                      :ruleset always-run)

                ; Given a list of Calls, return a list of each Call's arg field
                (function Map-Call-arg (ListExpr) ListExpr)
                (rewrite (Map-Call-arg (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Call-arg (Cons (Call _func e1) rest))
                         (Cons e1 (Map-Call-arg rest))
                         :ruleset always-run)

                ; Lift Call when only arg varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameCallIgnoring-arg exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Call _func e1) rest)))
                      ((union (Switch pred exprs)
                              (Call _func (Switch pred (Map-Call-arg exprs)))))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Call _func e1) (Call _func e2))
                         (Call _func (If c e1 e2))
                         :when ((ExprIsValid (If c (Call _func e1) (Call _func e2))))
                         :ruleset conditional-invariant-code-motion)


                ; Compute SameAllocIgnoring-e, which detects opportunities for lifting
                ; Allocs through control flow when only the e field varies
                (relation SameAllocIgnoring-e (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Alloc _id e1 _state _ty) (Nil))))
                      ((SameAllocIgnoring-e (Cons (Alloc _id e1 _state _ty) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Alloc _id e1 _state _ty) (Cons (Alloc _id e2 _state _ty) rest)))
                       (SameAllocIgnoring-e (Cons (Alloc _id e2 _state _ty) rest)))
                      ((SameAllocIgnoring-e (Cons (Alloc _id e1 _state _ty) (Cons (Alloc _id e2 _state _ty) rest))))
                      :ruleset always-run)

                ; Given a list of Allocs, return a list of each Alloc's e field
                (function Map-Alloc-e (ListExpr) ListExpr)
                (rewrite (Map-Alloc-e (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Alloc-e (Cons (Alloc _id e1 _state _ty) rest))
                         (Cons e1 (Map-Alloc-e rest))
                         :ruleset always-run)

                ; Lift Alloc when only e varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameAllocIgnoring-e exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Alloc _id e1 _state _ty) rest)))
                      ((union (Switch pred exprs)
                              (Alloc _id (Switch pred (Map-Alloc-e exprs)) _state _ty)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Alloc _id e1 _state _ty) (Alloc _id e2 _state _ty))
                         (Alloc _id (If c e1 e2) _state _ty)
                         :when ((ExprIsValid (If c (Alloc _id e1 _state _ty) (Alloc _id e2 _state _ty))))
                         :ruleset conditional-invariant-code-motion)

                ; Compute SameAllocIgnoring-state, which detects opportunities for lifting
                ; Allocs through control flow when only the state field varies
                (relation SameAllocIgnoring-state (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Alloc _id _e e1 _ty) (Nil))))
                      ((SameAllocIgnoring-state (Cons (Alloc _id _e e1 _ty) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Alloc _id _e e1 _ty) (Cons (Alloc _id _e e2 _ty) rest)))
                       (SameAllocIgnoring-state (Cons (Alloc _id _e e2 _ty) rest)))
                      ((SameAllocIgnoring-state (Cons (Alloc _id _e e1 _ty) (Cons (Alloc _id _e e2 _ty) rest))))
                      :ruleset always-run)

                ; Given a list of Allocs, return a list of each Alloc's state field
                (function Map-Alloc-state (ListExpr) ListExpr)
                (rewrite (Map-Alloc-state (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Alloc-state (Cons (Alloc _id _e e1 _ty) rest))
                         (Cons e1 (Map-Alloc-state rest))
                         :ruleset always-run)

                ; Lift Alloc when only state varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameAllocIgnoring-state exprs)
                       (> (ListExpr-length exprs) 1)
                       ; Bind non-varying field(s)
                       (= list (Cons (Alloc _id _e e1 _ty) rest)))
                      ((union (Switch pred exprs)
                              (Alloc _id _e (Switch pred (Map-Alloc-state exprs)) _ty)))
                      :ruleset conditional-invariant-code-motion)
                
                (rewrite (If c (Alloc _id _e e1 _ty) (Alloc _id _e e2 _ty))
                         (Alloc _id _e (If c e1 e2) _ty)
                         :when ((ExprIsValid (If c (Alloc _id _e e1 _ty) (Alloc _id _e e2 _ty))))
                         :ruleset conditional-invariant-code-motion)
; This file provides AddContext, a helpers that copies a sub-egraph into
; a new one with a new context.
; Users of AddContext can specify how deeply to do this copy.
; However, these rules do not recursivly add new InIf contexts as they go,
; since these can blow up exponentially. 


(ruleset context)
(ruleset context-helpers)

;; ################################ datatypes
;; A context path is a list of (DoAddContext ... (DoWhile ...)) nodes that we have already visited.
;; In substitution, the path is used to store every loop eclass we have visited, 
;; and the corresponding expression at that point.
;; When we visit an eclass for the second time, we have found a cycle in the egraph.
;; Then the corresponding contexts are made equivalent.
(datatype ContextPath
  (PathNil)
  (PathCons Expr ContextPath))


;; For every path P in the database,
;; we add a (Path-contains P S)
;; for every subpath S with the same endpoint.
;; We also include the empty path.
;; Ex: for path P = (PathCons a (PathCons b (PathCons c (PathNil))))
;; we have (Path-contains P P),
;; (Path-contains P (PathCons b (PathCons c (PathNil)))),
;; (Path-contains P (PathCons c (PathNil))),
;; and (Path-contains P (PathNil)).
(relation Path-contains (ContextPath ContextPath))

(rule ((= lhs (PathCons hd1 tl)))
      ((Path-contains lhs lhs))
      :ruleset context-helpers)
(rule ((Path-contains top (PathCons hd1 tl)))
      ((Path-contains top tl))
      :ruleset context-helpers)


(datatype ContextDepth
  ;; Make new InLoop contexts for the full reachable subgraph
  (Full)
  ;; Don't make new contexts for sub-loops
  (StopAtLoop))
(Full)
(StopAtLoop)

;; AddFuncContext is a helper for tests, it adds full context to everything in a function.
(function AddFuncContext (Expr) Expr :unextractable)
(function AddContext (Assumption ContextDepth Expr) Expr :unextractable)
(function DoAddContext (ContextPath Assumption ContextDepth Expr) Expr :unextractable)
(function DoAddContextList (ContextPath Assumption ContextDepth ListExpr) ListExpr :unextractable)

;; ###################### sugar


;; desugar add func context
(rule ((= lhs (AddFuncContext (Function name inty outty body))))
      ((union lhs
         (Function name inty outty
           (AddContext (NoContext) (Full) body))))
       :ruleset context-helpers)


;; AddContext is sugar for DoAddContext
(rewrite (AddContext ctx depth expr)
         (DoAddContext (PathNil) ctx depth expr)
         :ruleset context-helpers)

;; ################################### error detection

(rule ((DoAddContext path (InIf b pred) depth expr))
      ((panic "InIf context not allowed in AddContext. Only InLoop is allowed."))
      :ruleset context-helpers)


;; ################################ saturation

;; Adding context a second time does nothing, so union
(rule
  ((= lhs (DoAddContext seen ctx (Full) inner))
   (= inner (DoAddContext seen2 ctx (Full) expr)))
  ((union lhs inner))
  :ruleset context-helpers)


;; key rule that detects cycles
;; It finds that we have already seen the eclass we are adding context to.
;; The corresponding eclasses are unioned, and the cyclic
;; substitution is subsumed to ensure saturation.
(rule ((= lhs (DoAddContext seen ctx scope in))
       (Path-contains seen
         (PathCons original rest))
       (= original (DoAddContext oldseen oldctx oldscope in))
       )
      (;; contexts are equal
       (union ctx oldctx)
       ;; therefore adding context the first time is also equal to this time
       (union lhs original)
       ;; subsume the one with a cycle in the path
       (subsume (DoAddContext seen ctx scope in)))
      :ruleset context-helpers)

(rewrite (InContext (NoContext) expr)
         expr
         :ruleset context-helpers)


;; ############################################### Existing contexts


;; Replace existing InLoop contexts.
;; This relies on the fact that new contexts for DoAddContext 
;; must be more specific than old ones.
(rewrite (DoAddContext seen ctx scope
            (InContext (InLoop oldpred oldbody)  expr))
         (DoAddContext seen ctx scope expr)
         :ruleset context)

(rewrite (DoAddContext seen ctx scope
            (InContext (InIf b pred) expr))
         (InContext
           (InIf b (DoAddContext seen ctx scope pred))
           (DoAddContext seen ctx scope expr))
          :ruleset context)


;; ############################## Base cases- leaf nodes

(rewrite (DoAddContext seen ctx scope (Arg ty))
         (InContext ctx (Arg ty))
         :ruleset context)

(rewrite (DoAddContext seen ctx scope (Const constant ty))
         (InContext ctx (Const constant ty))
         :ruleset context)

(rewrite (DoAddContext seen ctx scope (Empty ty))
         (InContext ctx (Empty ty))
         :ruleset context)




;; ######################################### Operators


(rewrite (DoAddContext seen ctx scope (Bop op c1 c2))
         (Bop op
           (DoAddContext seen ctx scope c1)
           (DoAddContext seen ctx scope c2))
               :ruleset context)
(rewrite (DoAddContext seen ctx scope (Uop op c1))
         (Uop op (DoAddContext seen ctx scope c1))
         :ruleset context)
(rewrite (DoAddContext seen ctx scope (Get c1 index))
         (Get (DoAddContext seen ctx scope c1) index)
               :ruleset context)
(rewrite (DoAddContext seen ctx scope (Alloc id c1 state ty))
         (Alloc id (DoAddContext seen ctx scope c1) (DoAddContext seen ctx scope state) ty)
         :ruleset context)
(rewrite (DoAddContext seen ctx scope (Call name c1))
         (Call name (DoAddContext seen ctx scope c1))
         :ruleset context)

(rewrite (DoAddContext seen ctx scope (Single c1))
         (Single (DoAddContext seen ctx scope c1))
         :ruleset context)
(rewrite (DoAddContext seen ctx scope (Concat c1 c2))
         (Concat
           (DoAddContext seen ctx scope c1)
           (DoAddContext seen ctx scope c2))
         :ruleset context)

;; ################################### List operators

(rewrite (DoAddContextList seen ctx scope (Nil))
         (Nil)
         :ruleset context)

(rewrite (DoAddContextList seen ctx scope (Cons c1 rest))
         (Cons (DoAddContext seen ctx scope c1)
               (DoAddContextList seen ctx scope rest))
               :ruleset context)


;; ########################################## Control flow
(rewrite (DoAddContext seen ctx scope (Switch pred branches))
         (Switch (DoAddContext seen ctx scope pred)
                 (DoAddContextList seen ctx scope branches))
         :ruleset context)


;; don't generate new context for if nodes
(rule ((= lhs (DoAddContext seen ctx scope (If pred c1 c2))))
      ((If
         (DoAddContext seen ctx scope pred)
         (DoAddContext seen ctx scope c1)
         (DoAddContext seen ctx scope c2)))
       :ruleset context)


;; full context adds context to sub-loops
(rule ((= lhs (DoAddContext seen ctx scope (DoWhile inputs outputs)))
       (= scope (Full)))
      ((let new-inputs
         (DoAddContext seen ctx scope inputs))
       (let newpath
         (PathCons lhs seen))
       (union lhs
         (DoWhile new-inputs
           (DoAddContext newpath (InLoop new-inputs outputs) scope outputs))))
       :ruleset context)


;; For stop at loop, still add context to inputs
(rule ((= lhs (DoAddContext seen ctx scope (DoWhile inputs outputs)))
       (= scope (StopAtLoop)))
      ((DoWhile
          (DoAddContext seen ctx scope inputs)
          outputs))
       :ruleset context)


;; Besides the in_context rules that add fresh contexts to everything,
;; we normalize terms by pushing loop and func contexts to leaf nodes.
;; Pushing InIf contexts down to leaves causes exponential blowup, so we avoid this.
 
(ruleset context-prop)

;; A leaf context is either a InLoop or a NoContext.
;; We maintain the invariant that there is only one such context per region, and it can be pushed down to
;; leaf nodes.
(relation ScopeContext (Assumption))
(rule ((InLoop pred body))
      ((ScopeContext (InLoop pred body)))
      :ruleset context-prop)
(rule ((NoContext))
      ((ScopeContext (NoContext)))
      :ruleset context-prop)

(rewrite (InContext ctx (Top op a b c))
         (Top op (InContext ctx a) (InContext ctx b) (InContext ctx c))
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (Bop op a b))
         (Bop op (InContext ctx a) (InContext ctx b))
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (Uop op a))
         (Uop op (InContext ctx a))
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (Get expr ith))
         (Get (InContext ctx expr) ith)
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (Alloc i amount state_edge ty))
         (Alloc i (InContext ctx amount) (InContext ctx state_edge) ty)
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (Call name arg))
         (Call name (InContext ctx arg))
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (Single expr))
         (Single (InContext ctx expr))
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (Concat e1 e2))
         (Concat (InContext ctx e1) (InContext ctx e2))
         :when ((ScopeContext ctx))
         :ruleset context-prop)

(rewrite (InContext ctx (If cond then else))
         (If (InContext ctx cond) (InContext ctx then) (InContext ctx else))
         :when ((ScopeContext ctx))
         :ruleset context-prop)


;; don't add context to body, since it's a new region
(rewrite (InContext ctx (DoWhile inputs body))
         (DoWhile (InContext ctx inputs) body)
         :when ((ScopeContext ctx))
         :ruleset context-prop)


;; Substitution rules allow for substituting some new expression for the argument
;; in some new context.
;; It performs the substitution, copying over the equalities from the original eclass.
;; It only places context on the leaf nodes.

(ruleset subst)

;; (Subst assumption to in) substitutes to for `(Arg ty)` in `in`.
;; It also replaces any contexts found by updating them to `assumption`.
;; `assumption` *justifies* this substitution, as the context that the result is used in.
;; In other words, it must refine the equivalence relation of `in` with `to` as the argument.
(function Subst (Assumption Expr Expr) Expr :unextractable)
;; (SubstLeaf to in) substitutes `to` for `in` in a leaf node `in`
;; SubstLeaf assumes context has already been added
(function SubstLeaf (Expr Expr) Expr :unextractable)
(function SubstList (Assumption Expr ListExpr) ListExpr :unextractable)


;; Base case- leaf nodes
;; leaf node without context
(rule ((= lhs (Subst assum to leaf))
       (IsLeaf leaf))
      ((union lhs (InContext assum (SubstLeaf to leaf))))
      :ruleset subst)
;; leaf node with loop context
(rule ((= lhs (Subst assum to (InContext (InLoop inputs body) leaf)))
       (IsLeaf leaf))
      ((union lhs (InContext assum (SubstLeaf to leaf))))
      :ruleset subst)

;; modify inif context, doesn't need to be on a leaf
(rule ((= lhs (Subst assum to (InContext (InIf branch pred) expr))))
      ((union lhs
        (InContext
          (InIf branch (Subst assum to pred))
          (Subst assum to expr))))
      :ruleset subst)


;; substitute for a leaf node- interested case is (Arg ty)
(rewrite (SubstLeaf to (Arg ty))
         to
         :ruleset subst)
(rewrite (SubstLeaf to (Const constant ty))
         (Const constant ty2)
         :when ((HasArgType to ty2))
         :ruleset subst)
(rewrite (SubstLeaf to (Empty ty))
         (Empty ty2)
         :when ((HasArgType to ty2))
          :ruleset subst)


;; Operators
(rewrite (Subst assum to (Bop op c1 c2))
         (Bop op (Subst assum to c1)
                 (Subst assum to c2))
         :ruleset subst)
(rewrite (Subst assum to (Uop op c1))
         (Uop op (Subst assum to c1))
         :ruleset subst)
(rewrite (Subst assum to (Get c1 index))
         (Get (Subst assum to c1) index)
         :ruleset subst)
(rewrite (Subst assum to (Alloc id c1 state ty))
         (Alloc id (Subst assum to c1) (Subst assum to state) ty)
         :ruleset subst)
(rewrite (Subst assum to (Call name c1))
         (Call name (Subst assum to c1))
         :ruleset subst)


;; Tuple operators
(rewrite (Subst assum to (Single c1))
         (Single (Subst assum to c1))
         :ruleset subst)
(rewrite (Subst assum to (Concat c1 c2))
         (Concat (Subst assum to c1) (Subst assum to c2))
         :ruleset subst)


;; Control flow
(rewrite (Subst assum to (Switch pred branches))
         (Switch (Subst assum to pred)
                 (SubstList assum to branches))
         :ruleset subst)
(rewrite (Subst assum to (If pred c1 c2))
         (If (Subst assum to pred)
             (Subst assum to c1)
             (Subst assum to c2))
         :ruleset subst)
(rewrite (Subst assum to (DoWhile in out))
         (DoWhile (Subst assum to in)
                  out)
         :ruleset subst)

;; List operators
(rewrite (SubstList assum to (Cons c1 c2))
         (Cons (Subst assum to c1)
               (SubstList assum to c2))
         :ruleset subst)
(rewrite (SubstList assum to (Nil))
         (Nil)
         :ruleset subst)

;; substitute into function (convenience)
(rewrite (Subst assum to (Function name inty outty body))
         (Function name inty outty (Subst assum to body))
         :ruleset subst)
; We only have context for Exprs, not ListExprs.
(relation ContextOf (Expr Assumption))

; Base case: InContext means ContextOf
(rule ((InContext ctx e))
    ((ContextOf (InContext ctx e) ctx)) :ruleset always-run)

; Error checking - each expr should only have a single context
; TODO: this may not be true
; (rule ((ContextOf x ctx1)
;         (ContextOf x ctx2)
;         (!= ctx1 ctx2))
;     (
;         (panic "Equivalent expressions have nonequivalent context")
;     )
;     :ruleset error-checking)


(rule ((Top op x y z) (ContextOf x ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf y ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Top op x y z) (ContextOf z ctx))
    ((ContextOf (Top op x y z) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf x ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Bop op x y) (ContextOf y ctx))
    ((ContextOf (Bop op x y) ctx)) :ruleset always-run)

(rule ((Uop op x) (ContextOf x ctx))
    ((ContextOf (Uop op x) ctx)) :ruleset always-run)

(rule ((Get tup i) (ContextOf tup ctx))
    ((ContextOf (Get tup i) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf x ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Concat x y) (ContextOf y ctx))
    ((ContextOf (Concat x y) ctx)) :ruleset always-run)

(rule ((Single x) (ContextOf x ctx))
    ((ContextOf (Single x) ctx)) :ruleset always-run)

(rule ((Switch pred branches) (ContextOf pred ctx))
    ((ContextOf (Switch pred branches) ctx)) :ruleset always-run)

(rule ((If pred then else) (ContextOf pred ctx))
    ((ContextOf (If pred then else) ctx)) :ruleset always-run) 

(rule ((DoWhile in pred-and-output) (ContextOf in ctx))
    ((ContextOf (DoWhile in pred-and-output) ctx)) :ruleset always-run)

(rule ((Call func arg) (ContextOf arg ctx))
    ((ContextOf (Call func arg) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf e ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(rule ((Alloc amt e state ty) (ContextOf state ctx))
    ((ContextOf (Alloc amt e state ty) ctx)) :ruleset always-run)

(ruleset switch_rewrite)

(rewrite (If (Bop (And) a b) X Y)
         (If a (If b X Y) Y)
         :when ((ExprIsPure b))
         :ruleset switch_rewrite)

(rewrite (If (Bop (Or) a b) X Y)
         (If a X (If b X Y)) 
         :when ((ExprIsPure b))
         :ruleset switch_rewrite)

(rewrite (If (Const (Bool true) ty) thn els)
         thn
         :ruleset switch_rewrite)

(rewrite (If (Const (Bool false) ty) thn els)
         els
         :ruleset switch_rewrite)


;; Loop Invariant

;; bool: whether the term in the Expr is an invariant.
(function is-inv-Expr (Expr Expr) bool :unextractable :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :unextractable :merge (or old new))

;; in default, when there is a find, set is-inv to false
(rule ((BodyContainsExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((BodyContainsListExpr loop term)
       (= loop (DoWhile inputs pred_out)))
      ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((BodyContainsListExpr loop list) 
       (= loop (DoWhile inputs pred_out))) 
      ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)


(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Const _n _ty))) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get (Arg ty) i)) 
       (= loop (DoWhile in pred_out))
       (= expr (Get pred_out (+ i 1)))) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Function _name _tyin _tyout _out))  
       (= true (is-inv-Expr loop _out)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Top _op _x _y _z))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) (= true (is-inv-Expr loop _z)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Bop _op _x _y)) (BinaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Uop _op _x)) (UnaryOpIsPure _op) 
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Get _tup _i))  
       (= true (is-inv-Expr loop _tup)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Concat _x _y))  
       (= true (is-inv-Expr loop _x)) (= true (is-inv-Expr loop _y)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Single _x))  
       (= true (is-inv-Expr loop _x)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Switch _pred _branches))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-ListExpr loop _branches)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (If _pred _then _else))  
       (= true (is-inv-Expr loop _pred)) (= true (is-inv-Expr loop _then)) (= true (is-inv-Expr loop _else)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (DoWhile _in _pred-and-output))  
       (= true (is-inv-Expr loop _in)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Call _func _arg))  
       (= true (is-inv-Expr loop _arg)) 
       (ExprIsPure expr)) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (Empty _ty))  
        
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)

(rule ((BodyContainsExpr loop expr) 
       (= loop (DoWhile in out)) 
       (= expr (InContext _assumption _e))  
       (= true (is-inv-Expr loop _e)) 
       ) 
      ((set (is-inv-Expr loop expr) true)) :ruleset always-run)
;; Some simple simplifications of loops
(ruleset loop-simplify)

(rewrite
 (DoWhile (Arg ty)
  (Concat (Single (Const (Bool false) ty))
    (Single (Const constant ty))))
 (Single (Const constant ty))
 :ruleset loop-simplify)
;; Loop Splitting
(ruleset loop-splitting)

; i = a
; do while i < c:
;     if i <= b:
;         if_else
;     else:
;         if_else
;     i += 1
; ----------------------
; i = a
; do while i < b:
;     if_else
;     i += 1
; if i < c:
;     do while i < c:
;         if_else
;         i += 1

(rule ((= do_while (DoWhile inputs pred_and_body))
       (HasArgType do_while do_while_arg_type)

       (= a (Get inputs 1))
       (= 2 (tuple-length inputs))

       (= i (Get (Arg inner_arg_type) 1))
       (= one (Const (Int 1) inner_arg_type))

       (= loop_pred (Get pred_and_body 0))
       (= if_node (Get pred_and_body 1))
       (= i_plus_one (Get pred_and_body 2))
       (= 3 (tuple-length pred_and_body))

       (= loop_pred (Bop (LessThan) i c))
       (= i_plus_one (Bop (Add) i one))
       (= if_node (If if_pred if_then if_else))
       (= if_pred (Bop (LessEq) i b))

       (= (ival a) (IntI a1 a2))
       (= (ival b) (IntI b1 b2))
       (= (ival c) (IntI c1 c2))
       (< a2 b1)
       (<= b2 c1)

       (= b (Const b_const inner_arg_type))
       (= c (Const c_const inner_arg_type)))

      ((let a_to_b (DoWhile inputs (Concat
            (Single (Bop (LessThan) i b))
            (Concat
                (Single if_then)
                (Single i_plus_one)
            )
        )))
       (let b_to_c (DoWhile a_to_b (Concat
            (Single (Bop (LessThan) i c))
            (Concat
                (Single if_else)
                (Single i_plus_one)
            )
        )))

       (let b_to_c_if (If
            (Bop (LessThan) (Const b_const do_while_arg_type) (Const c_const do_while_arg_type))
            b_to_c
            a_to_b))

       (union do_while b_to_c_if))

      :ruleset loop-splitting)
;; Pass through thetas
(rule ((= lhs (Get loop i))
       (= loop (DoWhile inputs pred-outputs))
       (= (Get pred-outputs (+ i 1)) (Get (Arg _) i))
       (= passed-through (Get inputs i)))
      ((union lhs passed-through))
      :ruleset always-run)

;; Pass through switch arguments
(rule ((= lhs (Get switch i))
       (= switch (Switch pred branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) passed-through)
       (= (Get branch1 i) passed-through))
      ((union lhs passed-through))
      :ruleset always-run)

;; Pass through switch predicate
(rule ((= lhs (Get switch i))
       (= switch (Switch pred branches))
       (= (ListExpr-length branches) 2)
       (= branch0 (ListExpr-ith branches 0))
       (= branch1 (ListExpr-ith branches 1))
       (= (Get branch0 i) (Const (Bool false) _))
       (= (Get branch1 i) (Const (Bool true) _)))
      ((union lhs pred))
      :ruleset always-run)

;; Pass through if arguments
(rule ((= lhs (Get if i))
       (= if (If pred then_ else_))
       (= (Get else_ i) passed-through)
       (= (Get then_ i) passed-through))
      ((union lhs passed-through))
      :ruleset always-run)

;; Pass through if predicate
(rule ((= lhs (Get if i))
       (= if (If pred then_ else_))
       (= (Get else_ i) (Const (Bool false) _))
       (= (Get then_ i) (Const (Bool true) _)))
      ((union lhs pred))
      :ruleset always-run)

(let __tmp0 (StateT ))
(let __tmp1 (TNil ))
(let __tmp2 (TCons __tmp0 __tmp1))
(let __tmp3 (TupleT __tmp2))
(let __tmp4 (Print ))
(let __tmp5 (NoContext ))
(let __tmp6 (Arg __tmp3))
(let __tmp7 (InContext __tmp5 __tmp6))
(let __tmp8 (Get __tmp7 0))
(let __tmp9 (Single __tmp8))
(let __tmp10 (Int 6))
(let __tmp11 (Const __tmp10 __tmp3))
(let __tmp12 (InContext __tmp5 __tmp11))
(let __tmp13 (Single __tmp12))
(let __tmp14 (Concat __tmp9 __tmp13))
(let __tmp15 (LessEq ))
(let __tmp16 (IntT ))
(let __tmp17 (TCons __tmp16 __tmp1))
(let __tmp18 (TCons __tmp0 __tmp17))
(let __tmp19 (TupleT __tmp18))
(let __tmp20 (Arg __tmp19))
(let __tmp21 (Get __tmp20 1))
(let __tmp22 (Int 9))
(let __tmp23 (Const __tmp22 __tmp19))
(let __tmp24 (Bop __tmp15 __tmp21 __tmp23))
(let __tmp25 (Int 1))
(let __tmp26 (Const __tmp25 __tmp19))
(let __tmp27 (Get __tmp20 0))
(let __tmp28 (Bop __tmp4 __tmp26 __tmp27))
(let __tmp29 (Single __tmp28))
(let __tmp30 (Single __tmp21))
(let __tmp31 (LessThan ))
(let __tmp32 (Bop __tmp31 __tmp21 __tmp23))
(let __tmp33 (Single __tmp32))
(let __tmp34 (Concat __tmp30 __tmp33))
(let __tmp35 (Concat __tmp29 __tmp34))
(let __tmp36 (Int 2))
(let __tmp37 (Const __tmp36 __tmp19))
(let __tmp38 (Bop __tmp4 __tmp37 __tmp27))
(let __tmp39 (Single __tmp38))
(let __tmp40 (Concat __tmp39 __tmp34))
(let __tmp41 (If __tmp24 __tmp35 __tmp40))
(let __tmp42 (Get __tmp41 2))
(let __tmp43 (Get __tmp41 0))
(let __tmp44 (Single __tmp43))
(let __tmp45 (Add ))
(let __tmp46 (Get __tmp41 1))
(let __tmp47 (Bop __tmp45 __tmp46 __tmp26))
(let __tmp48 (Single __tmp47))
(let __tmp49 (Bool true))
(let __tmp50 (Const __tmp49 __tmp19))
(let __tmp51 (Single __tmp50))
(let __tmp52 (Concat __tmp48 __tmp51))
(let __tmp53 (Concat __tmp44 __tmp52))
(let __tmp54 (Bool false))
(let __tmp55 (Const __tmp54 __tmp19))
(let __tmp56 (Single __tmp55))
(let __tmp57 (Concat __tmp48 __tmp56))
(let __tmp58 (Concat __tmp44 __tmp57))
(let __tmp59 (If __tmp42 __tmp53 __tmp58))
(let __tmp60 (Get __tmp59 2))
(let __tmp61 (Single __tmp60))
(let __tmp62 (Get __tmp59 0))
(let __tmp63 (Single __tmp62))
(let __tmp64 (Get __tmp59 1))
(let __tmp65 (Single __tmp64))
(let __tmp66 (Concat __tmp63 __tmp65))
(let __tmp67 (Concat __tmp61 __tmp66))
(let __tmp68 (InLoop __tmp14 __tmp67))
(let __tmp69 (InContext __tmp68 __tmp20))
(let __tmp70 (Get __tmp69 1))
(let __tmp71 (InContext __tmp68 __tmp23))
(let __tmp72 (Bop __tmp15 __tmp70 __tmp71))
(let __tmp73 (InIf true __tmp72))
(let __tmp74 (InContext __tmp73 __tmp26))
(let __tmp75 (Get __tmp69 0))
(let __tmp76 (Bop __tmp4 __tmp74 __tmp75))
(let __tmp77 (Single __tmp76))
(let __tmp78 (Single __tmp70))
(let __tmp79 (Bop __tmp31 __tmp70 __tmp71))
(let __tmp80 (Single __tmp79))
(let __tmp81 (Concat __tmp78 __tmp80))
(let __tmp82 (Concat __tmp77 __tmp81))
(let __tmp83 (InIf false __tmp72))
(let __tmp84 (InContext __tmp83 __tmp37))
(let __tmp85 (Bop __tmp4 __tmp84 __tmp75))
(let __tmp86 (Single __tmp85))
(let __tmp87 (Concat __tmp86 __tmp81))
(let __tmp88 (If __tmp72 __tmp82 __tmp87))
(let __tmp89 (Get __tmp88 2))
(let __tmp90 (Get __tmp88 0))
(let __tmp91 (Single __tmp90))
(let __tmp92 (Get __tmp88 1))
(let __tmp93 (InContext __tmp68 __tmp26))
(let __tmp94 (Bop __tmp45 __tmp92 __tmp93))
(let __tmp95 (Single __tmp94))
(let __tmp96 (InIf true __tmp89))
(let __tmp97 (InContext __tmp96 __tmp50))
(let __tmp98 (Single __tmp97))
(let __tmp99 (Concat __tmp95 __tmp98))
(let __tmp100 (Concat __tmp91 __tmp99))
(let __tmp101 (InIf false __tmp89))
(let __tmp102 (InContext __tmp101 __tmp55))
(let __tmp103 (Single __tmp102))
(let __tmp104 (Concat __tmp95 __tmp103))
(let __tmp105 (Concat __tmp91 __tmp104))
(let __tmp106 (If __tmp89 __tmp100 __tmp105))
(let __tmp107 (Get __tmp106 2))
(let __tmp108 (Single __tmp107))
(let __tmp109 (Get __tmp106 0))
(let __tmp110 (Single __tmp109))
(let __tmp111 (Get __tmp106 1))
(let __tmp112 (Single __tmp111))
(let __tmp113 (Concat __tmp110 __tmp112))
(let __tmp114 (Concat __tmp108 __tmp113))
(let __tmp115 (DoWhile __tmp14 __tmp114))
(let __tmp116 (Get __tmp115 1))
(let __tmp117 (Get __tmp115 0))
(let __tmp118 (Bop __tmp4 __tmp116 __tmp117))
(let __tmp119 (Single __tmp118))
(let __tmp120 (Function "main" __tmp3 __tmp3 __tmp119))
(let __tmp121 (Nil ))
(let __tmp122 (Program __tmp120 __tmp121))
(let PROG __tmp122)

(run-schedule
  (repeat 6
    (saturate ;; saturate rulesets that we run to saturation
      (saturate always-run)
      (saturate error-checking)
      (saturate
        (saturate type-helpers)
        type-analysis
      )
      (saturate subst) ;; subst depends on type information for the argument
      (saturate interval-analysis)
      (saturate
        ;; make sure to saturate context-helpers, since they ensure the other rules saturate
        (saturate context-helpers)
        context
        context-prop))
    conditional-invariant-code-motion
    switch_rewrite
    loop-simplify
    loop-splitting
  )
)



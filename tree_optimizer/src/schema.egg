(datatype Expr)
(datatype ListExpr (Cons Expr ListExpr) (Nil))

(sort TypeList)

(datatype Type
  (IntT)
  (BoolT)
  (FuncT Type Type)
  (TupleT TypeList) ; Use a tuple of length 0 for a "unit" type
)

(function TNil () TypeList)
(function TCons (Type TypeList) TypeList)

; ==========================
; Operators that do not create regions
; ==========================
(datatype BinaryOp
  (Add)
  (Sub)
  (Mul)
  (LessThan)
  (And)
  (Or)
  (Write))
(datatype UnaryOp
  (Not)
  (Print))

; A Ctx defines an equality relation.
; All program leaves need to refer to a context to distinguish the equality relations.
; No term should mix two contexts that are not equal.
(datatype Ctx
  (Global) ; set of equalities between programs, assuming nothing
  ; Ctx is hard to add but easy to remove.
  ; We haven't decided what other Ctxs we may want to support. Here are two
  ; potential use cases:
  ; (Term)   ; set of only reflexive equalities between programs (e.g. a = a)
  ; (PathCondition Expr) ; set of equalities between programs, assuming the path condition on the argument
)

; Constants
(datatype Constant
  (Int i64)
  (Bool bool))
(function Const (Ctx Constant) Expr)

; Operators
(function Bop   (BinaryOp Expr Expr) Expr)
(function Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(function Get   (Expr i64) Expr)
; read has a type, so it can't be a bop
(function Read  (Expr Type)      Expr) 

; ==========================
; Tuple operations
; ==========================
(datatype Order (Parallel) (Sequential))

; Perform a list of operations. Only way to create a tuple!
; Needs a Ctx because the list may be empty.
; E.g. (All (Parallel) (Nil)) is a leaf, so it needs a Ctx.
(function All (Ctx Order ListExpr) Expr)

; Switch on a list of lazily-evaluated branches. Does not create a region.
; pred must be an integer
;                 pred     branches     chosen
(function Switch (Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred then else
(function If (Expr Expr Expr) Expr)


; ==========================
; Regions
; ==========================

; An `Input` marks a shared computation inside of a region (Loop or Let).
; Invariant: All inputs that are children of a region are equal.
; Invariant: (Input a) = (Input b) iff a = b.
; Invariant: An Input must have an enclosing region. An input cannot be
; a child of an input without a region constructor (Loop or Let) in-between.
; e.g. (Input (Add (Input 1) 2)) is invalid, since a new region was not created for the inner input.
; e.g. (Let (Input (Let (Input (Farg (IntT)))))) is valid.
; Don't union Inputs directly- they will be unioned via congruence.
(function Input (Expr) Expr)
; A function argument.
; In leaf regions, use `(Input (Farg some_type))` to refer to
; the function's inputs.
(function Farg (Type) Expr)



; Creates a region, allowing for a shared computation
; using `Input`. Evaluates the `input` first, then
; evaluates `output` on the result.
; 
;              output
(function Let (Expr) Expr)


; A do-while loop.
; `output` and `pred` are evaluated inside the loop,
; with the `output` evaluated first.
; `pred` must be a boolean, while `output` can have any type.
; 
;               output   pred
(function Loop (Expr     Expr)    Expr)

; ==========================
; Functions
; ==========================

; An entry function and a list of additional functions.
;                      entry function     other functions
(relation Program     (Expr               ListExpr))
;                   name   input ty  output ty  output
(function Function (String Type      Type       Expr)      Expr)

;               name of func  arg
(function Call (String        Expr) Expr)


; Rulesets
(ruleset always-run)
(ruleset error-checking)

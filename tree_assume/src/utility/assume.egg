; This file propogates assume nodes top-down from functions.
; It gives each program path a unique equality relation.
; This can be quite expensive, so be careful running these rules.

(ruleset assume)

(sort AssumeList)

; In order to saturate and not create unecessary contexts, we need to collapse
; duplicate assumptions.
; For example, the rewrite over `Function` could create many
; `(Assume (InFunc name) (Assume (InFunc name) ...))` nestings
(rewrite (Assume assumption (Assume assumption rest))
         (Assume assumption rest)
         :ruleset assume)

; ################### start top-down assumptions

(rewrite
 (Function name in_ty out_ty out)
 (Function name in_ty out_ty
   (Assume (InFunc  name)
               out))
 :ruleset assume)


; ################### operations
(rewrite (Assume asum (Bop op c1 c2))
         (Bop op (Assume asum c1) (Assume asum c2))
         :ruleset assume)
(rewrite (Assume assum (Uop op c1))
         (Uop op (Assume assum c1))
         :ruleset assume)
(rewrite (Assume assum (Get expr index))
         (Get (Assume assum expr) index)
         :ruleset assume)
(rewrite (Assume assum (Alloc expr ty))
         (Alloc (Assume assum expr) ty)
         :ruleset assume)
(rewrite (Assume assum (Call name expr))
         (Call name (Assume assum expr))
         :ruleset assume)

; ################### tuple operations
(rewrite (Assume assum (Single expr))
         (Single (Assume assum expr))
         :ruleset assume)
(rewrite (Assume assum (Concat order e1 e2))
         (Concat order (Assume assum e1) (Assume assum e2))
         :ruleset assume)

; #################### control flow

;                       assumptions, predicate, cases,   current case
(function SwitchAssume (AssumeList   Expr       ListExpr i64) ListExpr :unextractable) 

(rewrite (Assume assum (If pred then else))
         (If (Assume assum pred)
             (Assume
               (InIf true (Assume assum pred)) then)
             (Assume
               (InIf false (Assume assum pred)) else))
         :ruleset assume)

(rewrite (Assume assum (Let inputs body))
         (Let
           (Assume assum inputs)
           (Assume
             (InLet (Assume assum inputs))
             body))
          :ruleset assume)


(rule ((= lhs (Assume assum (DoWhile inputs pred_outputs))))
      ((union lhs
         (DoWhile
           (Assume assum inputs)
           (Assume
             (InLoop (Assume assum inputs) pred_outputs)
              pred_outputs))))
        :ruleset assume)
                   

(ruleset type-analysis)
(ruleset type-helpers)       ;; these rules need to saturate between every iter of type-analysis rules

(function TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-helpers)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-helpers)

(relation HasType (Expr Type))

;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))
(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; OKAY to compare types for equality because we never union types.
      )
      ((panic "type mismatch, better error message later :(")) ; once egglog allows non-literal panics
      :ruleset type-analysis)

(relation HasArgType (Expr Type))

(rule ((HasArgType e t1) (HasArgType e t2) (!= t1 t2))
      ((panic "arg type mismatch"))
      :ruleset type-analysis)

; Pushing expected arg types down
(rule ((HasArgType (Uop _ e) ty)) ((HasArgType e ty)) :ruleset type-analysis)
(rule ((HasArgType (Bop _ e1 e2) ty))
      (
        (HasArgType e1 ty)
        (HasArgType e2 ty)
      )
      :ruleset type-analysis)
(rule ((HasArgType (Get e _) ty)) ((HasArgType e ty)) :ruleset type-analysis)
(rule ((HasArgType (Alloc e _) ty)) ((HasArgType e ty)) :ruleset type-analysis)
(rule ((HasArgType (Call _ e) ty)) ((HasArgType e ty)) :ruleset type-analysis)
(rule ((HasArgType (Single e) ty)) ((HasArgType e ty)) :ruleset type-analysis)
(rule ((HasArgType (Concat _ e1 e2) ty))
      (
        (HasArgType e1 ty)
        (HasArgType e2 ty)
      )
      :ruleset type-analysis)
(rule ((HasArgType (Switch pred (Cons branch (Nil))) ty))
      (
        (HasArgType pred ty)
        (HasArgType branch ty)
      )
      :ruleset type-analysis)
(rule ((HasArgType (Switch pred (Cons branch rest)) ty))
      ((HasArgType (Switch pred rest) ty))
      :ruleset type-analysis)
(rule ((HasArgType (If c t e) ty))
      (
        (HasArgType c ty)
        (HasArgType t ty)
        (HasArgType e ty)
      )
      :ruleset type-analysis)
; Don't push arg types through Program, Function, DoWhile, Let exprs because
; these create new arg contexts.

; Primitives
(rule ((= lhs (Const (Int i))))
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b))))
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)

(rule ((= lhs (Empty)))
      ((HasType lhs (TupleT (TNil))))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not) expected bool, received {?}"))
      :ruleset type-analysis)


(rule (
        (= lhs (Uop (Print) e))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (TupleT (TNil))))
      :ruleset type-analysis)

(rule (
        (= lhs (Uop (Print) e))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset type-analysis)


(rule (
        (= lhs (Uop (Load) e))
        (HasType e (PointerT ty))
      )
      ((HasType lhs (Base ty)))
      :ruleset type-analysis)
(rule (
        (= lhs (Uop (Load) e))
        (HasType e ty)
        (= ty (Base x))
      )
      ((panic "(Load) expected pointer, received base"))
      :ruleset type-analysis)
(rule (
        (= lhs (Uop (Load) e))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset type-analysis)

; Binary ops
(rule (
        (= lhs (Bop (Add) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Add) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Add) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Add) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (Sub) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Sub) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Sub) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Sub) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (Mul) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Mul) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Mul) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Mul) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (LessThan) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (LessThan) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(LessThan) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(LessThan) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (And) e1 e2))
        (HasType e1 (Base (BoolT)))
        (HasType e2 (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (And) e1 e2)))
      (
        (ExpectType e1 (Base (BoolT)) "(And) expected bool, received {?}")
        (ExpectType e2 (Base (BoolT)) "(And) expected bool, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Or) e1 e2))
        (HasType e1 (Base (BoolT)))
        (HasType e2 (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Or) e1 e2)))
      (
        (ExpectType e1 (Base (BoolT)) "(Or) expected bool, received {?}")
        (ExpectType e2 (Base (BoolT)) "(Or) expected bool, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Write) ptr val))
        (HasType ptr (PointerT ty))
        (HasType val (Base t)) ; must be BaseType??
      )
      ((HasType lhs (TupleT (TNil)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (PointerT ty))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (TupleT (TNil)))) ; Returns () ??
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc amt ty))) 
      ((ExpectType amt (Base (IntT)) "(Alloc) expected int, got {?}"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc amt (Base ty)))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (PointerT ty)))
      :ruleset type-analysis)

(rule (
        (= lhs (Get e 0))     ; TODO: Generalize
        (HasType e (TupleT (TCons ty rest)))
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset type-analysis)

(rule (
        (= lhs (Single e))
        (HasType e ty)
      )
      ((HasType lhs (TupleT (TCons ty (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat ord e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)

; =================================
; Control flow
; =================================
(rule ((= lhs (If pred then else)))
      ((ExpectType pred (Base (BoolT)) "If predicate must be boolean"))
      :ruleset type-analysis)
(rule (
        (= lhs (If pred then else))
        (HasType pred (Base (BoolT)))
        (HasType then ty)
        (HasType else ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (If pred then else))
        (HasType pred (Base (BoolT)))
        (HasType then tya)
        (HasType else tyb)
        (!= tya tyb)
      )
      ((panic "if branches had different types"))
      :ruleset type-analysis)



(rule ((= lhs (Switch pred branches)))
      ((ExpectType pred (Base (IntT)) "Switch predicate must be integer"))
      :ruleset type-analysis)

; base case: single branch switch has type of branch
(rule (
        (= lhs (Switch pred (Cons branch (Nil))))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

; recursive case: peel off a layer
(rule ((Switch pred (Cons branch rest)))
      ((Switch pred rest))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch ty)
        (HasType (Switch pred rest) ty) ; rest of the branches also have type ty
      )
      ((HasType lhs ty))
      :ruleset type-analysis)

(rule (
        (= lhs (Switch pred (Cons branch rest)))
        (HasType pred (Base (IntT)))
        (HasType branch tya)
        (HasType (Switch pred rest) tyb)
        (!= tya tyb)
      )
      ((panic "switch branches had different types"))
      :ruleset type-analysis)

(rule (
        (= lhs (Let inp out))
        (HasType inp ty-in)
      )
      ((HasArgType out ty-in)) ; Track what type we expect the arg to have
      :ruleset type-analysis)

(rule (
        (= lhs (Let inp out))
        (HasType inp ty-in)
        (HasType out ty-out)
      )
      ((HasType lhs ty-out))
      :ruleset type-analysis)

(rule ((Arg ty))
      (
        (HasType (Arg ty) ty)
        (HasArgType (Arg ty) ty)
      )
      :ruleset type-analysis)


(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (Base ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset type-analysis)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (PointerT ty))
      )
      ((panic "loop input must be tuple"))
      :ruleset type-analysis)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (Base ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset type-analysis)
(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType pred-body (PointerT ty))
      )
      ((panic "loop pred-body must be tuple"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist))
      )
      ((HasArgType pred-body (TupleT tylist)))
      :ruleset type-analysis)

(rule ((= lhs (DoWhile inp pred-body)))
      ((ExpectType (Get pred-body 0) (Base (BoolT)) "loop pred must be bool"))
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT tylist)) ; input is a tuple
        ; pred-body is a tuple where the first elt is a bool
        ; and the rest of the list matches the input type
        (HasType pred-body (TupleT (TCons (Base (BoolT)) tylist)))
      )
      ((HasType lhs (TupleT tylist))) ; whole thing has type of inputs/outputs
      :ruleset type-analysis)

(rule (
        (= lhs (DoWhile inp pred-body))
        (HasType inp (TupleT in-tys))
        (HasType pred-body (TupleT (TCons (Base (BoolT)) out-tys)))
        (!= in-tys out-tys)
      )
      ((panic "input types and output types don't match"))
      :ruleset type-analysis)
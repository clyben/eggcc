(ruleset type-analysis)


(function TLConcat (TypeList TypeList) TypeList :unextractable)
(rewrite (TLConcat (TNil) r) r :ruleset type-analysis)
(rewrite (TLConcat (TCons hd tl) r)
         (TCons hd (TLConcat tl r))
         :ruleset type-analysis)

(relation HasType (Expr Type))

;; Keep track of type expectations for error messages
(relation ExpectType (Expr Type String))

(rule (
        (ExpectType e expected msg)
        (HasType e actual)
        (!= expected actual) ;; OKAY to compare types for equality because we never union types.
      )
      ((panic "type mismatch, better error message later :(")) ; once egglog allows non-literal panics
      :ruleset type-analysis)

; Primitives
(rule ((= lhs (Const (Int i))))
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)

(rule ((= lhs (Const (Bool b))))
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)

(rule ((= lhs (Empty)))
      ((HasType lhs (TupleT (TNil))))
      :ruleset type-analysis)

; Unary Ops
(rule (
        (= lhs (Uop (Not) e))
        (HasType e (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Uop (Not) e)))
      ((ExpectType e (Base (BoolT)) "(Not) expected bool, received {?}"))
      :ruleset type-analysis)


(rule (
        (= lhs (Uop (Print) e))
        (HasType e _ty)             ; just make sure it has some type.
      )
      ((HasType lhs (TupleT (TNil))))
      :ruleset type-analysis)

(rule (
        (= lhs (Uop (Print) e))
        (HasType e (TupleT ty))
      )
      ((panic "Don't print a tuple"))
      :ruleset type-analysis)


(rule (
        (= lhs (Uop (Load) e))
        (HasType e (PointerT ty))
      )
      ((HasType lhs (Base ty)))
      :ruleset type-analysis)
(rule (
        (= lhs (Uop (Load) e))
        (HasType e ty)
        (= ty (Base x))
      )
      ((panic "(Load) expected pointer, received base"))
      :ruleset type-analysis)
(rule (
        (= lhs (Uop (Load) e))
        (HasType e ty)
        (= ty (TupleT x))
      )
      ((panic "(Load) expected pointer, received tuple"))
      :ruleset type-analysis)

; Binary ops
(rule (
        (= lhs (Bop (Add) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Add) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Add) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Add) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (Sub) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Sub) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Sub) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Sub) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (Mul) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (IntT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Mul) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(Mul) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(Mul) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (LessThan) e1 e2))
        (HasType e1 (Base (IntT)))
        (HasType e2 (Base (IntT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (LessThan) e1 e2)))
      (
        (ExpectType e1 (Base (IntT)) "(LessThan) expected int, received {?}")
        (ExpectType e2 (Base (IntT)) "(LessThan) expected int, received {?}")
      )
      :ruleset type-analysis)  

(rule (
        (= lhs (Bop (And) e1 e2))
        (HasType e1 (Base (BoolT)))
        (HasType e2 (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (And) e1 e2)))
      (
        (ExpectType e1 (Base (BoolT)) "(And) expected bool, received {?}")
        (ExpectType e2 (Base (BoolT)) "(And) expected bool, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Or) e1 e2))
        (HasType e1 (Base (BoolT)))
        (HasType e2 (Base (BoolT)))
      )
      ((HasType lhs (Base (BoolT))))
      :ruleset type-analysis)
(rule ((= lhs (Bop (Or) e1 e2)))
      (
        (ExpectType e1 (Base (BoolT)) "(Or) expected bool, received {?}")
        (ExpectType e2 (Base (BoolT)) "(Or) expected bool, received {?}")
      )
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (Write) ptr val))
        (HasType ptr (PointerT ty))
        (HasType val (Base t)) ; must be BaseType??
      )
      ((HasType lhs (TupleT (TNil)))) ; Write returns ()
      :ruleset type-analysis)

(rule (
        (= lhs (Bop (PtrAdd) ptr n))
        (HasType ptr (PointerT ty))
        (HasType n (Base (IntT)))
      )
      ((HasType lhs (TupleT (TNil)))) ; Returns () ??
      :ruleset type-analysis)

; Other ops
(rule ((= lhs (Alloc amt ty))) 
      ((ExpectType amt (Base (IntT)) "(Alloc) expected int, got {?}"))
      :ruleset type-analysis)

(rule (
        (= lhs (Alloc amt (Base ty)))
        (HasType amt (Base (IntT)))
      )
      ((HasType lhs (PointerT ty)))
      :ruleset type-analysis)


; =================================
; Tuple operations
; =================================

(rule (
        (= lhs (Single e))
        (HasType e (TupleT tylist))
      )
      ((panic "don't nest tuples"))
      :ruleset type-analysis)

(rule (
        (= lhs (Single e))
        (HasType e ty)
      )
      ((HasType lhs (TupleT (TCons ty (TNil)))))
      :ruleset type-analysis)

(rule (
        (= lhs (Concat ord e1 e2))
        (HasType e1 (TupleT tylist1))
        (HasType e2 (TupleT tylist2))
      )
      ((HasType lhs (TupleT (TLConcat tylist1 tylist2))))
      :ruleset type-analysis)
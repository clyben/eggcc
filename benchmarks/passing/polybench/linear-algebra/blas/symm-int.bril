## symm computes matrix multiplication for a
## symmetric matrix.

@main {
    # constants
    # dimensions correspond to Polybench MEDIUM_DATASET

    M: int = const 200;
    fM: int = const 200;
    N: int = const 240;
    fN: int = const 240;

    one: int = const 1;
    fzero: int = const 0;

    # initialize arrays
    C: ptr<int> = call @matrix_new M N;
    A: ptr<int> = call @matrix_new M M;
    B: ptr<int> = call @matrix_new M N;
    alpha: int = const 3;
    beta: int = const 2;
    call @init C A B M fM N fN;

    # main computation

    i: int = const 0;
.main_i:
    cond: bool = lt i M;
    br cond .main_i_body .main_i_done;
.main_i_body:
    j: int = const 0;
.main_j:
    cond: bool = lt j N;
    br cond .main_j_body .main_j_done;
.main_j_body:
    temp2: int = const 0;
    k: int = const 0;
.main_k:
    cond: bool = lt k i;
    br cond .main_k_body .main_k_done;
.main_k_body:
    Bij: int = call @matrix_get B i j N;
    Aik: int = call @matrix_get A i k M;
    incr: int = mul alpha Bij;
    incr: int = mul incr Aik;
    call @matrix_incr C k j N incr;

    Bkj: int = call @matrix_get B k j N;
    Aik: int = call @matrix_get A i k M;
    incr: int = mul Bkj Aik;

    temp2: int = add temp2 incr;

    k: int = add k one;
    jmp .main_k;
.main_k_done:
    Cij: int = call @matrix_get C i j N;
    Bij: int = call @matrix_get B i j N;
    Aii: int = call @matrix_get A i i M;

    val1: int = mul beta Cij;
    val2: int = mul alpha Bij;

    val2: int = mul val2 Aii;
    val3: int = mul alpha temp2;

    val: int = add val1 val2;
    val: int = add val val3;
    call @matrix_set C i j N val;
    j: int = add j one;
    jmp .main_j;
.main_j_done:
    i: int = add i one;
    jmp .main_i;
.main_i_done:

    call @matrix_print C M N;

    free C;
    free A;
    free B;
}

@init(C: ptr<int>, A: ptr<int>, B: ptr<int>,
      M: int, fM: int, N: int, fN: int) {
    one: int = const 1;
    fone: int = const 1;
    hundred: int = const 100;
    invalid: int = const -999;

    i: int = const 0;
    fi: int = const 0;
.init_CB_i:
    cond: bool = lt i M;
    br cond .init_CB_i_body .init_CB_i_done;
.init_CB_i_body:
    j: int = const 0;
    fj: int = const 0;
.init_CB_j:
    cond: bool = lt j N;
    br cond .init_CB_j_body .init_CB_j_done;
.init_CB_j_body:
    val: int = add fi fj;
    val: int = call @fmod val hundred;
    val: int = div val fM;
    call @matrix_set C i j N val;

    val: int = add fN fi;
    val: int = sub val fj;
    val: int = call @fmod val hundred;
    val: int = div val fM;
    call @matrix_set B i j N val;

    j: int = add j one;
    fj: int = add fj fone;
    jmp .init_CB_j;
.init_CB_j_done:
    i: int = add i one;
    fi: int = add fi fone;
    jmp .init_CB_i;
.init_CB_i_done:

    i: int = const 0;
    fi: int = const 0;
.init_A_i:
    cond: bool = lt i M;
    br cond .init_A_i_body .init_A_i_done;
.init_A_i_body:
    j: int = const 0;
    fj: int = const 0;
.init_A_j1:
    cond: bool = le j i;
    br cond .init_A_j1_body .init_A_j1_done;
.init_A_j1_body:
    val: int = add fi fj;
    val: int = call @fmod val hundred;
    val: int = div val fM;
    call @matrix_set A i j M val;

    j: int = add j one;
    fj: int = add fj fone;
    jmp .init_A_j1;
.init_A_j1_done:
    j: int = add i one;
.init_A_j2:
    cond: bool = lt j M;
    br cond .init_A_j2_body .init_A_j2_done;
.init_A_j2_body:
    call @matrix_set A i j M invalid;
    j: int = add j one;
    jmp .init_A_j2;
.init_A_j2_done:
    i: int = add i one;
    fi: int = add fi fone;
    jmp .init_A_i;
.init_A_i_done:
}

@matrix_new(Nrow: int, Ncol: int): ptr<int> {
    total: int = mul Nrow Ncol;
    ptr: ptr<int> = alloc total;
    ret ptr;
}

@matrix_loc(mtx: ptr<int>, row: int, col: int, Ncol: int): ptr<int> {
    row_offset: int = mul row Ncol;
    offset: int = add row_offset col;
    new_ptr: ptr<int> = ptradd mtx offset;
    ret new_ptr;
}

# EXPECTS:
#   @matrix_loc defined
@matrix_get(mtx: ptr<int>, row: int, col: int, Ncol: int): int {
    ptr: ptr<int> = call @matrix_loc mtx row col Ncol;
    val: int = load ptr;
    ret val;
}

# EXPECTS:
#   @matrix_loc defined
@matrix_set(mtx: ptr<int>, row: int, col: int, Ncol: int, val: int) {
    ptr: ptr<int> = call @matrix_loc mtx row col Ncol;
    store ptr val;
}

# EXPECTS:
#   @matrix_loc defined
@matrix_incr(mtx: ptr<int>, row: int, col: int, Ncol: int, incr: int) {
    ptr: ptr<int> = call @matrix_loc mtx row col Ncol;
    val: int = load ptr;
    new_val: int = add val incr;
    store ptr new_val;
}

@matrix_print(mtx: ptr<int>, Nrow: int, Ncol: int) {
    i: int = const 0;
    one: int = const 1;
    total: int = mul Nrow Ncol;
.while:
    cond: bool = lt i total;
    br cond .body .done;
.body:
    mtx_loc: ptr<int> = ptradd mtx i;
    val: int = load mtx_loc;
    print val;
    i: int = add i one;
    jmp .while;
.done:
}

# Search for n % m where n and m are ints by
# iteratively subtracting the largest m*2^k that
# fits inside n. 
# Takes O((log n/m)^2) time.
# NOTE: In C, this can be done with a built in 
# function, but this is the best we can do.
@fmod(n: int, m: int): int {
    zero: int = const 0;
    two: int = const 2;
    rem: int = id n;
.while:
    cond: bool = ge rem m;
    br cond .body .done;
.body:
    decr: int = id m;
.while_inner:
    diff: int = sub rem decr;
    cond: bool = ge diff zero;
    br cond .body_inner .done_inner;
.body_inner:
    decr: int = mul decr two;
    jmp .while_inner;
.done_inner:
    decr: int = div decr two;
    rem: int = sub rem decr;
    jmp .while;
.done:
    ret rem;
}

## mvt computes a matrix vector product and transpose

@main {
    # constants
    # dimensions correspond to Polybench MEDIUM_DATASET

    N: int = const 400;
    fN: int = const 400;

    one: int = const 1;

    x1: ptr<int> = call @vector_new N;
    x2: ptr<int> = call @vector_new N;
    y_1: ptr<int> = call @vector_new N;
    y_2: ptr<int> = call @vector_new N;
    A: ptr<int> = call @matrix_new N N;

    call @init x1 x2 y_1 y_2 A N fN;

    i: int = const 0;
.part1_i:
    cond: bool = lt i N;
    br cond .part1_i_body .part1_i_done;
.part1_i_body:
    j: int = const 0;
.part1_j:
    cond: bool = lt j N;
    br cond .part1_j_body .part1_j_done;
.part1_j_body:
    x1i: int = call @vector_get x1 i;
    Aij: int = call @matrix_get A i j N;
    y_1j: int = call @vector_get y_1 j;
    val: int = mul Aij y_1j;
    val: int = add val x1i;
    call @vector_set x1 i val;
    j: int = add j one;
    jmp .part1_j;
.part1_j_done:
    i: int = add i one;
    jmp .part1_i;
.part1_i_done:

    i: int = const 0;
.part2_i:
    cond: bool = lt i N;
    br cond .part2_i_body .part2_i_done;
.part2_i_body:
    j: int = const 0;
.part2_j:
    cond: bool = lt j N;
    br cond .part2_j_body .part2_j_done;
.part2_j_body:
    x2i: int = call @vector_get x2 i;
    Aji: int = call @matrix_get A j i N;
    y_2j: int = call @vector_get y_2 j;
    val: int = mul Aji y_2j;
    val: int = add val x2i;
    call @vector_set x2 i val;
    j: int = add j one;
    jmp .part2_j;
.part2_j_done:
    i: int = add i one;
    jmp .part2_i;
.part2_i_done:

    call @vector_print x1 N;
    call @vector_print x2 N;

    free x1;
    free x2;
    free y_1;
    free y_2;
    free A;
}

@init(x1: ptr<int>, x2: ptr<int>, y_1: ptr<int>, y_2: ptr<int>, A: ptr<int>,
      N: int, fN: int) {
    one: int = const 1;
    fone: int = const 1;
    fthree: int = const 3;
    ffour: int = const 4;

    i: int = const 0;
    fi: int = const 0;
.init_i:
    cond: bool = lt i N;
    br cond .init_i_body .init_i_done;
.init_i_body:
    val: int = call @fmod fi fN;
    val: int = div val fN;
    call @vector_set x1 i val;

    val: int = add fi fone;
    val: int = call @fmod val fN;
    val: int = div val fN;
    call @vector_set x2 i val;

    val: int = add fi fthree;
    val: int = call @fmod val fN;
    val: int = div val fN;
    call @vector_set y_1 i val;

    val: int = add fi ffour;
    val: int = call @fmod val fN;
    val: int = div val fN;
    call @vector_set y_2 i val;

    j: int = const 0;
    fj: int = const 0;
.init_j:
    cond: bool = lt j N;
    br cond .init_j_body .init_j_done;
.init_j_body:
    val: int = mul fi fj;
    val: int = call @fmod val fN;
    val: int = div val fN;
    call @matrix_set A i j N val;

    j: int = add j one;
    fj: int = add fj fone;
    jmp .init_j;
.init_j_done:
    i: int = add i one;
    fi: int = add fi fone;
    jmp .init_i;
.init_i_done:
}

@vector_new(N: int): ptr<int> {
    ptr: ptr<int> = alloc N;
    ret ptr;
}

@vector_get(vec: ptr<int>, i: int): int {
    ptr: ptr<int> = ptradd vec i;
    val: int = load ptr;
    ret val;
}

@vector_set(vec: ptr<int>, i: int, val: int) {
    ptr: ptr<int> = ptradd vec i;
    store ptr val;
}

# EXPECTS:
#   @vector_get defined
@vector_print(vec: ptr<int>, N: int) {
    i: int = const 0;
    one: int = const 1;
.while:
    cond: bool = lt i N;
    br cond .body .done;
.body:
    val: int = call @vector_get vec i;
    print val;
    i: int = add i one;
    jmp .while;
.done:
}

@matrix_new(Nrow: int, Ncol: int): ptr<int> {
    total: int = mul Nrow Ncol;
    ptr: ptr<int> = alloc total;
    ret ptr;
}

@matrix_loc(mtx: ptr<int>, row: int, col: int, Ncol: int): ptr<int> {
    row_offset: int = mul row Ncol;
    offset: int = add row_offset col;
    new_ptr: ptr<int> = ptradd mtx offset;
    ret new_ptr;
}

# EXPECTS:
#   @matrix_loc defined
@matrix_get(mtx: ptr<int>, row: int, col: int, Ncol: int): int {
    ptr: ptr<int> = call @matrix_loc mtx row col Ncol;
    val: int = load ptr;
    ret val;
}

# EXPECTS:
#   @matrix_loc defined
@matrix_set(mtx: ptr<int>, row: int, col: int, Ncol: int, val: int) {
    ptr: ptr<int> = call @matrix_loc mtx row col Ncol;
    store ptr val;
}

# Search for n % m where n and m are ints by
# iteratively subtracting the largest m*2^k that
# fits inside n. 
# Takes O((log n/m)^2) time.
# NOTE: In C, this can be done with a built in 
# function, but this is the best we can do.
@fmod(n: int, m: int): int {
    zero: int = const 0;
    two: int = const 2;
    rem: int = id n;
.while:
    cond: bool = ge rem m;
    br cond .body .done;
.body:
    decr: int = id m;
.while_inner:
    diff: int = sub rem decr;
    cond: bool = ge diff zero;
    br cond .body_inner .done_inner;
.body_inner:
    decr: int = mul decr two;
    jmp .while_inner;
.done_inner:
    decr: int = div decr two;
    rem: int = sub rem decr;
    jmp .while;
.done:
    ret rem;
}
(datatype Literal)
(datatype Expr)
(datatype Operand)
(datatype Body)

(sort VecOperandBase (Vec Operand))
(datatype VecOperand (VO VecOperandBase))

(sort VecVecOperandBase (Vec VecOperand))
(datatype VecVecOperand (VVO VecVecOperandBase))

;; Type
(datatype Type
    (IntT)
    (BoolT)
    (FloatT)
    (CharT)
    (PointerT Type))
(datatype EffectType
    (Bril Type)
    (PrintState))
(sort FuncSigs (Vec EffectType))
(datatype OptionType
    (SomeType Type)
    (NoneType))
;; Literal
(function Num (i64) Literal)
(function Float (f64) Literal)
(function Char (String) Literal)
(function Bool (bool) Literal)

;; Expr
(datatype ConstOps (const))
(function Const (Type ConstOps Literal) Expr)
;; Call may return multiple values but at most one of them
;; is a value type, which is stored in OptionType.
;; The last fields denotes how many return values it have
;; Finally, we assume if call ever returns a value, 
;; it has to be the first one.
(function Call (OptionType String VecOperand i64) Expr :cost 1000) ; TODO: fix cost model
(function badd (Type Operand Operand) Expr)
(function bsub (Type Operand Operand) Expr)
(function bmul (Type Operand Operand) Expr :cost 1000)
(function bfmul (Type Operand Operand) Expr)
(function bdiv (Type Operand Operand) Expr)
(function beq (Type Operand Operand) Expr)
(function blt (Type Operand Operand) Expr)
(function bgt (Type Operand Operand) Expr)
(function ble (Type Operand Operand) Expr)
(function bge (Type Operand Operand) Expr)
(function bnot (Type Operand Operand) Expr)
(function band (Type Operand Operand) Expr)
(function bor (Type Operand Operand) Expr)
(function PRINT (Operand Operand) Expr)

;; Operand
(function Arg (i64) Operand)
(function Node (Body) Operand)
(function Project (i64 Body) Operand)

;; Body
(function PureOp (Expr) Body)
;; branching
;; predicate (outside switch), inputs (outside switch),
;; and for each branch a vector of outputs
(function Gamma (Operand VecOperand VecVecOperand) Body)
;; loops
;; predicate (inside loop), inputs (outside loop), outputs (inside loop)
(function Theta (Operand VecOperand VecOperand) Body)
;; A body can also just be a VecOperand for convenience
;; This has no corresponding node in rust, it can be
;; removed during translation
(function OperandGroup (VecOperand) Body)

(datatype Function
    ;;    name   input types    output types    body
    (Func String FuncSigs       FuncSigs        VecOperand))


;; procedure f(n):
;;   i = 0
;;   ans = 0
;;   do:
;;     ans += i*5;
;;     i += 1
;;   while(i < n);
;;   return ansm

;; ;; inputs: [n]
; (Project 0
;     (Theta
;        ;     i       n
;         (lt (Arg 1) (Arg 2)) ;; pred
;         (vec-of ;; inputs
;             (Node (PureOp (Const 0))) ;; accumulator
;             (Node (PureOp (Const 0))) ;; loop var
;             (Arg 0) ;; n
;             )
;         (vec-of ;; outputs
;             (Node (PureOp (add (Arg 0) ;; ans
;                 (Node (PureOp (mul 
;                     (Arg 1) ;; i
;                     (Node (PureOp (Const 5))))))))) ;; ans = i*5
;             (Node (PureOp (add (Arg 1) (Node (PureOp (Const 1)))))) ;; i += 1
;             (Arg 2) ;; n
;         ))
; )



;; Substitution
(ruleset subst)

;;                   e  [ x -> v ]
(function SubstExpr (Expr i64 Operand) Expr :unextractable)
(function SubstOperand (Operand i64 Operand) Operand :unextractable)
(function SubstBody (Body i64 Operand) Body :unextractable)
(function SubstVecOperand (VecOperand i64 Operand) VecOperand :unextractable)
(function SubstVecVecOperand (VecVecOperand i64 Operand) VecVecOperand :unextractable)

(rewrite (SubstExpr (Const ty ops lit) x v) (Const ty ops lit) :ruleset subst)
(rewrite (SubstExpr (Call ty f args n-outs) x v) (Call ty f (SubstVecOperand args x v) n-outs) :ruleset subst)
(rewrite (SubstExpr (badd ty a b) x v) (badd ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bsub ty a b) x v) (bsub ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bmul ty a b) x v) (bmul ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bdiv ty a b) x v) (bdiv ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (beq ty a b) x v) (beq ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (blt ty a b) x v) (blt ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bgt ty a b) x v) (bgt ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (ble ty a b) x v) (ble ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bge ty a b) x v) (bge ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bnot ty a b) x v) (bnot ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (band ty a b) x v) (band ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (bor ty a b) x v) (bor ty (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)
(rewrite (SubstExpr (PRINT a b) x v) (PRINT (SubstOperand a x v) (SubstOperand b x v)) :ruleset subst)

(rewrite (SubstOperand (Arg x) x v) v :ruleset subst)
(rule ((= f (SubstOperand (Arg y) x v)) (!= y x))
      ((union f (Arg y))) :ruleset subst)
(rewrite (SubstOperand (Node b) x v) (Node (SubstBody b x v)) :ruleset subst)
(rewrite (SubstOperand (Project i b) x v) (Project i (SubstBody b x v)) :ruleset subst)

(rewrite (SubstBody (PureOp e) x v) (PureOp (SubstExpr e x v)) :ruleset subst)
;; Subst doesn't cross regions - so we subst into the inputs but not outputs
;; Node that a Gamma node's idx is on the outside, so it gets affected, but not
;; a Theta node's predicate
(rewrite (SubstBody (Gamma pred inputs outputs) x v) (Gamma (SubstOperand pred x v) (SubstVecOperand inputs x v) outputs) :ruleset subst)
(rewrite (SubstBody (Theta pred inputs outputs) x v) (Theta pred (SubstVecOperand inputs x v) outputs) :ruleset subst)

;; params: vec, var, op, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecOperandHelper (VecOperand i64 Operand i64) VecOperand :unextractable)
(rewrite (SubstVecOperand vec x v) (SubstVecOperandHelper vec x v 0) :ruleset subst)
(rule
  (
    (= f (SubstVecOperandHelper (VO vec) x v i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (SubstVecOperandHelper (VO vec) x v i)
      (SubstVecOperandHelper
        (VO (vec-set vec i (SubstOperand (vec-get vec i) x v)))
        x v (+ i 1)
        ))
  ) :ruleset subst)

(rule
  (
    (= f (SubstVecOperandHelper (VO vec) x v i))
    (= i (vec-length vec))
  )
  ( 
    (union (SubstVecOperandHelper (VO vec) x v i) (VO vec))
  ) :ruleset subst)


;; params: vec, var, op, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecVecOperandHelper (VecVecOperand i64 Operand i64) VecVecOperand :unextractable)
(rewrite (SubstVecVecOperand vec x v) (SubstVecVecOperandHelper vec x v 0) :ruleset subst)
(rule
  (
    (= f (SubstVecVecOperandHelper (VVO vec) x v i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (SubstVecVecOperandHelper (VVO vec) x v i)
      (SubstVecVecOperandHelper
        (VVO (vec-set vec i (SubstVecOperand (vec-get vec i) x v)))
        x v (+ i 1)
        ))
  ) :ruleset subst)

(rule
  (
    (= f (SubstVecVecOperandHelper (VVO vec) x v i))
    (= i (vec-length vec))
  )
  ( 
    (union (SubstVecVecOperandHelper (VVO vec) x v i) (VVO vec))
  ) :ruleset subst)
 
;; SubstAll - Simultaneous substitutions
;;
;; Instead of substituting a particular argument for an operand, the "*All"
;; variants substitute (Arg i) for (vec-get v i) for a vector `v` passed in as the
;; first argument.

(function SubstExprAll          (VecOperand Expr)          Expr :unextractable)
(function SubstOperandAll       (VecOperand Operand)       Operand :unextractable)
(function SubstBodyAll          (VecOperand Body)          Body :unextractable)
(function SubstVecOperandAll    (VecOperand VecOperand)    VecOperand :unextractable)
(function SubstVecVecOperandAll (VecOperand VecVecOperand) VecVecOperand :unextractable)

(rewrite (SubstExprAll x (Const ty ops lit)) (Const ty ops lit) :ruleset subst)
(rewrite (SubstExprAll x (Call ty f args n-outs)) (Call ty f (SubstVecOperandAll x args) n-outs) :ruleset subst)
(rewrite (SubstExprAll x (badd ty a b)) (badd ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bsub ty a b)) (bsub ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bmul ty a b)) (bmul ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bdiv ty a b)) (bdiv ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (beq ty a b)) (beq ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (blt ty a b)) (blt ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bgt ty a b)) (bgt ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (ble ty a b)) (ble ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bge ty a b)) (bge ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bnot ty a b)) (bnot ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (band ty a b)) (band ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (bor ty a b)) (bor ty (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)
(rewrite (SubstExprAll x (PRINT a b)) (PRINT (SubstOperandAll x a) (SubstOperandAll x b)) :ruleset subst)

(rule ((= res (SubstOperandAll (VO ops) (Arg x)))
       (< x (vec-length ops)))
      ((union res (vec-get ops x))) :ruleset subst)
;; NB: unclear if this rule is needed      
(rule ((= res (SubstOperandAll (VO ops) (Arg x)))
       (>= x (vec-length ops)))
      ((union res (Arg x))) :ruleset subst)
(rewrite (SubstOperandAll x (Node b)) (Node (SubstBodyAll x b)) :ruleset subst)
(rewrite (SubstOperandAll x (Project i b)) (Project i (SubstBodyAll x b)) :ruleset subst)

(rewrite (SubstBodyAll x (PureOp e)) (PureOp (SubstExprAll x e)) :ruleset subst)
;; Subst doesn't cross regions - so we subst into the inputs but not outputs
;; Node that a Gamma node's idx is on the outside, so it gets affected, but not
;; a Theta node's predicate
(rewrite (SubstBodyAll x (Gamma pred inputs outputs)) 
  (Gamma (SubstOperandAll x pred) (SubstVecOperandAll x inputs) outputs) :ruleset subst)
(rewrite (SubstBodyAll x (Theta pred inputs outputs)) 
  (Theta pred (SubstVecOperandAll x inputs) outputs) :ruleset subst)

;; params: substs, vec, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecOperandAllHelper (VecOperand VecOperand i64) VecOperand :unextractable)
(rewrite (SubstVecOperandAll x vec) (SubstVecOperandAllHelper x vec 0) :ruleset subst)
(rule
  ((= f (SubstVecOperandAllHelper x (VO vec) i))
   (< i (vec-length vec)))
  ((union
     (SubstVecOperandAllHelper x (VO vec) i)
     (SubstVecOperandAllHelper
       x
       (VO (vec-set vec i (SubstOperandAll x (vec-get vec i))))
       (+ i 1)))) :ruleset subst)

(rule
  ((= f (SubstVecOperandAllHelper x (VO vec) i))
   (= i (vec-length vec)))
  ((union (SubstVecOperandAllHelper x (VO vec) i) (VO vec))) :ruleset subst)


;; params: substs, vec, next index to subst
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function SubstVecVecOperandAllHelper (VecOperand VecVecOperand i64) VecVecOperand :unextractable)
(rewrite (SubstVecVecOperandAll x vec) (SubstVecVecOperandAllHelper x vec 0) :ruleset subst)
(rule
  ((= f (SubstVecVecOperandAllHelper x (VVO vec) i))
   (< i (vec-length vec)))
  ((union
     (SubstVecVecOperandAllHelper x (VVO vec) i)
     (SubstVecVecOperandAllHelper
       x
       (VVO (vec-set vec i (SubstVecOperandAll x (vec-get vec i))))
       (+ i 1)))) :ruleset subst)

(rule
  ((= f (SubstVecVecOperandAllHelper x (VVO vec) i))
   (= i (vec-length vec)))
  ((union (SubstVecVecOperandAllHelper x (VVO vec) i) (VVO vec))) :ruleset subst)
 

        (relation can-subst-Expr-beneath (Body Expr Expr))
        (relation can-subst-Operand-beneath (Body Operand Operand))
        (relation can-subst-Body-beneath (Body Body Body))
        (relation can-subst-VecVecOperand-beneath (Body VecVecOperand VecVecOperand))
        (relation can-subst-VecOperand-beneath (Body VecOperand VecOperand))

        ;; Base case 'do the substitution' rules
        (rule ((can-subst-Operand-beneath above from to)
               (= above     (Theta from inputs outputs)))
              ((union above (Theta to   inputs outputs)))
              :ruleset subst)
        (rule ((can-subst-VecOperand-beneath above from to)
               (= above     (Theta pred inputs from)))
              ((union above (Theta pred inputs to)))
              :ruleset subst)
        (rule ((can-subst-Operand-beneath above pred-from pred-to)
               (can-subst-VecOperand-beneath above outputs-from outputs-to)
               (= above     (Theta pred-from inputs outputs-from)))
              ((union above (Theta pred-from inputs outputs-to)))
              :ruleset subst)
        (rule ((can-subst-VecVecOperand-beneath above from to)
               (= above     (Gamma pred inputs from)))
              ((union above (Gamma pred inputs to)))
              :ruleset subst)
        (rule ((can-subst-VecOperand-beneath above from to)
               (= above     (OperandGroup from)))
              ((union above (OperandGroup to)))
              :ruleset subst)

        ;; Learn can-subst-Operand-beneath
        (rule ((can-subst-Body-beneath above from to)
               (= new-from (Node from)))
              ((can-subst-Operand-beneath above new-from (Node to)))
              :ruleset subst)
        (rule ((can-subst-Body-beneath above from to)
               (= new-from (Project i from)))
              ((can-subst-Operand-beneath above new-from (Project i to)))
              :ruleset subst)

        ;; Learn can-subst-body-beneath
        (rule ((can-subst-Expr-beneath above from to)
               (= new-from (PureOp from)))
              ((can-subst-Body-beneath above new-from (PureOp to)))
              :ruleset subst)
        ;; Propagates up same context (Gamma: pred & inputs, Theta: inputs)
        ;; rtjoa: Is it sound to propagate up outputs if we renumber args?
        (rule ((can-subst-Operand-beneath above from to)
               (= new-from (Gamma from inputs outputs)))
              ((can-subst-Body-beneath above new-from (Gamma to inputs outputs)))
              :ruleset subst)
        (rule ((can-subst-VecOperand-beneath above from to)
               (= new-from (Gamma pred from outputs)))
              ((can-subst-Body-beneath above new-from (Gamma pred to outputs)))
              :ruleset subst)
        (rule ((can-subst-VecOperand-beneath above from to)
               (= new-from (Theta pred from outputs)))
              ((can-subst-Body-beneath above new-from (Theta pred to outputs)))
              :ruleset subst)
        (rule ((can-subst-VecOperand-beneath above from to)
               (= new-from (OperandGroup from)))
              ((can-subst-Body-beneath above new-from (OperandGroup to)))
              :ruleset subst)
        

      (rule ((can-subst-VecOperand-beneath above from to)
              (= new-from (Call ty f from n-outs)))
             ((can-subst-Expr-beneath above new-from (Call ty f to n-outs)))
            :ruleset subst)

              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (badd type from e2)))
                     ((can-subst-Expr-beneath above new-from (badd type to e2)))
                    :ruleset subst)
              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (badd type e1 from)))
                     ((can-subst-Expr-beneath above new-from (badd type e1 to)))
                    :ruleset subst)
                     

              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (bsub type from e2)))
                     ((can-subst-Expr-beneath above new-from (bsub type to e2)))
                    :ruleset subst)
              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (bsub type e1 from)))
                     ((can-subst-Expr-beneath above new-from (bsub type e1 to)))
                    :ruleset subst)
                     

              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (bmul type from e2)))
                     ((can-subst-Expr-beneath above new-from (bmul type to e2)))
                    :ruleset subst)
              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (bmul type e1 from)))
                     ((can-subst-Expr-beneath above new-from (bmul type e1 to)))
                    :ruleset subst)
                     

              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (bdiv type from e2)))
                     ((can-subst-Expr-beneath above new-from (bdiv type to e2)))
                    :ruleset subst)
              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (bdiv type e1 from)))
                     ((can-subst-Expr-beneath above new-from (bdiv type e1 to)))
                    :ruleset subst)
                     

              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (blt type from e2)))
                     ((can-subst-Expr-beneath above new-from (blt type to e2)))
                    :ruleset subst)
              (rule ((can-subst-Operand-beneath above from to)
                      (= new-from (blt type e1 from)))
                     ((can-subst-Expr-beneath above new-from (blt type e1 to)))
                    :ruleset subst)

          (rule ((can-subst-Operand-beneath above from to)
                (= new-from (PRINT from state)))
                ((can-subst-Expr-beneath above new-from (PRINT to state)))
                :ruleset subst)

          (function VecOperand-get (VecOperand i64) Operand)
          (rule ((VO x) (> (vec-length x) 0))
                ((union (VecOperand-get (VO x) 0) (vec-get x 0)))
                :ruleset subst)
          (rule ((VecOperand-get (VO x) j)
                 (= i (+ j 1)) (< i (vec-length x)))
                ((union (VecOperand-get (VO x) i) (vec-get x i)))
                :ruleset subst)

          (rule ((can-subst-Operand-beneath above from to)
                 (= from (VecOperand-get (VO vec) i)))
                ((can-subst-VecOperand-beneath
                    above
                    (VO vec)
                    (VO (vec-set vec i to))))
                :ruleset subst)

          (function VecVecOperand-get (VecVecOperand i64) VecOperand)
          (rule ((VVO x) (> (vec-length x) 0))
                ((union (VecVecOperand-get (VVO x) 0) (vec-get x 0)))
                :ruleset subst)
          (rule ((VecVecOperand-get (VVO x) j)
                 (= i (+ j 1)) (< i (vec-length x)))
                ((union (VecVecOperand-get (VVO x) i) (vec-get x i)))
                :ruleset subst)

          (rule ((can-subst-VecOperand-beneath above from to)
                 (= from (VecVecOperand-get (VVO vec) i)))
                ((can-subst-VecVecOperand-beneath
                    above
                    (VVO vec)
                    (VVO (vec-set vec i to))))
                :ruleset subst)
;; Shift
(ruleset shift)

;; Within e, replace all (Args x) where x > last-unshifted
;; with (Args (x + amt))
;;                             e             last-unshifted  amt
(function ShiftExpr           (Expr          i64             i64) Expr)
(function ShiftOperand        (Operand       i64             i64) Operand)
(function ShiftBody           (Body          i64             i64) Body)
(function ShiftVecOperand     (VecOperand    i64             i64) VecOperand)
(function ShiftVecVecOperand  (VecVecOperand i64             i64) VecVecOperand)

(rewrite (ShiftExpr (Const ty ops lit) last-unshifted amt) (Const ty ops lit) :ruleset shift)
(rewrite (ShiftExpr (Call ty f args n-outs) last-unshifted amt) (Call ty f (ShiftVecOperand args last-unshifted amt) n-outs) :ruleset shift)
(rewrite (ShiftExpr (badd ty a b) last-unshifted amt) (badd ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (bsub ty a b) last-unshifted amt) (bsub ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (bmul ty a b) last-unshifted amt) (bmul ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (bdiv ty a b) last-unshifted amt) (bdiv ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (beq ty a b) last-unshifted amt) (beq ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (blt ty a b) last-unshifted amt) (blt ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (bgt ty a b) last-unshifted amt) (bgt ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (ble ty a b) last-unshifted amt) (ble ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (bge ty a b) last-unshifted amt) (bge ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (bnot ty a b) last-unshifted amt) (bnot ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (band ty a b) last-unshifted amt) (band ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftExpr (bor ty a b) last-unshifted amt) (bor ty (ShiftOperand a last-unshifted amt) (ShiftOperand b last-unshifted amt)) :ruleset shift)

(rule ((= f (ShiftOperand (Arg x) last-unshifted amt)) (<= x last-unshifted))
      ((union f (Arg x))) :ruleset shift)
(rule ((= f (ShiftOperand (Arg x) last-unshifted amt)) (> x last-unshifted))
      ((union f (Arg (+ x amt)))) :ruleset shift)

(rewrite (ShiftOperand (Node b) last-unshifted amt) (Node (ShiftBody b last-unshifted amt)) :ruleset shift)
(rewrite (ShiftOperand (Project i b) last-unshifted amt) (Project i (ShiftBody b last-unshifted amt)) :ruleset shift)

(rewrite (ShiftBody (PureOp e) last-unshifted amt) (PureOp (ShiftExpr e last-unshifted amt)) :ruleset shift)
;; Shift doesn't cross regions - so we shift into the inputs but not outputs
;; Node that a Gamma node's idx is on the outside, so it gets affected, but not
;; a Theta node's predicate
(rewrite (ShiftBody (Gamma pred inputs outputs) last-unshifted amt) (Gamma (ShiftOperand pred last-unshifted amt) (ShiftVecOperand inputs last-unshifted amt) outputs) :ruleset shift)
(rewrite (ShiftBody (Theta pred inputs outputs) last-unshifted amt) (Theta pred (ShiftVecOperand inputs last-unshifted amt) outputs) :ruleset shift)

;; params: vec, var, op, next index to shift
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function ShiftVecOperandHelper (VecOperand i64 i64 i64) VecOperand)
(rewrite (ShiftVecOperand vec last-unshifted amt) (ShiftVecOperandHelper vec last-unshifted amt 0) :ruleset shift)
(rule
  (
    (= f (ShiftVecOperandHelper (VO vec) last-unshifted amt i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (ShiftVecOperandHelper (VO vec) last-unshifted amt i)
      (ShiftVecOperandHelper
        (VO (vec-set vec i (ShiftOperand (vec-get vec i) last-unshifted amt)))
        last-unshifted amt (+ i 1)
        ))
  ) :ruleset shift)

(rule
  (
    (= f (ShiftVecOperandHelper (VO vec) last-unshifted amt i))
    (= i (vec-length vec))
  )
  ( 
    (union (ShiftVecOperandHelper (VO vec) last-unshifted amt i) (VO vec))
  ) :ruleset shift)


;; params: vec, var, op, next index to shift
;; rtjoa: TODO: implement by mapping internally so they're not O(n^2) time
(function ShiftVecVecOperandHelper (VecVecOperand i64 i64 i64) VecVecOperand)
(rewrite (ShiftVecVecOperand vec last-unshifted amt) (ShiftVecVecOperandHelper vec last-unshifted amt 0) :ruleset shift)
(rule
  (
    (= f (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i))
    (< i (vec-length vec))
  )
  ( 
    (union
      (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i)
      (ShiftVecVecOperandHelper
        (VVO (vec-set vec i (ShiftVecOperand (vec-get vec i) last-unshifted amt)))
        last-unshifted amt (+ i 1)
        ))
  ) :ruleset shift)

(rule
  (
    (= f (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i))
    (= i (vec-length vec))
  )
  ( 
    (union (ShiftVecVecOperandHelper (VVO vec) last-unshifted amt i) (VVO vec))
  ) :ruleset shift)

;; ####################################
;; implementation of PassThroughArguments
;; Creates a vec of arguments
;; (vec-of (Arg 0) (Arg 1) ...) with length i
(function PassThroughArguments (i64) VecOperand :unextractable)



;; (how many arguments to generate, vector so far)
(function PassThroughArgumentsHelper (i64 VecOperand) VecOperand :unextractable)

(rewrite (PassThroughArguments i)
  (PassThroughArgumentsHelper i (VO (vec-of)))
  :ruleset subst)

(rule ((= lhs (PassThroughArgumentsHelper i (VO rest)))
       (< (vec-length rest) i))
      ((union lhs
        (PassThroughArgumentsHelper i
            (VO (vec-push rest (Arg (vec-length rest)))))))
      :ruleset subst)

(rule ((= lhs (PassThroughArgumentsHelper i (VO rest)))
       (= (vec-length rest) i))
      ((union lhs (VO rest)))
      :ruleset subst)



;; Project each argument out of a body
(function BodyToVecOperand (i64 Body) VecOperand :unextractable)
;; current index, body length, body, and vector so far
(function BodyToVecOperandHelper (i64 i64 Body VecOperandBase) VecOperand :unextractable)

(rewrite (BodyToVecOperand body-len body)
         (BodyToVecOperandHelper 0 body-len body (vec-of)))
(rule
  ((= helper (BodyToVecOperandHelper index body-len body so-far))
   (< index body-len))
  ((union helper
          (BodyToVecOperandHelper (+ index 1) body-len body
                                  (vec-push so-far 
                                   (Project index body)))))
  :ruleset subst)

(rule
  ((= helper (BodyToVecOperandHelper index body-len body so-far))
   (= index body-len))
  ((union helper (VO so-far)))
  :ruleset subst)



;; constant_fold.rs adds most constant folding operations
;; this file is for special cases


;; eliminate gamma nodes for true and false cases
(rule ((= gamma
          ;; gamma predicate is true
          (Gamma (Node (PureOp (Const (BoolT) (const) (Bool true))))
                 inputs
                 (VVO outputs))))
      (
        ;; replace use of the gamma with
        ;; the true case
        (union
          gamma
          (OperandGroup
              (SubstVecOperandAll inputs
                (vec-get outputs 1))))))



(rule ((= gamma
          ;; gamma predicate is false
          (Gamma (Node (PureOp (Const (BoolT) (const) (Bool false))))
                 inputs
                 (VVO outputs))))
      (
        ;; replace use of the gamma with
        ;; the false case
        (union
          gamma
          (OperandGroup
              (SubstVecOperandAll inputs
                (vec-get outputs 0))))))

;; Eliminate theta
;; Unroll one layer and get rid of loop
(rule ((= theta
          ;; gamma predicate is false
          (Theta (Node (PureOp (Const (BoolT) (const) (Bool false))))
                 (VO inputs)
                 (VO outputs))))
      ((let after-one-iter (SubstVecOperandAll (VO inputs) (VO outputs)))
       (union theta
          (OperandGroup after-one-iter))))





(rewrite (badd output_type
                    (Node (PureOp (Const ty2 (const) (Num n1))))
                    (Node (PureOp (Const ty3 (const) (Num n2)))))
                  (Const output_type (const) (Num (+ n1 n2))))
(rewrite (bsub output_type
                    (Node (PureOp (Const ty2 (const) (Num n1))))
                    (Node (PureOp (Const ty3 (const) (Num n2)))))
                  (Const output_type (const) (Num (- n1 n2))))
(rewrite (bmul output_type
                    (Node (PureOp (Const ty2 (const) (Num n1))))
                    (Node (PureOp (Const ty3 (const) (Num n2)))))
                  (Const output_type (const) (Num (* n1 n2))))
(rewrite (bdiv output_type
                    (Node (PureOp (Const ty2 (const) (Num n1))))
                    (Node (PureOp (Const ty3 (const) (Num n2)))))
                  (Const output_type (const) (Num (/ n1 n2))))
(rewrite (blt output_type
                  (Node (PureOp (Const ty2 (const) (Num n1))))
                  (Node (PureOp (Const ty3 (const) (Num n2)))))
                (Const output_type (const) (Bool (bool-< n1 n2))))
;;	if a && b:
;;		A
;;	else:
;;		B
;; ----------
;;	if a:
;;		if b:
;;			A
;;		else:
;;			B
;;	else:
;;		B
(rule ((= gamma (Gamma (Node (PureOp (band BoolT a b))) (VO inputs) (VVO outputs)))
       (= (vec-length outputs) 2)
       (= (vec-get outputs 1) (VO A))
       (= (vec-get outputs 0) (VO B))
       (= args (vec-length inputs))
       (= rets (vec-length B)))
      ((let inner (Gamma (Arg args) ; we pass b as an extra argument to the outer gamma
                         (PassThroughArguments args)
                         (VVO (vec-of (VO B)
                                      (VO A)))))
       (union gamma (Gamma a
                           (VO (vec-push inputs b)) ; pass b as an extra argument
                           (VVO (vec-of (VO B)
                                        (BodyToVecOperand rets inner)))))))

;;	if a || b:
;;		A
;;	else:
;;		B
;; -----------
;;	if a:
;;		A
;;	else:
;;		if b:
;;			A
;;		else:
;;			B
(rule ((= gamma (Gamma (Node (PureOp (bor BoolT a b))) (VO inputs) (VVO outputs)))
       (= (vec-length outputs) 2)
       (= (vec-get outputs 1) (VO A))
       (= (vec-get outputs 0) (VO B))
       (= args (vec-length inputs))
       (= rets (vec-length B)))
      ((let inner (Gamma (Arg args) ; we pass b as an extra argument to the outer gamma
                         (PassThroughArguments args)
                         (VVO (vec-of (VO B)
                                      (VO A)))))
       (union gamma (Gamma a
                           (VO (vec-push inputs b)) ; pass b as an extra argument
                           (VVO (vec-of (BodyToVecOperand rets inner)
                                        (VO A)))))))

;;	if a:
;;		A
;;	else:
;;		A
;; ------
;;	A
(rule ((= gamma (Gamma condition inputs (VVO outputs)))
       (= (vec-length outputs) 2)
       (= (vec-get outputs 0) (vec-get outputs 1)))
      ((union gamma (OperandGroup (SubstVecOperandAll inputs (vec-get outputs 0))))))


;; unroll loops
(rule ((= theta (Theta pred (VO inputs) (VO outputs))))
                          ;;            arguments body
      ((let after-one-iter
         (SubstVecOperandAll (VO inputs) (VO outputs)))
       ;; (vec-of (Arg 0) (Arg 1) ...)
       (let pass-through (PassThroughArguments (vec-length outputs)))
       (union theta
          (Gamma
            (SubstOperandAll after-one-iter pred)
            after-one-iter
            (VVO
              (vec-of
                ;; in the false case, we are done
                pass-through
                ;; otherwise do the rest of the loop
                (BodyToVecOperand
                (vec-length outputs)
                (Theta pred pass-through
                            (VO outputs)))))))))



(rule  
    (
        ; Match on PureOp because all exprs are converted to bodies
        ; Will refactor Call in the future
        (= return (PureOp (Call ty name args num)) )
        (Func name input-types output-types body)
    )
    ((
        union 
        return
        (OperandGroup (SubstVecOperandAll args body))
    ))
)
;; in-loop
;;
;; ORIGINAL
;; a = 0
;; c = 3
;; for  i = 0 to n:
;;     a = i * c
;;
;; OPTIMIZED
;; a = 0
;; c = 3
;; d = 0
;; for i = 0 to n:
;;     a += d
;;     d += c
(rule 
    (
        ;; Find theta
        (= old-theta (Theta pred (VO inputs) (VO outputs)))
        ; Find constant in the theta
        (= c (Node (PureOp (Const (IntT) (const) (Num 7)))))
        (= i (Arg 1))
        (= old-exp (Node (PureOp (bmul (IntT) c i))))
    )
    (
        ; Initial value of temp is i * b
        (let d-init (Node (PureOp (bmul (IntT) c (Arg 1)))))
        ; Value of temp in loop
        (let d-out (Node (PureOp (badd (IntT) (Arg 3) c))))
        (let new-theta 
            (Theta pred (VO (vec-push inputs d-init)) (VO (vec-push outputs d-out)))
        )

        ; Substitute Arg 3, the temp var, for the *i expression
        (can-subst-Operand-beneath new-theta (Arg 3) old-exp)

        (union old-theta
            (OperandGroup 
                (VO 
                    (vec-of
                        (Project 0 new-theta)
                        (Project 1 new-theta)
                        (Project 2 new-theta)
                    )
                )
            )
        )
    )
)

     (rule
      ((= num (Node (PureOp (Const (IntT) (const) (Num n1)))))
       (= lhs (badd (IntT) other num)))
      ((union lhs (badd (IntT) num other))))

     (rule
      ((= num (Node (PureOp (Const (IntT) (const) (Num n1)))))
       (= lhs (bmul (IntT) other num)))
      ((union lhs (bmul (IntT) num other))))

      (rule
        ((= lhs (badd (IntT)
                      (Node (PureOp (badd (IntT) a b)))
                      c)))
        ((union lhs
                (badd (IntT)
                      a
                      (Node (PureOp (badd (IntT) b c)))))))
      

        (rule
          ((= lhs (badd (IntT)
                        a
                        (Node (PureOp (badd (IntT) b c)))))
           (= b (Node (PureOp (Const (IntT) (const) (Num n1)))))            
          )
          ((union lhs
             (badd (IntT)
                   b
                   (Node (PureOp (badd (IntT) a c))))))               
        )
      

      (rule
        ((= lhs (badd (IntT)
                      a
                      (Node (PureOp (badd (IntT) b c)))))
         (= a (Node (PureOp (Const (IntT) (const) (Num n1)))))
         (= b (Node (PureOp (Const (IntT) (const) (Num n2))))))

        ((union lhs
          (badd (IntT)
            (Node (PureOp (Const (IntT) (const) (Num (+ n1 n2)))))
            c))))      
      
(let v0 (Func "main" (vec-of (Bril (IntT)) (PrintState)) (vec-of (PrintState)) (VO (vec-of (Node (PureOp (PRINT (Project 1 (Theta (Node (PureOp (blt (BoolT) (Arg 1) (Arg 2)))) (VO (vec-of (Arg 1) (Node (PureOp (Const (IntT) (const) (Num 0)))) (Arg 0))) (VO (vec-of (Node (PureOp (PRINT (Node (PureOp (bmul (IntT) (Node (PureOp (Const (IntT) (const) (Num 7)))) (Arg 1)))) (Arg 0)))) (Node (PureOp (badd (IntT) (Arg 1) (Node (PureOp (Const (IntT) (const) (Num 1))))))) (Arg 2))))) (Project 0 (Theta (Node (PureOp (blt (BoolT) (Arg 1) (Arg 2)))) (VO (vec-of (Arg 1) (Node (PureOp (Const (IntT) (const) (Num 0)))) (Arg 0))) (VO (vec-of (Node (PureOp (PRINT (Node (PureOp (bmul (IntT) (Node (PureOp (Const (IntT) (const) (Num 7)))) (Arg 1)))) (Arg 0)))) (Node (PureOp (badd (IntT) (Arg 1) (Node (PureOp (Const (IntT) (const) (Num 1))))))) (Arg 2))))))))))))
(run-schedule
        (repeat 2 (run)
                  (saturate subst)))


; This is trying to check if the optimized loop gets generated at all
(let theta (Theta (Node (PureOp (blt (BoolT) (Arg 1) (Arg 2)))) (VO (vec-of (Arg 1) (Node (PureOp (Const (IntT) (const) (Num 0)))) (Arg 0))) (VO (vec-of (Node (PureOp (PRINT (Node (PureOp (bmul (IntT) (Node (PureOp (Const (IntT) (const) (Num 7)))) (Arg 1)))) (Arg 0)))) (Node (PureOp (badd (IntT) (Arg 1) (Node (PureOp (Const (IntT) (const) (Num 1))))))) (Arg 2)))))


(query-extract :variants 8 theta)
(query-extract :variants 6 (Arg 3))

;
; This is where I was trying to check if the tuple I wanted to insert was inserted
;
; (let new-theta (Theta 
;   (Node (PureOp (blt (BoolT) (Arg 1) (Arg 2)))) 
;   (VO (vec-of 
;       (Arg 1) 
;       (Node (PureOp (Const (IntT) (const) (Num 0)))) 
;       (Arg 0) 
;       (Node (PureOp (bmul (IntT) (Node (PureOp (Const (IntT) (const) (Num 7))))  (Arg 1)))))) 
;   (VO (vec-of 
;       (Node (PureOp (PRINT (Node (PureOp (bmul (IntT) (Node (PureOp (Const (IntT) (const) (Num 7)))) (Arg 1)))) (Arg 0)))) 
;       (Node (PureOp (badd (IntT) (Arg 1) (Node (PureOp (Const (IntT) (const) (Num 1))))))) 
;       (Arg 2) 
;       (Node (PureOp (badd (IntT) (Arg 3) (Node (PureOp (Const (IntT) (const) (Num 7)))))))))))
; (check (can-subst-Operand-beneath
;     new-theta
;     (Node (PureOp (bmul (IntT) (Node (PureOp (Const (IntT) (const) (Num 7)))) (Arg 1))))
;     (Arg 3)))
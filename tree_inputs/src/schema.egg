; Every term is an `Expr`.
(datatype Expr)
; Used for constructing tuples and `Switch`es.
(datatype ListExpr (Cons Expr ListExpr) (Nil))

; =================================
; Types
; =================================

(sort TypeList)

(datatype Type
  (IntT)
  (BoolT)
  ; TODO delete? No first-class functions
  (FuncT Type Type)
  ; Use a tuple of length 0 for a "unit" type
  (TupleT TypeList) 
)

(function TNil () TypeList)
(function TCons (Type TypeList) TypeList)

; =================================
; Operators that do not create regions
; =================================
(datatype BinaryOp
  (Add)
  (Sub)
  (Mul)
  (LessThan)
  (And)
  (Or)
  (Write))
(datatype UnaryOp
  (Not)
  (Print))

; Constants
(datatype Constant
  (Int i64)
  (Bool bool))
(function Const (Ctx Constant) Expr)

; Operators
(function Bop   (BinaryOp Expr Expr) Expr)
(function Uop   (UnaryOp Expr) Expr)
; gets from a tuple. static index
(function Get   (Expr i64) Expr)
; read has a type, so it can't be a BinaryOp
(function Read  (Expr Type)      Expr) 
;               name of func   arg
(function Call (String         Expr) Expr)


; =================================
; Tuple operations
; =================================
(datatype Order (Parallel) (Sequential))

; Perform a list of operations. Only way to create a tuple!
; Needs a Ctx because the list may be empty.
; E.g. (All (Parallel) (Nil)) is a leaf, so it needs a Ctx.
(function All (Ctx Order ListExpr) Expr)

; =================================
; Control flow
; =================================

; Switch on a list of lazily-evaluated branches.
; Does not create a region.
; pred must be an integer
;                 pred     branches     chosen
(function Switch (Expr     ListExpr)    Expr)
; If is like switch, but with a boolean predicate
;             pred then else
(function If (Expr Expr Expr) Expr)


; Creates a region, binding the input so that it can
; be referred to using `Arg`.
; 
;              input    output
(function Let (Expr     Expr)    Expr)


; A do-while loop.

; iter_val = [[input]]
; pred_val = false
; while !pred_val:
;   pred_val, iter_val = iter_val = [[pred_output[ arg |-> iter_val]]]
; iter_val

; input must have the same type as output
; pred must be a boolean
;                  input   (pred, output) tuple
(function DoWhile (Expr    Expr)                   Expr)


; An argument to a region.
(function Arg (Type) Expr)



; =================================
; Assume
; =================================

(datatype Assumption
  ; The argument is bound to `expr`.
  ; The argument cannot be unioned with `expr` because `expr`
  ; is evaluated once at the nearest enclosing `Let`.
  ;      expr
  (InLet Expr)
  ; The term is in a loop with `input` and `output`.
  ;      input    output
  (InLoop Expr     Expr)
  ; Other assumptions are possible, but not supported yet.
  ; For example:
  ;      A boolean predicate is true.
  ;      e.g. (> (Arg (IntT)) (Const (Int 2)))
  ; (IsTrue Expr))
)

; Assume allows creating context-specific terms.
; e.g. (Assume (InLet (Const (Int 2))) (Arg (IntT))) is equal to (Const (Int 2))
(function Assume (Assumption Expr) Expr)


; =================================
; Top-level expressions
; =================================
; An entry function and a list of additional functions.
;                      entry function     other functions
(relation Program     (Expr               ListExpr))
;                   name   input ty  output ty  output
(function Function (String Type      Type       Expr)      Expr)



; Rulesets
(ruleset always-run)
(ruleset error-checking)

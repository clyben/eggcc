;; Loop Invariant
;;                      loop  expr-in-loop
(relation find-inv-Expr (Expr Expr))
(relation find-inv-ListExpr (Expr ListExpr))

;; bool: whether the term in the Expr is an invariant.
;;                    loop  expr-in-loop
(function is-inv-Expr (Expr Expr) bool :unextractable :merge (or old new))
(function is-inv-ListExpr (Expr ListExpr) bool :unextractable :merge (or old new))

(relation arg-inv (Expr i64))

;; in default, when there is a find, set is-inv to false
(rule ((find-inv-Expr loop term)) ((set (is-inv-Expr loop term) false)) :ruleset always-run)
(rule ((find-inv-ListExpr loop term)) ((set (is-inv-ListExpr loop term) false)) :ruleset always-run)

;; I assume input is tuple here
(rule ((= loop (Loop id inputs outputs))
       (= (Get (Arg id) i) (get-loop-outputs-ith loop i)))
    ((arg-inv loop i)) :ruleset always-run)

;; top level entry
(rule ((= loop (Loop id inputs outputs))
	   (arg-inv loop i))
	((find-inv-Expr loop outputs)) :ruleset always-run)

;; propagations

;; ListExpr -> expr
(rule ((find-inv-ListExpr loop list) 
       (= ith (ListExpr-ith list i))) 
    ((find-inv-Expr loop ith)) :ruleset always-run)


(relation is-inv-ListExpr-helper (Expr ListExpr i64))
(rule ((find-inv-ListExpr loop list)) ((is-inv-ListExpr-helper loop list 0)) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= true (is-inv-Expr loop expr))
       (= expr (ListExpr-ith list i)))
    ((is-inv-ListExpr-helper loop list (+ i 1))) :ruleset always-run)

(rule ((is-inv-ListExpr-helper loop list i)
       (= i (ListExpr-length list)))
    ((set (is-inv-ListExpr loop list) true)) :ruleset always-run)

(ruleset boundary-analysis)
;; An Expr is on boundary when it is invariant and its parent is not
;                       loop invariant-expr
(relation boundary-Expr (Expr Expr))

;; boundary for ListExpr's children
(rule ((= true (is-inv-Expr loop expr))
       (= false (is-inv-ListExpr loop list))
       (= expr (ListExpr-ith list i)))
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; if a output branch is invariant, it's also boundary-Expr
(rule ((= true (is-inv-Expr loop expr))
       (= expr (get-loop-outputs-ith loop i))) 
      ((boundary-Expr loop expr)) :ruleset boundary-analysis)

;; a ListExpr could be on invariant boundary if it occur in switch
;; we don't hoist this ListExpr but hoist all Expr in list.
;; maybe no, it's unsound
; (rule ((= true (is-inv-ListExpr loop list))
;        (= false (is-inv-Expr loop (Switch pred list)))
;        (= subexpr (ListExpr-ith list i)))
;        ((boundary-Expr loop subexpr)))

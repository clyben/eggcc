(ruleset type-analysis)

(sort TypeList)

(datatype Type
  (IntT)
  (BoolT)
  (UnitT)
  (FuncT Type Type)
  (TupleT TypeList)
)

(function TNil () TypeList)
(function TCons (Type TypeList) TypeList)

(function TypeList-length (TypeList) i64)
(function TypeList-ith (TypeList i64) Type :unextractable)
(function TypeList-suffix (TypeList i64) TypeList :unextractable)

(rule ((TupleT tylist)) ((union (TypeList-suffix tylist 0) tylist)) :ruleset type-analysis)

(rule ((= (TypeList-suffix top n) (TCons hd tl)))
    ((union (TypeList-ith top n) hd)
     (union (TypeList-suffix top (+ n 1)) tl)) :ruleset type-analysis)

(rule ((= (TypeList-suffix list n) (TNil)))
    ((set (TypeList-length list) n)) :ruleset type-analysis)

(relation HasTypeDemand (IdSort Expr))

(relation HasType (IdSort Expr Type))

; Primitives
(rule ((HasTypeDemand ctx (Num ctx n)))
      ((HasType ctx (Num ctx n) (IntT)))
      :ruleset type-analysis)

(rule ((HasTypeDemand ctx (Boolean ctx b)))
      ((HasType ctx (Boolean ctx b) (BoolT)))
      :ruleset type-analysis)

(rule ((HasTypeDemand ctx (UnitExpr ctx)))
      ((HasType ctx (UnitExpr ctx) (UnitT)))
      :ruleset type-analysis)


; Pure Op Demand
(rule ((HasTypeDemand ctx (Add x y)))
      (
       (HasTypeDemand ctx x)
       (HasTypeDemand ctx y)
      )
      :ruleset type-analysis)
(rule ((HasTypeDemand ctx (Sub x y)))
      (
       (HasTypeDemand ctx x)
       (HasTypeDemand ctx y)
      )
      :ruleset type-analysis)
(rule ((HasTypeDemand ctx (Mul x y)))
      (
       (HasTypeDemand ctx x)
       (HasTypeDemand ctx y)
      )
      :ruleset type-analysis)
(rule ((HasTypeDemand ctx (LessThan x y)))
      (
       (HasTypeDemand ctx x)
       (HasTypeDemand ctx y)
      )
      :ruleset type-analysis)
(rule ((HasTypeDemand ctx (And x y)))
      (
       (HasTypeDemand ctx x)
       (HasTypeDemand ctx y)
      )
      :ruleset type-analysis)
(rule ((HasTypeDemand ctx (Or x y)))
      (
       (HasTypeDemand ctx x)
       (HasTypeDemand ctx y)
      )
      :ruleset type-analysis)
(rule ((HasTypeDemand ctx (Not x)))
      ((HasTypeDemand ctx x))
      :ruleset type-analysis)
(rule ((HasTypeDemand ctx (Get e idx)))
      ((HasTypeDemand ctx e))
      :ruleset type-analysis)

; Pure Op Compute
(rule (
       (HasTypeDemand ctx (Add x y))
       (HasType ctx x (IntT))
       (HasType ctx y (IntT))
      )
      (
       (HasType ctx (Add x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (HasTypeDemand ctx (Sub x y))
       (HasType ctx x (IntT))
       (HasType ctx y (IntT))
      )
      (
       (HasType ctx (Sub x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (HasTypeDemand ctx (Mul x y))
       (HasType ctx x (IntT))
       (HasType ctx y (IntT))
      )
      (
       (HasType ctx (Mul x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (HasTypeDemand ctx (LessThan x y))
       (HasType ctx x (IntT))
       (HasType ctx y (IntT))
      )
      (
       (HasType ctx (LessThan x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (HasTypeDemand ctx (And x y))
       (HasType ctx x (BoolT))
       (HasType ctx y (BoolT))
      )
      (
       (HasType ctx (And x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (HasTypeDemand ctx (Or x y))
       (HasType ctx x (BoolT))
       (HasType ctx y (BoolT))
      )
      (
       (HasType ctx (Or x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (HasTypeDemand ctx (Not x))
       (HasType ctx x (BoolT))
      )
      (
       (HasType ctx (Not x) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (HasTypeDemand ctx (Get e n))
       (HasType ctx e (TupleT tylist))
      )
      ((HasType ctx (Get e n) (TypeList-ith tylist n)))
      :ruleset type-analysis)

; Effectful Ops
(rule ((HasTypeDemand ctx (Print e)))
      ((HasType ctx (Print e) (UnitT)))
      :ruleset type-analysis)
; TODO: Read and Write (requires type annotations)

; Switch 
; if the condition is a boolean, it must have exactly two branches
(rule ((HasTypeDemand ctx (Switch cond (Cons A (Cons B (Nil))))))
      (
       (HasTypeDemand ctx cond)
       (HasTypeDemand ctx A)
       (HasTypeDemand ctx B)
      )
      :ruleset type-analysis)
(rule (
       (= switch (Switch cond (Cons A (Cons B (Nil)))))
       (HasTypeDemand ctx switch)
       (HasType ctx cond (BoolT))
       (HasType ctx A ty)
       (HasType ctx B ty)
      )
      ((HasType ctx switch ty))
      :ruleset type-analysis)

; Otherwise, the condition must be an integer, and we can have any number of branches.

; peel off a branch and demand type
(rule ((HasTypeDemand ctx (Switch cond (Cons branch rest))))
      (
       (HasTypeDemand ctx branch)
       (HasTypeDemand ctx (Switch cond rest))
      )
      :ruleset type-analysis)
; base case- demand the type of the condition
(rule ((HasTypeDemand ctx (Switch cond Nil)))
      ((HasTypeDemand ctx cond))
      :ruleset type-analysis)

; base case- single branch switch has type of branch
(rule (
       (HasTypeDemand ctx (Switch cond (Cons branch (Nil))))
       ; boolean condition handled above, now we must have an integer condition
       (HasType ctx cond (IntT))
       (HasType ctx branch ty)
      )
      ((HasType ctx (Switch cond (Cons branch (Nil))) ty))
      :ruleset type-analysis)
; recursive case
(rule (
       (HasTypeDemand ctx (Switch cond (Cons branch rest)))
       (HasType ctx (Switch cond rest) ty)
       ; make sure the condition is an integer
       ; (prevents us from typing boolean switches with >2 branches)
       (HasType ctx cond (IntT))
       (HasType ctx branch ty)
      )
      ((HasType ctx (Switch cond (Cons branch rest)) ty))
      :ruleset type-analysis)

; Sequencing
(rule ((HasTypeDemand ctx (All ord (Cons hd tl))))
      (
       (HasTypeDemand ctx hd)
       (HasTypeDemand ctx (All ord tl))
      )
      :ruleset type-analysis)
; base case: Nil
(rule (
       (HasTypeDemand ctx (All ord (Nil)))
      )
      ((HasType ctx (All ord (Nil)) (TupleT (TNil))))
      :ruleset type-analysis)
; rec case
(rule (
       (HasTypeDemand ctx (All ord (Cons hd tl)))
       (HasType ctx hd ty)
       (HasType ctx (All ord tl) (TupleT tylist))
      )
      ((HasType ctx (All ord (Cons hd tl)) (TupleT (TCons ty tylist))))
      :ruleset type-analysis)

; If an expr has two different types, panic
(rule (
       (HasType ctx e t1)
       (HasType ctx e t2)
       (!= t1 t2)
      )
      ((panic "Type Mismatch!"))
      :ruleset type-analysis)


; Lets
(rule ((HasTypeDemand ctx (Let id in out)))
      ((HasTypeDemand ctx in))
      :ruleset type-analysis)

(rule (
       (HasTypeDemand ctx (Let id in out))
       (HasType ctx in ty)
      )
      (
       (HasType id in ty) ; assert in has type ty in the let's context
       (HasTypeDemand id out) ; demand the type of out in the let's context
      )
      :ruleset type-analysis)
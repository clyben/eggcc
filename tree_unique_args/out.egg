; We could generate this from ir.rs, this manual version is just easier reference.

(sort IdSort)
(function Id (i64) IdSort)
(datatype Expr)
(datatype ListExpr (Cons Expr ListExpr) (Nil))

(sort TypeList)

(datatype Type
  (IntT)
  (BoolT)
  (FuncT Type Type)
  (TupleT TypeList)
  (UnitT)
)

(function TNil () TypeList)
(function TCons (Type TypeList) TypeList)

; ==========================
; Pure operators
; ==========================
;              id     val
(function Num (IdSort i64) Expr)
;                  id     val
(function Boolean (IdSort bool) Expr)
;                   id
(function UnitExpr (IdSort) Expr) ; Unit is already an egglog sort
(function Add (Expr Expr) Expr)
(function Sub (Expr Expr) Expr)
(function Mul (Expr Expr) Expr)
(function LessThan (Expr Expr) Expr)
(function And (Expr Expr) Expr)
(function Or (Expr Expr) Expr)
(function Not (Expr) Expr)
(function Get (Expr i64) Expr) ; gets from a tuple. static index

; ==========================
; Effectful operators
; ==========================

;                value      unit
(function Print (Expr)      Expr)
;                addr type      value
(function Read  (Expr Type)      Expr)
;                addr value unit
(function Write (Expr Expr) Expr)

; ==========================
; Control flow operators
; ==========================

(datatype Order (Parallel) (Sequential))

; Perform a list of operations. Only way to create a tuple!
(function All (IdSort Order ListExpr) Expr)

; Switch on a list of lazily-evaluated branches. Doesn't create context
;                 pred branches chosen
(function Switch (Expr ListExpr)    Expr)

; ==========================
; Regions
; ==========================

; pred and output are evaluated inside the loop's context
; input and output may or may not be a tuples. pred must be boolean.
; 
;               id     input (pred, output) tuple
(function Loop (IdSort Expr  Expr)  Expr)

;              id     input output
(function Let (IdSort Expr  Expr) Expr)

; Arg gets the input of a region or the parameter of a function
(function Arg (IdSort) Expr)

; ==========================
; Functions
; ==========================

;                   f      output
(function Function (IdSort Expr) Expr)

;               f      arg
(function Call (IdSort Expr) Expr)

;; Rulesets
(ruleset always-run)
(ruleset error-checking)

(relation ExprIsValid (Expr))
(relation ListExprIsValid (ListExpr))
(rule ((ExprIsValid (Add _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Sub _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Mul _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (LessThan _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (And _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Or _x _y))) ((ExprIsValid _x)
(ExprIsValid _y)) :ruleset always-run)
(rule ((ExprIsValid (Not _x))) ((ExprIsValid _x)) :ruleset always-run)
(rule ((ExprIsValid (Get _tup _i))) ((ExprIsValid _tup)) :ruleset always-run)
(rule ((ExprIsValid (Print _printee))) ((ExprIsValid _printee)) :ruleset always-run)
(rule ((ExprIsValid (Read _addr _type))) ((ExprIsValid _addr)) :ruleset always-run)
(rule ((ExprIsValid (Write _addr _data))) ((ExprIsValid _addr)
(ExprIsValid _data)) :ruleset always-run)
(rule ((ExprIsValid (All _id _order _exprs))) ((ListExprIsValid _exprs)) :ruleset always-run)
(rule ((ExprIsValid (Switch _pred _branches))) ((ExprIsValid _pred)
(ListExprIsValid _branches)) :ruleset always-run)
(rule ((ExprIsValid (Loop _id _in _pred-and-output))) ((ExprIsValid _in)
(ExprIsValid _pred-and-output)) :ruleset always-run)
(rule ((ExprIsValid (Let _id _in _out))) ((ExprIsValid _in)
(ExprIsValid _out)) :ruleset always-run)
(rule ((ExprIsValid (Call _f _arg))) ((ExprIsValid _arg)) :ruleset always-run)
(rule ((ListExprIsValid (Cons _hd _tl))) ((ExprIsValid _hd)
(ListExprIsValid _tl)) :ruleset always-run)
(relation ExprIsPure (Expr))
(relation ListExprIsPure (ListExpr))
(relation FunctionIsPure (IdSort))
(rule ((Function id out) (ExprIsPure out)) ((FunctionIsPure id)):ruleset always-run)
(rule ((Num _id _n))
      ((ExprIsPure (Num _id _n)))
      :ruleset always-run)
(rule ((Boolean _id _b))
      ((ExprIsPure (Boolean _id _b)))
      :ruleset always-run)
(rule ((Add _x _y) (ExprIsPure _x) (ExprIsPure _y))
      ((ExprIsPure (Add _x _y)))
      :ruleset always-run)
(rule ((Sub _x _y) (ExprIsPure _x) (ExprIsPure _y))
      ((ExprIsPure (Sub _x _y)))
      :ruleset always-run)
(rule ((Mul _x _y) (ExprIsPure _x) (ExprIsPure _y))
      ((ExprIsPure (Mul _x _y)))
      :ruleset always-run)
(rule ((LessThan _x _y) (ExprIsPure _x) (ExprIsPure _y))
      ((ExprIsPure (LessThan _x _y)))
      :ruleset always-run)
(rule ((And _x _y) (ExprIsPure _x) (ExprIsPure _y))
      ((ExprIsPure (And _x _y)))
      :ruleset always-run)
(rule ((Or _x _y) (ExprIsPure _x) (ExprIsPure _y))
      ((ExprIsPure (Or _x _y)))
      :ruleset always-run)
(rule ((Not _x) (ExprIsPure _x))
      ((ExprIsPure (Not _x)))
      :ruleset always-run)
(rule ((Get _tup _i) (ExprIsPure _tup))
      ((ExprIsPure (Get _tup _i)))
      :ruleset always-run)
(rule ((All _id _order _exprs) (ListExprIsPure _exprs))
      ((ExprIsPure (All _id _order _exprs)))
      :ruleset always-run)
(rule ((Switch _pred _branches) (ExprIsPure _pred) (ListExprIsPure _branches))
      ((ExprIsPure (Switch _pred _branches)))
      :ruleset always-run)
(rule ((Loop _id _in _pred-and-output) (ExprIsPure _in) (ExprIsPure _pred-and-output))
      ((ExprIsPure (Loop _id _in _pred-and-output)))
      :ruleset always-run)
(rule ((Let _id _in _out) (ExprIsPure _in) (ExprIsPure _out))
      ((ExprIsPure (Let _id _in _out)))
      :ruleset always-run)
(rule ((Arg _id))
      ((ExprIsPure (Arg _id)))
      :ruleset always-run)
(rule ((Call _f _arg) (ExprIsPure _arg) (FunctionIsPure _f))
      ((ExprIsPure (Call _f _arg))):ruleset always-run)
(rule ((Cons _hd _tl) (ExprIsPure _hd) (ListExprIsPure _tl))
      ((ListExprIsPure (Cons _hd _tl)))
      :ruleset always-run)
(rule ((Nil))
      ((ListExprIsPure (Nil)))
      :ruleset always-run)
(relation BodyContainsExpr (IdSort Expr))
(relation BodyContainsListExpr (IdSort ListExpr))
(rule ((Loop _id _in _pred-and-output)) ((BodyContainsExpr _id _pred-and-output)) :ruleset always-run)
(rule ((Let _id _in _out)) ((BodyContainsExpr _id _out)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Add _x _y))) ((BodyContainsExpr body_id _x) (BodyContainsExpr body_id _y)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Sub _x _y))) ((BodyContainsExpr body_id _x) (BodyContainsExpr body_id _y)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Mul _x _y))) ((BodyContainsExpr body_id _x) (BodyContainsExpr body_id _y)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (LessThan _x _y))) ((BodyContainsExpr body_id _x) (BodyContainsExpr body_id _y)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (And _x _y))) ((BodyContainsExpr body_id _x) (BodyContainsExpr body_id _y)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Or _x _y))) ((BodyContainsExpr body_id _x) (BodyContainsExpr body_id _y)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Not _x))) ((BodyContainsExpr body_id _x)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Get _tup _i))) ((BodyContainsExpr body_id _tup)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Print _printee))) ((BodyContainsExpr body_id _printee)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Read _addr _type))) ((BodyContainsExpr body_id _addr)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Write _addr _data))) ((BodyContainsExpr body_id _addr) (BodyContainsExpr body_id _data)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (All _id _order _exprs))) ((BodyContainsListExpr body_id _exprs)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Switch _pred _branches))) ((BodyContainsExpr body_id _pred) (BodyContainsListExpr body_id _branches)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Loop _id _in _pred-and-output))) ((BodyContainsExpr body_id _in)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Let _id _in _out))) ((BodyContainsExpr body_id _in)) :ruleset always-run)
(rule ((BodyContainsExpr body_id (Call _f _arg))) ((BodyContainsExpr body_id _arg)) :ruleset always-run)
(rule ((BodyContainsListExpr body_id (Cons _hd _tl))) ((BodyContainsExpr body_id _hd) (BodyContainsListExpr body_id _tl)) :ruleset always-run)
(function SubstExpr (Expr Expr) Expr :unextractable)
(function SubstListExpr (ListExpr Expr) ListExpr :unextractable)
(rewrite (SubstExpr (Num _id _n) v)
         (Num _id _n)
         :ruleset always-run)
(rewrite (SubstExpr (Boolean _id _b) v)
         (Boolean _id _b)
         :ruleset always-run)
(rewrite (SubstExpr (Add _x _y) v)
         (Add (SubstExpr _x v) (SubstExpr _y v))
         :ruleset always-run)
(rewrite (SubstExpr (Sub _x _y) v)
         (Sub (SubstExpr _x v) (SubstExpr _y v))
         :ruleset always-run)
(rewrite (SubstExpr (Mul _x _y) v)
         (Mul (SubstExpr _x v) (SubstExpr _y v))
         :ruleset always-run)
(rewrite (SubstExpr (LessThan _x _y) v)
         (LessThan (SubstExpr _x v) (SubstExpr _y v))
         :ruleset always-run)
(rewrite (SubstExpr (And _x _y) v)
         (And (SubstExpr _x v) (SubstExpr _y v))
         :ruleset always-run)
(rewrite (SubstExpr (Or _x _y) v)
         (Or (SubstExpr _x v) (SubstExpr _y v))
         :ruleset always-run)
(rewrite (SubstExpr (Not _x) v)
         (Not (SubstExpr _x v))
         :ruleset always-run)
(rewrite (SubstExpr (Get _tup _i) v)
         (Get (SubstExpr _tup v) _i)
         :ruleset always-run)
(rewrite (SubstExpr (Print _printee) v)
         (Print (SubstExpr _printee v))
         :ruleset always-run)
(rewrite (SubstExpr (Read _addr _type) v)
         (Read (SubstExpr _addr v) _type)
         :ruleset always-run)
(rewrite (SubstExpr (Write _addr _data) v)
         (Write (SubstExpr _addr v) (SubstExpr _data v))
         :ruleset always-run)
(rewrite (SubstExpr (All _id _order _exprs) v)
         (All _id _order (SubstListExpr _exprs v))
         :ruleset always-run)
(rewrite (SubstExpr (Switch _pred _branches) v)
         (Switch (SubstExpr _pred v) (SubstListExpr _branches v))
         :ruleset always-run)
(rewrite (SubstExpr (Loop _id _in _pred-and-output) v)
         (Loop _id (SubstExpr _in v) _pred-and-output)
         :ruleset always-run)
(rewrite (SubstExpr (Let _id _in _out) v)
         (Let _id (SubstExpr _in v) _out)
         :ruleset always-run)
(rewrite (SubstExpr (Arg (Id id)) v) v :ruleset always-run)
(rewrite (SubstExpr (Call _f _arg) v)
         (Call _f (SubstExpr _arg v))
         :ruleset always-run)
(rewrite (SubstListExpr (Cons _hd _tl) v)
         (Cons (SubstExpr _hd v) (SubstListExpr _tl v))
         :ruleset always-run)
(rewrite (SubstListExpr (Nil) v)
         (Nil)
         :ruleset always-run)
(function DeepCopyExpr (Expr IdSort) Expr :unextractable)
(function DeepCopyListExpr (ListExpr IdSort) ListExpr :unextractable)
(rule ((= e (DeepCopyExpr (Num _id _n) new-id)))
      ((union e (Num new-id _n)))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Boolean _id _b) new-id)))
      ((union e (Boolean new-id _b)))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Add _x _y) new-id)))
      ((union e (Add (DeepCopyExpr _x new-id) (DeepCopyExpr _y new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Sub _x _y) new-id)))
      ((union e (Sub (DeepCopyExpr _x new-id) (DeepCopyExpr _y new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Mul _x _y) new-id)))
      ((union e (Mul (DeepCopyExpr _x new-id) (DeepCopyExpr _y new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (LessThan _x _y) new-id)))
      ((union e (LessThan (DeepCopyExpr _x new-id) (DeepCopyExpr _y new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (And _x _y) new-id)))
      ((union e (And (DeepCopyExpr _x new-id) (DeepCopyExpr _y new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Or _x _y) new-id)))
      ((union e (Or (DeepCopyExpr _x new-id) (DeepCopyExpr _y new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Not _x) new-id)))
      ((union e (Not (DeepCopyExpr _x new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Get _tup _i) new-id)))
      ((union e (Get (DeepCopyExpr _tup new-id) _i)))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Print _printee) new-id)))
      ((union e (Print (DeepCopyExpr _printee new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Read _addr _type) new-id)))
      ((union e (Read (DeepCopyExpr _addr new-id) _type)))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Write _addr _data) new-id)))
      ((union e (Write (DeepCopyExpr _addr new-id) (DeepCopyExpr _data new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (All _id _order _exprs) new-id)))
      ((union e (All new-id _order (DeepCopyListExpr _exprs new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Switch _pred _branches) new-id)))
      ((union e (Switch (DeepCopyExpr _pred new-id) (DeepCopyListExpr _branches new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Loop _id _in _pred-and-output) new-id)))
      ((let new-inner-id (Id (i64-fresh!)))
       (union e (Loop new-inner-id (DeepCopyExpr _in new-id) (DeepCopyExpr _pred-and-output new-inner-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Let _id _in _out) new-id)))
      ((let new-inner-id (Id (i64-fresh!)))
       (union e (Let new-inner-id (DeepCopyExpr _in new-id) (DeepCopyExpr _out new-inner-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Arg _id) new-id)))
      ((union e (Arg new-id)))
      :ruleset always-run)
(rule ((= e (DeepCopyExpr (Call _f _arg) new-id)))
      ((union e (Call _f (DeepCopyExpr _arg new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyListExpr (Cons _hd _tl) new-id)))
      ((union e (Cons (DeepCopyExpr _hd new-id) (DeepCopyListExpr _tl new-id))))
      :ruleset always-run)
(rule ((= e (DeepCopyListExpr (Nil) new-id)))
      ((union e (Nil)))
      :ruleset always-run)
; Functions useful for writing tests and actions, but should not be matched on
(function Pair (Expr Expr) ListExpr)
(rewrite (Pair a b)
         (Cons a (Cons b (Nil)))
         :ruleset always-run)

(function list3 (Expr Expr Expr) ListExpr)
(rewrite (list3 a b c)
         (Cons a (Cons b (Cons c (Nil)))) :ruleset always-run)

(function list4 (Expr Expr Expr Expr) ListExpr)
(rewrite (list4 a b c d)
         (Cons a (Cons b (Cons c (Cons d (Nil))))) :ruleset always-run)

(function list5 (Expr Expr Expr Expr Expr) ListExpr)
(rewrite (list5 a b c d e)
         (Cons a (Cons b (Cons c (Cons d (Cons e (Nil)))))) :ruleset always-run)

(function IgnoreFirst (IdSort Expr Expr) Expr)
(rewrite (IgnoreFirst id a b)
         (Get
             (All id (Sequential) (Cons a (Cons b (Nil))))
             1)
         :ruleset always-run)

(function NewLoop (IdSort Expr Expr) Expr :unextractable)
(rewrite (NewLoop id in out)
         (Loop id in (DeepCopyExpr out id))
         :ruleset always-run)

(function NewLet (IdSort Expr Expr) Expr)
(rewrite (NewLet id in out)
         (Let id in (DeepCopyExpr out id))
         :ruleset always-run)

(function ListExpr-length (ListExpr) i64)
(function ListExpr-ith (ListExpr i64) Expr :unextractable)
(function ListExpr-suffix (ListExpr i64) ListExpr :unextractable)
(function Append (ListExpr Expr) ListExpr :unextractable)

(rule ((All id order top)) ((union (ListExpr-suffix top 0) top)) :ruleset always-run)

(rule ((= (ListExpr-suffix top n) (Cons hd tl)))
    ((union (ListExpr-ith top n) hd)
     (union (ListExpr-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (ListExpr-suffix list n) (Nil)))
    ((set (ListExpr-length list) n)) :ruleset always-run)

(rewrite (Append (Cons a b) e)
    (Cons a (Append b e))
    :ruleset always-run)
(rewrite (Append (Nil) e)
    (Cons e (Nil))
    :ruleset always-run)

(function Expr-size (Expr) i64 :merge (min old new))
(function ListExpr-size (ListExpr) i64 :merge (min old new))

(function TypeList-length (TypeList) i64)
(function TypeList-ith (TypeList i64) Type :unextractable)
(function TypeList-suffix (TypeList i64) TypeList :unextractable)

(rule ((TupleT tylist)) ((union (TypeList-suffix tylist 0) tylist)) :ruleset always-run)

(rule ((= (TypeList-suffix top n) (TCons hd tl)))
    ((union (TypeList-ith top n) hd)
     (union (TypeList-suffix top (+ n 1)) tl)) :ruleset always-run)

(rule ((= (TypeList-suffix list n) (TNil)))
    ((set (TypeList-length list) n)) :ruleset always-run)
(rule ((= expr (Num _id _n))) ((set (Expr-size expr) 1))  :ruleset always-run)
(rule ((= expr (Boolean _id _b))) ((set (Expr-size expr) 1))  :ruleset always-run)
(rule ((= expr (Add _x _y)) (= sum (+ (Expr-size _x) (Expr-size _y)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (Sub _x _y)) (= sum (+ (Expr-size _x) (Expr-size _y)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (Mul _x _y)) (= sum (+ (Expr-size _x) (Expr-size _y)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (LessThan _x _y)) (= sum (+ (Expr-size _x) (Expr-size _y)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (And _x _y)) (= sum (+ (Expr-size _x) (Expr-size _y)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (Or _x _y)) (= sum (+ (Expr-size _x) (Expr-size _y)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (Not _x)) (= n (Expr-size _x))) ((set (Expr-size expr) (+ 1 n))) :ruleset always-run)
(rule ((= expr (Get tup i)) (= n (Expr-size tup))) ((set (Expr-size expr) n))  :ruleset always-run)
(rule ((= expr (Print _printee)) (= n (Expr-size _printee))) ((set (Expr-size expr) (+ 1 n))) :ruleset always-run)
(rule ((= expr (Read _addr _type)) (= n (Expr-size _addr))) ((set (Expr-size expr) (+ 1 n))) :ruleset always-run)
(rule ((= expr (Write _addr _data)) (= sum (+ (Expr-size _addr) (Expr-size _data)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (All id ord list)) (= n (ListExpr-size list))) ((set (Expr-size expr) n))  :ruleset always-run)
(rule ((= expr (Switch _pred _branches)) (= sum (+ (Expr-size _pred) (ListExpr-size _branches)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (Loop _id _in _pred-and-output)) (= sum (+ (Expr-size _in) (Expr-size _pred-and-output)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (Let _id _in _out)) (= sum (+ (Expr-size _in) (Expr-size _out)))) ((set (Expr-size expr) (+ 1 sum))) :ruleset always-run)
(rule ((= expr (Arg _id))) ((set (Expr-size expr) 1))  :ruleset always-run)
(rule ((= expr (Call _f _arg)) (= n (Expr-size _arg))) ((set (Expr-size expr) (+ 1 n))) :ruleset always-run)
(rule ((= list (Cons expr xs)) (= a (Expr-size expr)) (= b (ListExpr-size xs))) ((set (ListExpr-size list) (+ a b))) :ruleset always-run)
(rule ((Nil)) ((set (ListExpr-size (Nil)) 0))  :ruleset always-run)
(relation ExprHasRefId (Expr IdSort))
(rule ((ExprHasRefId x id1)
                (ExprHasRefId x id2)
                (!= id1 id2))
                ((panic "Ref ids don't match"))
                :ruleset error-checking)
(relation ListExprHasRefId (ListExpr IdSort))
(rule ((ListExprHasRefId x id1)
                (ListExprHasRefId x id2)
                (!= id1 id2))
                ((panic "Ref ids don't match"))
                :ruleset error-checking)
(rule ((Num _id _n) (ExprIsValid (Num _id _n)))
                       ((ExprHasRefId (Num _id _n) _id))
                       :ruleset always-run)
(rule ((Boolean _id _b) (ExprIsValid (Boolean _id _b)))
                       ((ExprHasRefId (Boolean _id _b) _id))
                       :ruleset always-run)
(rule ((Add _x _y) (ExprHasRefId _x ref-id) (ExprIsValid (Add _x _y)))
                       ((ExprHasRefId (Add _x _y) ref-id))
                       :ruleset always-run)
(rule ((Add _x _y) (ExprHasRefId _y ref-id) (ExprIsValid (Add _x _y)))
                       ((ExprHasRefId (Add _x _y) ref-id))
                       :ruleset always-run)
(rule ((Sub _x _y) (ExprHasRefId _x ref-id) (ExprIsValid (Sub _x _y)))
                       ((ExprHasRefId (Sub _x _y) ref-id))
                       :ruleset always-run)
(rule ((Sub _x _y) (ExprHasRefId _y ref-id) (ExprIsValid (Sub _x _y)))
                       ((ExprHasRefId (Sub _x _y) ref-id))
                       :ruleset always-run)
(rule ((Mul _x _y) (ExprHasRefId _x ref-id) (ExprIsValid (Mul _x _y)))
                       ((ExprHasRefId (Mul _x _y) ref-id))
                       :ruleset always-run)
(rule ((Mul _x _y) (ExprHasRefId _y ref-id) (ExprIsValid (Mul _x _y)))
                       ((ExprHasRefId (Mul _x _y) ref-id))
                       :ruleset always-run)
(rule ((LessThan _x _y) (ExprHasRefId _x ref-id) (ExprIsValid (LessThan _x _y)))
                       ((ExprHasRefId (LessThan _x _y) ref-id))
                       :ruleset always-run)
(rule ((LessThan _x _y) (ExprHasRefId _y ref-id) (ExprIsValid (LessThan _x _y)))
                       ((ExprHasRefId (LessThan _x _y) ref-id))
                       :ruleset always-run)
(rule ((And _x _y) (ExprHasRefId _x ref-id) (ExprIsValid (And _x _y)))
                       ((ExprHasRefId (And _x _y) ref-id))
                       :ruleset always-run)
(rule ((And _x _y) (ExprHasRefId _y ref-id) (ExprIsValid (And _x _y)))
                       ((ExprHasRefId (And _x _y) ref-id))
                       :ruleset always-run)
(rule ((Or _x _y) (ExprHasRefId _x ref-id) (ExprIsValid (Or _x _y)))
                       ((ExprHasRefId (Or _x _y) ref-id))
                       :ruleset always-run)
(rule ((Or _x _y) (ExprHasRefId _y ref-id) (ExprIsValid (Or _x _y)))
                       ((ExprHasRefId (Or _x _y) ref-id))
                       :ruleset always-run)
(rule ((Not _x) (ExprHasRefId _x ref-id) (ExprIsValid (Not _x)))
                       ((ExprHasRefId (Not _x) ref-id))
                       :ruleset always-run)
(rule ((Get _tup _i) (ExprHasRefId _tup ref-id) (ExprIsValid (Get _tup _i)))
                       ((ExprHasRefId (Get _tup _i) ref-id))
                       :ruleset always-run)
(rule ((Print _printee) (ExprHasRefId _printee ref-id) (ExprIsValid (Print _printee)))
                       ((ExprHasRefId (Print _printee) ref-id))
                       :ruleset always-run)
(rule ((Read _addr _type) (ExprHasRefId _addr ref-id) (ExprIsValid (Read _addr _type)))
                       ((ExprHasRefId (Read _addr _type) ref-id))
                       :ruleset always-run)
(rule ((Write _addr _data) (ExprHasRefId _addr ref-id) (ExprIsValid (Write _addr _data)))
                       ((ExprHasRefId (Write _addr _data) ref-id))
                       :ruleset always-run)
(rule ((Write _addr _data) (ExprHasRefId _data ref-id) (ExprIsValid (Write _addr _data)))
                       ((ExprHasRefId (Write _addr _data) ref-id))
                       :ruleset always-run)
(rule ((All _id _order _exprs) (ExprIsValid (All _id _order _exprs)))
                       ((ExprHasRefId (All _id _order _exprs) _id))
                       :ruleset always-run)
(rule ((All _id _order _exprs) (ListExprHasRefId _exprs ref-id) (ExprIsValid (All _id _order _exprs)))
                       ((ExprHasRefId (All _id _order _exprs) ref-id))
                       :ruleset always-run)
(rule ((Switch _pred _branches) (ExprHasRefId _pred ref-id) (ExprIsValid (Switch _pred _branches)))
                       ((ExprHasRefId (Switch _pred _branches) ref-id))
                       :ruleset always-run)
(rule ((Switch _pred _branches) (ListExprHasRefId _branches ref-id) (ExprIsValid (Switch _pred _branches)))
                       ((ExprHasRefId (Switch _pred _branches) ref-id))
                       :ruleset always-run)
(rule ((Loop _id _in _pred-and-output) (ExprHasRefId _in ref-id) (ExprIsValid (Loop _id _in _pred-and-output)))
                       ((ExprHasRefId (Loop _id _in _pred-and-output) ref-id))
                       :ruleset always-run)
(rule ((Let _id _in _out) (ExprHasRefId _in ref-id) (ExprIsValid (Let _id _in _out)))
                       ((ExprHasRefId (Let _id _in _out) ref-id))
                       :ruleset always-run)
(rule ((Arg _id) (ExprIsValid (Arg _id)))
                       ((ExprHasRefId (Arg _id) _id))
                       :ruleset always-run)
(rule ((Call _f _arg) (ExprHasRefId _arg ref-id) (ExprIsValid (Call _f _arg)))
                       ((ExprHasRefId (Call _f _arg) ref-id))
                       :ruleset always-run)
(rule ((Cons _hd _tl) (ExprHasRefId _hd ref-id) (ListExprIsValid (Cons _hd _tl)))
                       ((ListExprHasRefId (Cons _hd _tl) ref-id))
                       :ruleset always-run)
(rule ((Cons _hd _tl) (ListExprHasRefId _tl ref-id) (ListExprIsValid (Cons _hd _tl)))
                       ((ListExprHasRefId (Cons _hd _tl) ref-id))
                       :ruleset always-run)

(ruleset simple-pure)
; !(a or b) ==> !a and !b
(rewrite (Not (Or A B)) (And (Not A) (Not B)) :ruleset simple-pure)

; !(a and b) ==> !a or !b
(rewrite (Not (And A B)) (Or (Not A) (Not B)) :ruleset simple-pure)

; !! a ==> a
(rewrite (Not (Not A)) A :ruleset simple-pure)


(ruleset function-inlining)

(rule
    (
        (= call (Call f arg))
        (Function f out)
        (ExprIsValid call)
    )
    (
        (let new-id (Id (i64-fresh!)))
        (union
            call
            (NewLet new-id arg out)
        )
    )
:ruleset function-inlining)
(ruleset interval-analysis)

(datatype Interval
  (BoolI bool bool)
  (IntI i64 i64)
  (interval-intersect Interval Interval)
  (interval-union Interval Interval))

; Interval combinators
(rewrite (interval-intersect (IntI la ha) (IntI lb hb))
         (IntI (max la lb) (min ha hb))
         :ruleset interval-analysis)
(rewrite (interval-union (IntI la ha) (IntI lb hb))
         (IntI (min la lb) (max ha hb))
         :ruleset interval-analysis)
(rewrite (interval-intersect (BoolI la ha) (BoolI lb hb))
         (BoolI (or la lb) (and ha hb))
         :ruleset interval-analysis)
(rewrite (interval-union (BoolI la ha) (BoolI lb hb))
         (BoolI (and la lb) (or ha hb))
         :ruleset interval-analysis)


; Interval Table
(function ival (Expr) Interval
  :merge (interval-intersect old new))

; Consts
(rule (
       (= lhs (Num id value))
       (ExprIsValid lhs)
      )
      ((set (ival lhs) (IntI value value)))
      :ruleset interval-analysis)
(rule (
       (= lhs (Boolean id value))
       (ExprIsValid lhs)
      )
      ((set (ival lhs) (BoolI value value)))
      :ruleset interval-analysis)      

; Constant folding from interval analysis
(rule (
        (= (IntI x x) (ival expr))
        (ExprIsPure expr)
        (ExprHasRefId expr id)
      )
      ((union expr (Num id x)))
      :ruleset interval-analysis)
(rule (
        (= (BoolI x x) (ival expr))
        (ExprIsPure expr)
        (ExprHasRefId expr id)
      )
      ((union expr (Boolean id x)))
      :ruleset interval-analysis)

; < a b interval is (< ha lb) (< la hb)
(rule (
       (= lhs (LessThan a b))
       (ExprIsValid lhs)
       (= (IntI la ha) (ival a))
       (= (IntI lb hb) (ival b))
      )
      ((set (ival lhs) (BoolI (bool-< ha lb) (bool-< la hb))))
      :ruleset interval-analysis)

; + a b interval is (+ la lb) (+ ha hb)
(rule (
       (= lhs (Add a b))
       (ExprIsValid lhs)
       (= (IntI la ha) (ival a))
       (= (IntI lb hb) (ival b))
      )
      ((set (ival lhs) (IntI (+ la lb) (+ ha hb))))
      :ruleset interval-analysis)

; Switch interval is union of branch intervals
(rule (
       (= lhs (Switch pred (Cons A (Cons B (Nil)))))
       (ExprIsValid lhs)
       (= a-ival (ival A))
       (= b-ival (ival B))
      )
      ((set (ival lhs) (interval-union a-ival b-ival)))
      :ruleset interval-analysis)

(ruleset ivt)

; IVT inverts ifs and loops when their predicates match, e.g.
;
;        do {
;           if (x) Y else Z
;        } while(x);
; 
;        =>
; 
;        if (x) {
;            do {
;                Y
;            } while (x);
;        } else {
;            Z
;        }
;
; The rules here assume that the entire loop body _is_ an if. This of course
; will not match most loops directly: we rely on optimizations that nest
; computations inside of an if for this rule to fire.

;                     switch  inputs output id
(function LiftSwitch (Expr    Expr   IdSort)     Expr)
(rewrite (LiftSwitch inner subst outer-id) 
         (DeepCopyExpr (SubstExpr inner subst) outer-id) :ruleset always-run)

; Create demand
(rule ((= loop (Loop id in out))
       (ExprHasRefId loop outer-id)
       (ExprIsValid loop)
       (= out (All id ord (Cons pred (Cons switch (Nil)))))
       (= switch (Switch pred branches))
       (ExprIsPure pred))
      ((LiftSwitch switch in outer-id)) :ruleset ivt)

; Apply the rule
(rule ((= loop (Loop id in out))
       (ExprIsValid loop)
       (= out (All id ord (Cons pred (Cons switch (Nil)))))
       (= switch (Switch pred (Cons thn* (Cons els* (Nil)))))
       ; NB: we don't constrain 'outer-id' here in part because there can only
       ; be _one_ outer-id that is referenced by it. (See the panic in the rules
       ; for *HasRefId).
       (= (Switch pred_ (Cons thn (Cons els (Nil)))) (LiftSwitch switch in outer-id)))
      ((let new-id (Id (i64-fresh!)))
       (let inner (NewLoop new-id in (All new-id ord (Pair pred thn*))))
       (let outer (Switch pred_ (Cons inner (Cons els (Nil)))))
       (union loop outer)) :ruleset ivt)
(ruleset switch-rewrites)

        ; Constant condition elimination
        (rewrite (Switch (Boolean id true) (Cons A (Cons B (Nil))))
                 B
                 :when ((ExprIsValid (Switch (Boolean id true) (Cons A (Cons B (Nil))))))
                 :ruleset switch-rewrites)
        (rewrite (Switch (Boolean id false) (Cons A (Cons B (Nil))))
                 A
                 :when ((ExprIsValid (Switch (Boolean id false) (Cons A (Cons B (Nil))))))
                 :ruleset switch-rewrites)
    
        ; (if E then S1 else S2); S3 ==> if E then S1;S3 else S2;S3
        (rewrite (All id ord (Cons (Switch e (Cons S1 (Cons S2 (Nil)))) S3))
                 (Switch e (Cons (All id ord (Cons S1 S3)) (Cons (All id ord (Cons S2 S3)) (Nil))))
                 :ruleset switch-rewrites)
    
        (rewrite (Switch (And a b) (Cons A (Cons B (Nil)))) (Switch a (Pair (Switch b (Pair A B)) B)) :when ((ExprIsPure b) (ExprIsValid (Switch (And a b) (Cons A (Cons B (Nil))))))
                                    :ruleset switch-rewrites)
                 (rewrite (Switch a (Pair (Switch b (Pair A B)) B)) (Switch (And a b) (Cons A (Cons B (Nil)))) :when ((ExprIsPure b) (ExprIsValid (Switch a (Pair (Switch b (Pair A B)) B))))
                                    :ruleset switch-rewrites)
(rewrite (Switch (Or a b) (Cons A (Cons B (Nil)))) (Switch a (Pair A (Switch b (Pair A B)))) :when ((ExprIsPure b) (ExprIsValid (Switch (Or a b) (Cons A (Cons B (Nil))))))
                                    :ruleset switch-rewrites)
                 (rewrite (Switch a (Pair A (Switch b (Pair A B)))) (Switch (Or a b) (Cons A (Cons B (Nil)))) :when ((ExprIsPure b) (ExprIsValid (Switch a (Pair A (Switch b (Pair A B))))))
                                    :ruleset switch-rewrites)
(ruleset type-analysis)

(relation HasType (Expr Type))

; Primitives
(rule ((Num id n))
      ((HasType (Num id n) (IntT)))
      :ruleset type-analysis)

(rule ((Boolean id b))
      ((HasType (Boolean id b) (BoolT)))
      :ruleset type-analysis)

; Pure Op Compute
(rule (
       (Add x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (Add x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (Sub x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (Sub x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (Mul x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (Mul x y) (IntT))
      )
      :ruleset type-analysis)
(rule (
       (LessThan x y)
       (HasType x (IntT))
       (HasType y (IntT))
      )
      (
       (HasType (LessThan x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (And x y)
       (HasType x (BoolT))
       (HasType y (BoolT))
      )
      (
       (HasType (And x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (Or x y)
       (HasType x (BoolT))
       (HasType y (BoolT))
      )
      (
       (HasType (Or x y) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (Not x)
       (HasType x (BoolT))
      )
      (
       (HasType (Not x) (BoolT))
      )
      :ruleset type-analysis)
(rule (
       (Get e n)
       (HasType e (TupleT tylist))
      )
      ((HasType (Get e n) (TypeList-ith tylist n)))
      :ruleset type-analysis)

; Effectful Ops
(rule ((Print e))
      ((HasType (Print e) (TupleT (TNil))))
      :ruleset type-analysis)
(rule ((= lhs (Read addr ty)))
      ((HasType lhs ty))
      :ruleset type-analysis)
(rule ((= lhs (Write addr val)))
      ((HasType lhs (UnitT)))
      :ruleset type-analysis)

; Switch 
; if the condition is a boolean, it must have exactly two branches
(rule (
       (= switch (Switch cond (Cons A (Cons B (Nil)))))
       (HasType cond (BoolT))
       (HasType A ty)
       (HasType B ty)
      )
      ((HasType switch ty))
      :ruleset type-analysis)

; Otherwise, the condition must be an integer, and we can have any number of branches.

(rule ((Switch cond (Cons branch rest)))
      ((Switch cond rest))                ; peel off a branch for type checking
      :ruleset type-analysis)

; base case- single branch switch has type of branch
(rule (
       (Switch cond (Cons branch (Nil)))
       ; boolean condition handled above, now we must have an integer condition
       (HasType cond (IntT))
       (HasType branch ty)
      )
      ((HasType (Switch cond (Cons branch (Nil))) ty))
      :ruleset type-analysis)
; recursive case
(rule (
       (Switch cond (Cons branch rest))
       (HasType (Switch cond rest) ty)
       ; make sure the condition is an integer
       ; (prevents us from typing boolean switches with >2 branches)
       (HasType cond (IntT))
       (HasType branch ty)
      )
      ((HasType (Switch cond (Cons branch rest)) ty))
      :ruleset type-analysis)

; Sequencing
(rule ((All id ord (Cons hd tl)))
      ((All id ord tl))                ; peel off a layer for type checking
      :ruleset type-analysis)
; base case: Nil
(rule ((All id ord (Nil)))
      ((HasType (All id ord (Nil)) (TupleT (TNil))))
      :ruleset type-analysis)
; rec case
(rule (
       (All id ord (Cons hd tl))
       (HasType hd ty)
       (HasType (All id ord tl) (TupleT tylist))
      )
      ((HasType (All id ord (Cons hd tl)) (TupleT (TCons ty tylist))))
      :ruleset type-analysis)

; If an expr has two different types, panic
(rule (
       (HasType e t1)
       (HasType e t2)
       (!= t1 t2)
      )
      ((panic "Type Mismatch!"))
      :ruleset type-analysis)


; Lets

(rule (
       (Let id in out)
       (HasType in ty)
      )
      (
       (HasType (Arg id) ty) ; assert the let's argument has type ty in the let's context
      )
      :ruleset type-analysis)

(rule (
       (Let id in out)
       (HasType out ty)
      )
      ((HasType (Let id in out) ty))
      :ruleset type-analysis)

; Loops

(rule (
       (Loop id in pred-out)
       (HasType in ty)
      )
      (
       (HasType (Arg id) ty) ; assert the argument has type ty in the loop's context
      )
      :ruleset type-analysis)

(rule (
       (Loop id in pred-out)
       (HasType in ty) ; input type
       ; pred-out must be a two-element tuple.
       ; pred must be boolean, output type must match input type
       (HasType pred-out (TupleT (TCons (BoolT) (TCons ty (TNil)))))
      )
      ((HasType (Loop id in pred-out) ty)) ; whole loop has type of output
      :ruleset type-analysis)

(rule (
       (Loop id in pred-out)
       (HasType pred-out (TupleT (TCons pred-ty rest)))
       (!= pred-ty (BoolT))
      )
      ((panic "Loop predicate was not a boolean"))
      :ruleset type-analysis)

(rule (
       (Loop id in pred-out)
       (HasType in in-ty)
       (HasType pred-out (TupleT lst))
       (!= (TypeList-length lst) 2)
      )
      ((panic "Loop did not get two arguments (predicate and output)"))
      :ruleset type-analysis)

        (ruleset conditional-invariant-code-motion)
        (relation DemandSameIgnoring (ListExpr))
        (rule ((DemandSameIgnoring (Cons hd tl))) ((DemandSameIgnoring tl)) :ruleset always-run)
        (rule ((Switch pred exprs)) ((DemandSameIgnoring exprs)) :ruleset always-run)



                ; Compute SameAddIgnoring-x, which detects opportunities for lifting
                ; Adds through control flow when only the x field varies
                (relation SameAddIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Add e1 _y) (Nil))))
                      ((SameAddIgnoring-x (Cons (Add e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Add e1 _y) (Cons (Add e2 _y) rest)))
                       (SameAddIgnoring-x (Cons (Add e2 _y) rest)))
                      ((SameAddIgnoring-x (Cons (Add e1 _y) (Cons (Add e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of Adds, return a list of each Add's x field
                (function Map-Add-x (ListExpr) ListExpr)
                (rewrite (Map-Add-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Add-x (Cons (Add e1 _y) rest))
                         (Cons e1 (Map-Add-x rest))
                         :ruleset always-run)

                ; Lift Add when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameAddIgnoring-x exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Add e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (Add (Switch pred (Map-Add-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameAddIgnoring-y, which detects opportunities for lifting
                ; Adds through control flow when only the y field varies
                (relation SameAddIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Add _x e1) (Nil))))
                      ((SameAddIgnoring-y (Cons (Add _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Add _x e1) (Cons (Add _x e2) rest)))
                       (SameAddIgnoring-y (Cons (Add _x e2) rest)))
                      ((SameAddIgnoring-y (Cons (Add _x e1) (Cons (Add _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of Adds, return a list of each Add's y field
                (function Map-Add-y (ListExpr) ListExpr)
                (rewrite (Map-Add-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Add-y (Cons (Add _x e1) rest))
                         (Cons e1 (Map-Add-y rest))
                         :ruleset always-run)

                ; Lift Add when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameAddIgnoring-y exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Add _x e1) rest)))
                      ((union (Switch pred exprs)
                              (Add _x (Switch pred (Map-Add-y exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameSubIgnoring-x, which detects opportunities for lifting
                ; Subs through control flow when only the x field varies
                (relation SameSubIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Sub e1 _y) (Nil))))
                      ((SameSubIgnoring-x (Cons (Sub e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Sub e1 _y) (Cons (Sub e2 _y) rest)))
                       (SameSubIgnoring-x (Cons (Sub e2 _y) rest)))
                      ((SameSubIgnoring-x (Cons (Sub e1 _y) (Cons (Sub e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of Subs, return a list of each Sub's x field
                (function Map-Sub-x (ListExpr) ListExpr)
                (rewrite (Map-Sub-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Sub-x (Cons (Sub e1 _y) rest))
                         (Cons e1 (Map-Sub-x rest))
                         :ruleset always-run)

                ; Lift Sub when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameSubIgnoring-x exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Sub e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (Sub (Switch pred (Map-Sub-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameSubIgnoring-y, which detects opportunities for lifting
                ; Subs through control flow when only the y field varies
                (relation SameSubIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Sub _x e1) (Nil))))
                      ((SameSubIgnoring-y (Cons (Sub _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Sub _x e1) (Cons (Sub _x e2) rest)))
                       (SameSubIgnoring-y (Cons (Sub _x e2) rest)))
                      ((SameSubIgnoring-y (Cons (Sub _x e1) (Cons (Sub _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of Subs, return a list of each Sub's y field
                (function Map-Sub-y (ListExpr) ListExpr)
                (rewrite (Map-Sub-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Sub-y (Cons (Sub _x e1) rest))
                         (Cons e1 (Map-Sub-y rest))
                         :ruleset always-run)

                ; Lift Sub when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameSubIgnoring-y exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Sub _x e1) rest)))
                      ((union (Switch pred exprs)
                              (Sub _x (Switch pred (Map-Sub-y exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameMulIgnoring-x, which detects opportunities for lifting
                ; Muls through control flow when only the x field varies
                (relation SameMulIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Mul e1 _y) (Nil))))
                      ((SameMulIgnoring-x (Cons (Mul e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Mul e1 _y) (Cons (Mul e2 _y) rest)))
                       (SameMulIgnoring-x (Cons (Mul e2 _y) rest)))
                      ((SameMulIgnoring-x (Cons (Mul e1 _y) (Cons (Mul e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of Muls, return a list of each Mul's x field
                (function Map-Mul-x (ListExpr) ListExpr)
                (rewrite (Map-Mul-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Mul-x (Cons (Mul e1 _y) rest))
                         (Cons e1 (Map-Mul-x rest))
                         :ruleset always-run)

                ; Lift Mul when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameMulIgnoring-x exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Mul e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (Mul (Switch pred (Map-Mul-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameMulIgnoring-y, which detects opportunities for lifting
                ; Muls through control flow when only the y field varies
                (relation SameMulIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Mul _x e1) (Nil))))
                      ((SameMulIgnoring-y (Cons (Mul _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Mul _x e1) (Cons (Mul _x e2) rest)))
                       (SameMulIgnoring-y (Cons (Mul _x e2) rest)))
                      ((SameMulIgnoring-y (Cons (Mul _x e1) (Cons (Mul _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of Muls, return a list of each Mul's y field
                (function Map-Mul-y (ListExpr) ListExpr)
                (rewrite (Map-Mul-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Mul-y (Cons (Mul _x e1) rest))
                         (Cons e1 (Map-Mul-y rest))
                         :ruleset always-run)

                ; Lift Mul when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameMulIgnoring-y exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Mul _x e1) rest)))
                      ((union (Switch pred exprs)
                              (Mul _x (Switch pred (Map-Mul-y exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameLessThanIgnoring-x, which detects opportunities for lifting
                ; LessThans through control flow when only the x field varies
                (relation SameLessThanIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (LessThan e1 _y) (Nil))))
                      ((SameLessThanIgnoring-x (Cons (LessThan e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (LessThan e1 _y) (Cons (LessThan e2 _y) rest)))
                       (SameLessThanIgnoring-x (Cons (LessThan e2 _y) rest)))
                      ((SameLessThanIgnoring-x (Cons (LessThan e1 _y) (Cons (LessThan e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of LessThans, return a list of each LessThan's x field
                (function Map-LessThan-x (ListExpr) ListExpr)
                (rewrite (Map-LessThan-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-LessThan-x (Cons (LessThan e1 _y) rest))
                         (Cons e1 (Map-LessThan-x rest))
                         :ruleset always-run)

                ; Lift LessThan when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameLessThanIgnoring-x exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (LessThan e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (LessThan (Switch pred (Map-LessThan-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameLessThanIgnoring-y, which detects opportunities for lifting
                ; LessThans through control flow when only the y field varies
                (relation SameLessThanIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (LessThan _x e1) (Nil))))
                      ((SameLessThanIgnoring-y (Cons (LessThan _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (LessThan _x e1) (Cons (LessThan _x e2) rest)))
                       (SameLessThanIgnoring-y (Cons (LessThan _x e2) rest)))
                      ((SameLessThanIgnoring-y (Cons (LessThan _x e1) (Cons (LessThan _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of LessThans, return a list of each LessThan's y field
                (function Map-LessThan-y (ListExpr) ListExpr)
                (rewrite (Map-LessThan-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-LessThan-y (Cons (LessThan _x e1) rest))
                         (Cons e1 (Map-LessThan-y rest))
                         :ruleset always-run)

                ; Lift LessThan when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameLessThanIgnoring-y exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (LessThan _x e1) rest)))
                      ((union (Switch pred exprs)
                              (LessThan _x (Switch pred (Map-LessThan-y exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameAndIgnoring-x, which detects opportunities for lifting
                ; Ands through control flow when only the x field varies
                (relation SameAndIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (And e1 _y) (Nil))))
                      ((SameAndIgnoring-x (Cons (And e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (And e1 _y) (Cons (And e2 _y) rest)))
                       (SameAndIgnoring-x (Cons (And e2 _y) rest)))
                      ((SameAndIgnoring-x (Cons (And e1 _y) (Cons (And e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of Ands, return a list of each And's x field
                (function Map-And-x (ListExpr) ListExpr)
                (rewrite (Map-And-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-And-x (Cons (And e1 _y) rest))
                         (Cons e1 (Map-And-x rest))
                         :ruleset always-run)

                ; Lift And when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameAndIgnoring-x exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (And e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (And (Switch pred (Map-And-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameAndIgnoring-y, which detects opportunities for lifting
                ; Ands through control flow when only the y field varies
                (relation SameAndIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (And _x e1) (Nil))))
                      ((SameAndIgnoring-y (Cons (And _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (And _x e1) (Cons (And _x e2) rest)))
                       (SameAndIgnoring-y (Cons (And _x e2) rest)))
                      ((SameAndIgnoring-y (Cons (And _x e1) (Cons (And _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of Ands, return a list of each And's y field
                (function Map-And-y (ListExpr) ListExpr)
                (rewrite (Map-And-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-And-y (Cons (And _x e1) rest))
                         (Cons e1 (Map-And-y rest))
                         :ruleset always-run)

                ; Lift And when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameAndIgnoring-y exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (And _x e1) rest)))
                      ((union (Switch pred exprs)
                              (And _x (Switch pred (Map-And-y exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameOrIgnoring-x, which detects opportunities for lifting
                ; Ors through control flow when only the x field varies
                (relation SameOrIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Or e1 _y) (Nil))))
                      ((SameOrIgnoring-x (Cons (Or e1 _y) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Or e1 _y) (Cons (Or e2 _y) rest)))
                       (SameOrIgnoring-x (Cons (Or e2 _y) rest)))
                      ((SameOrIgnoring-x (Cons (Or e1 _y) (Cons (Or e2 _y) rest))))
                      :ruleset always-run)

                ; Given a list of Ors, return a list of each Or's x field
                (function Map-Or-x (ListExpr) ListExpr)
                (rewrite (Map-Or-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Or-x (Cons (Or e1 _y) rest))
                         (Cons e1 (Map-Or-x rest))
                         :ruleset always-run)

                ; Lift Or when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameOrIgnoring-x exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Or e1 _y) rest)))
                      ((union (Switch pred exprs)
                              (Or (Switch pred (Map-Or-x exprs)) _y)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameOrIgnoring-y, which detects opportunities for lifting
                ; Ors through control flow when only the y field varies
                (relation SameOrIgnoring-y (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Or _x e1) (Nil))))
                      ((SameOrIgnoring-y (Cons (Or _x e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Or _x e1) (Cons (Or _x e2) rest)))
                       (SameOrIgnoring-y (Cons (Or _x e2) rest)))
                      ((SameOrIgnoring-y (Cons (Or _x e1) (Cons (Or _x e2) rest))))
                      :ruleset always-run)

                ; Given a list of Ors, return a list of each Or's y field
                (function Map-Or-y (ListExpr) ListExpr)
                (rewrite (Map-Or-y (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Or-y (Cons (Or _x e1) rest))
                         (Cons e1 (Map-Or-y rest))
                         :ruleset always-run)

                ; Lift Or when only y varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameOrIgnoring-y exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Or _x e1) rest)))
                      ((union (Switch pred exprs)
                              (Or _x (Switch pred (Map-Or-y exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameNotIgnoring-x, which detects opportunities for lifting
                ; Nots through control flow when only the x field varies
                (relation SameNotIgnoring-x (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Not e1) (Nil))))
                      ((SameNotIgnoring-x (Cons (Not e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Not e1) (Cons (Not e2) rest)))
                       (SameNotIgnoring-x (Cons (Not e2) rest)))
                      ((SameNotIgnoring-x (Cons (Not e1) (Cons (Not e2) rest))))
                      :ruleset always-run)

                ; Given a list of Nots, return a list of each Not's x field
                (function Map-Not-x (ListExpr) ListExpr)
                (rewrite (Map-Not-x (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Not-x (Cons (Not e1) rest))
                         (Cons e1 (Map-Not-x rest))
                         :ruleset always-run)

                ; Lift Not when only x varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameNotIgnoring-x exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Not e1) rest)))
                      ((union (Switch pred exprs)
                              (Not (Switch pred (Map-Not-x exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameGetIgnoring-tup, which detects opportunities for lifting
                ; Gets through control flow when only the tup field varies
                (relation SameGetIgnoring-tup (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Get e1 _i) (Nil))))
                      ((SameGetIgnoring-tup (Cons (Get e1 _i) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Get e1 _i) (Cons (Get e2 _i) rest)))
                       (SameGetIgnoring-tup (Cons (Get e2 _i) rest)))
                      ((SameGetIgnoring-tup (Cons (Get e1 _i) (Cons (Get e2 _i) rest))))
                      :ruleset always-run)

                ; Given a list of Gets, return a list of each Get's tup field
                (function Map-Get-tup (ListExpr) ListExpr)
                (rewrite (Map-Get-tup (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Get-tup (Cons (Get e1 _i) rest))
                         (Cons e1 (Map-Get-tup rest))
                         :ruleset always-run)

                ; Lift Get when only tup varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameGetIgnoring-tup exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Get e1 _i) rest)))
                      ((union (Switch pred exprs)
                              (Get (Switch pred (Map-Get-tup exprs)) _i)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SamePrintIgnoring-printee, which detects opportunities for lifting
                ; Prints through control flow when only the printee field varies
                (relation SamePrintIgnoring-printee (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Print e1) (Nil))))
                      ((SamePrintIgnoring-printee (Cons (Print e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Print e1) (Cons (Print e2) rest)))
                       (SamePrintIgnoring-printee (Cons (Print e2) rest)))
                      ((SamePrintIgnoring-printee (Cons (Print e1) (Cons (Print e2) rest))))
                      :ruleset always-run)

                ; Given a list of Prints, return a list of each Print's printee field
                (function Map-Print-printee (ListExpr) ListExpr)
                (rewrite (Map-Print-printee (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Print-printee (Cons (Print e1) rest))
                         (Cons e1 (Map-Print-printee rest))
                         :ruleset always-run)

                ; Lift Print when only printee varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SamePrintIgnoring-printee exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Print e1) rest)))
                      ((union (Switch pred exprs)
                              (Print (Switch pred (Map-Print-printee exprs)))))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameReadIgnoring-addr, which detects opportunities for lifting
                ; Reads through control flow when only the addr field varies
                (relation SameReadIgnoring-addr (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Read e1 _type) (Nil))))
                      ((SameReadIgnoring-addr (Cons (Read e1 _type) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Read e1 _type) (Cons (Read e2 _type) rest)))
                       (SameReadIgnoring-addr (Cons (Read e2 _type) rest)))
                      ((SameReadIgnoring-addr (Cons (Read e1 _type) (Cons (Read e2 _type) rest))))
                      :ruleset always-run)

                ; Given a list of Reads, return a list of each Read's addr field
                (function Map-Read-addr (ListExpr) ListExpr)
                (rewrite (Map-Read-addr (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Read-addr (Cons (Read e1 _type) rest))
                         (Cons e1 (Map-Read-addr rest))
                         :ruleset always-run)

                ; Lift Read when only addr varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameReadIgnoring-addr exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Read e1 _type) rest)))
                      ((union (Switch pred exprs)
                              (Read (Switch pred (Map-Read-addr exprs)) _type)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameWriteIgnoring-addr, which detects opportunities for lifting
                ; Writes through control flow when only the addr field varies
                (relation SameWriteIgnoring-addr (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Write e1 _data) (Nil))))
                      ((SameWriteIgnoring-addr (Cons (Write e1 _data) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Write e1 _data) (Cons (Write e2 _data) rest)))
                       (SameWriteIgnoring-addr (Cons (Write e2 _data) rest)))
                      ((SameWriteIgnoring-addr (Cons (Write e1 _data) (Cons (Write e2 _data) rest))))
                      :ruleset always-run)

                ; Given a list of Writes, return a list of each Write's addr field
                (function Map-Write-addr (ListExpr) ListExpr)
                (rewrite (Map-Write-addr (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Write-addr (Cons (Write e1 _data) rest))
                         (Cons e1 (Map-Write-addr rest))
                         :ruleset always-run)

                ; Lift Write when only addr varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameWriteIgnoring-addr exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Write e1 _data) rest)))
                      ((union (Switch pred exprs)
                              (Write (Switch pred (Map-Write-addr exprs)) _data)))
                      :ruleset conditional-invariant-code-motion)

                ; Compute SameWriteIgnoring-data, which detects opportunities for lifting
                ; Writes through control flow when only the data field varies
                (relation SameWriteIgnoring-data (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Write _addr e1) (Nil))))
                      ((SameWriteIgnoring-data (Cons (Write _addr e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Write _addr e1) (Cons (Write _addr e2) rest)))
                       (SameWriteIgnoring-data (Cons (Write _addr e2) rest)))
                      ((SameWriteIgnoring-data (Cons (Write _addr e1) (Cons (Write _addr e2) rest))))
                      :ruleset always-run)

                ; Given a list of Writes, return a list of each Write's data field
                (function Map-Write-data (ListExpr) ListExpr)
                (rewrite (Map-Write-data (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Write-data (Cons (Write _addr e1) rest))
                         (Cons e1 (Map-Write-data rest))
                         :ruleset always-run)

                ; Lift Write when only data varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameWriteIgnoring-data exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Write _addr e1) rest)))
                      ((union (Switch pred exprs)
                              (Write _addr (Switch pred (Map-Write-data exprs)))))
                      :ruleset conditional-invariant-code-motion)


                ; Compute SameSwitchIgnoring-pred, which detects opportunities for lifting
                ; Switchs through control flow when only the pred field varies
                (relation SameSwitchIgnoring-pred (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Switch e1 _branches) (Nil))))
                      ((SameSwitchIgnoring-pred (Cons (Switch e1 _branches) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Switch e1 _branches) (Cons (Switch e2 _branches) rest)))
                       (SameSwitchIgnoring-pred (Cons (Switch e2 _branches) rest)))
                      ((SameSwitchIgnoring-pred (Cons (Switch e1 _branches) (Cons (Switch e2 _branches) rest))))
                      :ruleset always-run)

                ; Given a list of Switchs, return a list of each Switch's pred field
                (function Map-Switch-pred (ListExpr) ListExpr)
                (rewrite (Map-Switch-pred (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Switch-pred (Cons (Switch e1 _branches) rest))
                         (Cons e1 (Map-Switch-pred rest))
                         :ruleset always-run)

                ; Lift Switch when only pred varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameSwitchIgnoring-pred exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Switch e1 _branches) rest)))
                      ((union (Switch pred exprs)
                              (Switch (Switch pred (Map-Switch-pred exprs)) _branches)))
                      :ruleset conditional-invariant-code-motion)


                ; Compute SameCallIgnoring-arg, which detects opportunities for lifting
                ; Calls through control flow when only the arg field varies
                (relation SameCallIgnoring-arg (ListExpr))
                (rule ((DemandSameIgnoring (Cons (Call _f e1) (Nil))))
                      ((SameCallIgnoring-arg (Cons (Call _f e1) (Nil))))
                      :ruleset always-run)
                (rule ((DemandSameIgnoring (Cons (Call _f e1) (Cons (Call _f e2) rest)))
                       (SameCallIgnoring-arg (Cons (Call _f e2) rest)))
                      ((SameCallIgnoring-arg (Cons (Call _f e1) (Cons (Call _f e2) rest))))
                      :ruleset always-run)

                ; Given a list of Calls, return a list of each Call's arg field
                (function Map-Call-arg (ListExpr) ListExpr)
                (rewrite (Map-Call-arg (Nil)) (Nil) :ruleset always-run)
                (rewrite (Map-Call-arg (Cons (Call _f e1) rest))
                         (Cons e1 (Map-Call-arg rest))
                         :ruleset always-run)

                ; Lift Call when only arg varies
                (rule ((ExprIsValid (Switch pred exprs))
                       (SameCallIgnoring-arg exprs)
                       ; Bind non-varying field(s)
                       (= list (Cons (Call _f e1) rest)))
                      ((union (Switch pred exprs)
                              (Call _f (Switch pred (Map-Call-arg exprs)))))
                      :ruleset conditional-invariant-code-motion)

(let id1 (Id (i64-fresh!)))
(let b1 (Boolean id1 true))
(let n1 (Num id1 1))
(let n2 (Num id1 12))
(let n3 (Num id1 22))
(let n4 (Num id1 0))

(let x (Switch b1 (Pair n2 n2)))
;(let x (Add n2 n3))

(let switch1 (Switch n1 (Pair x x)))
;(let switch1 (Switch n1 (Pair n2 n2)))
(ExprIsValid switch1)

;(ExprIsValid s)
;(ExprIsValid s1)

    
; The main (run) statement for the egglog program

(run-schedule
  (repeat 6
    (saturate always-run)
    (saturate error-checking) ; In the future, this will be "debug mode" only
    simple-pure
    conditional-invariant-code-motion
    switch-rewrites
    function-inlining
    interval-analysis
    ivt
    ; can't add the type-analysis rules here yet until we fix the correctness bug
    ; described in https://github.com/egraphs-good/eggcc/issues/292
    ))


(check (!= n1 n2))
;(check (!= switch1 (Num id1 1))) 
;(check (= switch1 x))
;(check (= x n2))
;(check (= switch1 n2))
    
